<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Tetris</title>
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDwhLS0gTmVvbiBnbG93IGVmZmVjdCBmb3IgZmF2aWNvbiAtLT4KICAgIDxmaWx0ZXIgaWQ9ImZhdmljb25HbG93IiB4PSItMjAlIiB5PSItMjAlIiB3aWR0aD0iMTQwJSIgaGVpZ2h0PSIxNDAlIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiByZXN1bHQ9ImNvbG9yZWRCbHVyIi8+CiAgICAgIDxmZU1lcmdlPiAKICAgICAgICA8ZmVNZXJnZU5vZGUgaW49ImNvbG9yZWRCbHVyIi8+CiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJTb3VyY2VHcmFwaGljIi8+CiAgICAgIDwvZmVNZXJnZT4KICAgIDwvZmlsdGVyPgogICAgCiAgICA8IS0tIEJhY2tncm91bmQgZ3JhZGllbnQgLS0+CiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9ImJnR3JhZGllbnQiIGN4PSI1MCUiIGN5PSI1MCUiIHI9IjUwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMxYTFhMmU7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzBmMGYyMztzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgPC9kZWZzPgogIAogIDwhLS0gQmFja2dyb3VuZCAtLT4KICA8cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9InVybCgjYmdHcmFkaWVudCkiIHJ4PSI4IiByeT0iOCIvPgogIAogIDwhLS0gQ2xhc3NpYyBULXBpZWNlIGluIHRoZSBjZW50ZXIgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAsIDE2KSI+CiAgICA8IS0tIFRvcCBob3Jpem9udGFsIGJhciAtLT4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMTYiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8IS0tIFZlcnRpY2FsIHN0ZW0gLS0+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIyNCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI2Zhdmljb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBTbWFsbCBhY2NlbnQgYmxvY2tzIGZvciBkZXRhaWwgLS0+CiAgPGcgb3BhY2l0eT0iMC43Ij4KICAgIDwhLS0gVG9wIGxlZnQgLS0+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDBGRkZGIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgICA8IS0tIFRvcCByaWdodCAtLT4KICAgIDxyZWN0IHg9IjUyIiB5PSI4IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgICA8IS0tIEJvdHRvbSBsZWZ0IC0tPgogICAgPHJlY3QgeD0iOCIgeT0iNTIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIwLjUiLz4KICAgIDwhLS0gQm90dG9tIHJpZ2h0IC0tPgogICAgPHJlY3QgeD0iNTIiIHk9IjUyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgPC9nPgogIAogIDwhLS0gQm9yZGVyIGdsb3cgLS0+CiAgPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSJub25lIiBzdHJva2U9InJnYmEoNTcsIDI1NSwgMjAsIDAuNCkiIHN0cm9rZS13aWR0aD0iMSIgcng9IjgiIHJ5PSI4IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIi8+Cjwvc3ZnPg==">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
    
    <!-- PWA Manifest -->
    
    <meta name="theme-color" content="#0f0f23">
    <meta name="description" content="Modern Tetris game with neon graphics and 90s-style music">
    
    
    
    
    
    
<style>

/* styles/main.css */
/* Modern Tetris - Main Styles */

:root {
    --primary-bg: #0a0a0a;
    --secondary-bg: #1a1a2e;
    --accent-bg: #16213e;
    --glass-bg: rgba(255, 255, 255, 0.1);
    
    --neon-blue: #00d4ff;
    --neon-purple: #9d4edd;
    --neon-pink: #ff006e;
    --neon-green: #39ff14;
    --neon-yellow: #ffff00;
    --neon-orange: #ff8500;
    --neon-red: #ff0040;
    
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-accent: var(--neon-blue);
    
    --shadow-glow: 0 0 20px rgba(0, 212, 255, 0.3);
    --shadow-strong: 0 0 30px rgba(0, 212, 255, 0.5);
    --border-radius: 12px;
    
    --font-primary: 'Orbitron', monospace;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-primary);
    background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 50%, var(--accent-bg) 100%);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
    pointer-events: none;
    z-index: -1;
}

.app {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}

/* Header Styles */
.header {
    margin-bottom: 30px;
    z-index: 10;
}

.header-top {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.header-controls {
    display: flex;
    gap: 10px;
}

.btn-icon {
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: var(--text-primary);
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-icon:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-glow);
    transform: translateY(-2px);
}

.btn-icon.muted {
    color: var(--neon-red);
    border-color: var(--neon-red);
}

/* Logo Styles */
.logo-container {
    display: flex;
    align-items: center;
    gap: 15px;
}

.logo {
    height: 60px;
    width: auto;
    filter: drop-shadow(0 0 10px rgba(57, 255, 20, 0.5));
    transition: all 0.3s ease;
}

.logo:hover {
    filter: drop-shadow(0 0 15px rgba(57, 255, 20, 0.8));
    transform: scale(1.05);
}

.title {
    font-size: clamp(2rem, 6vw, 4rem);
    font-weight: 900;
    letter-spacing: 0.2em;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-pink));
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: var(--shadow-glow);
    animation: gradient-shift 3s ease-in-out infinite;
    margin: 0;
}

/* Screen reader only class */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.controls-hint {
    display: flex;
    gap: 20px;
    justify-content: center;
    flex-wrap: wrap;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.controls-hint span {
    padding: 8px 16px;
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    transition: all 0.3s ease;
}

.controls-hint span:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-glow);
}

/* Game Container */
.game-container {
    display: grid;
    grid-template-columns: 200px 1fr 200px;
    gap: 30px;
    align-items: start;
    max-width: 1200px;
    width: 100%;
}

/* Sidebars */
.game-sidebar {
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.hold-area, .next-area, .stats,
.hold-stats-card, .next-pieces-card, .info-panel, .next-panel {
    background: var(--glass-bg);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: var(--border-radius);
    padding: 20px;
    box-shadow: var(--shadow-glow);
    position: relative;
    overflow: hidden;
}

/* Default desktop layout */
.game-container {
    display: grid;
    grid-template-columns: 220px 1fr 220px;
    gap: 25px;
    max-width: 1200px;
    margin: 0 auto;
}

/* Show desktop sidebars by default */
.game-sidebar {
    display: block;
}

/* Hide mobile panels by default */
.info-panel, .next-panel {
    display: none;
}

.hold-area::before, .next-area::before, .stats::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    border-radius: var(--border-radius);
    z-index: -1;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.hold-area:hover::before, .next-area:hover::before, .stats:hover::before {
    opacity: 0.3;
}

.hold-area h3, .next-area h3 {
    color: var(--text-accent);
    font-size: 1.1rem;
    font-weight: 700;
    text-align: center;
    margin-bottom: 15px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.hold-piece, .next-piece {
    width: 80px;
    height: 80px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: all 0.3s ease;
}

.next-pieces {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.next-piece:first-child {
    transform: scale(1.1);
    border-color: var(--neon-blue);
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

/* Stats */
.stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.stat:last-child {
    border-bottom: none;
}

.stat-label {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.stat-value {
    color: var(--neon-blue);
    font-weight: 700;
    font-size: 1.2rem;
    text-shadow: 0 0 10px currentColor;
}

/* Game Board */
.game-board {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 600px;
}

#game-canvas {
    background: var(--glass-bg);
    backdrop-filter: blur(15px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-strong);
    max-width: 100%;
    height: auto;
}

/* Game Overlay */
.game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--border-radius);
    z-index: 100;
}

.overlay-content {
    text-align: center;
    padding: 40px;
}

#overlay-title {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text-accent);
    margin-bottom: 20px;
    text-shadow: var(--shadow-glow);
}

#overlay-message {
    font-size: 1.2rem;
    color: var(--text-secondary);
    margin-bottom: 30px;
}

/* Buttons */
.btn-primary, .btn-secondary {
    padding: 15px 30px;
    font-family: var(--font-primary);
    font-size: 1rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 0 10px;
    position: relative;
    overflow: hidden;
}

.btn-primary {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    color: white;
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.6);
}

.btn-secondary {
    background: transparent;
    color: var(--text-secondary);
    border: 2px solid var(--text-secondary);
}

.btn-secondary:hover {
    color: var(--text-primary);
    border-color: var(--text-primary);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
}

/* Particles Container */
.particles-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
}

/* Hidden by default */
.game-overlay.hidden {
    display: none;
}

/* Player Name Input Modal */
.name-input-overlay, .leaderboard-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    animation: fade-in 0.3s ease-out;
}

.name-input-content, .leaderboard-content {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--border-radius);
    padding: 30px;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: var(--shadow-strong);
    position: relative;
}

.name-input-content h2, .leaderboard-content h2 {
    color: var(--neon-blue);
    font-size: 2rem;
    margin-bottom: 15px;
    text-shadow: var(--shadow-glow);
}

.name-input-content p {
    color: var(--text-secondary);
    font-size: 1.1rem;
    margin-bottom: 25px;
}

.input-group {
    margin-bottom: 25px;
}

#player-name-input {
    width: 100%;
    padding: 15px 20px;
    font-family: var(--font-primary);
    font-size: 1.1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    color: var(--text-primary);
    text-align: center;
    margin-bottom: 20px;
    transition: all 0.3s ease;
}

#player-name-input:focus {
    outline: none;
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    background: rgba(255, 255, 255, 0.15);
}

#player-name-input::placeholder {
    color: var(--text-secondary);
    opacity: 0.7;
}

.input-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.score-summary {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 25px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--border-radius);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.score-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.score-item span:first-child {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.score-item span:last-child {
    color: var(--neon-blue);
    font-size: 1.4rem;
    font-weight: 700;
    text-shadow: 0 0 10px currentColor;
}

/* Leaderboard Mode Selector */
.mode-selector-container {
    margin: 15px 0;
    padding: 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
}

.mode-selector {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.mode-select-btn {
    background: var(--glass-bg);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    padding: 8px 15px;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9rem;
}

.mode-select-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.mode-select-btn.active {
    background: var(--neon-blue);
    color: var(--primary-bg);
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
}

.mode-icon {
    font-size: 1.2rem;
}

/* Mode-specific leaderboard entries */
.entry-time,
.entry-puzzle,
.entry-checkpoint,
.entry-duration,
.entry-wins {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 3px;
}

.entry-puzzle {
    color: #ff8800;
}

.entry-time {
    color: #ff00ff;
    font-weight: bold;
}

/* Leaderboard Styles */
.leaderboard-content {
    max-width: 700px;
    max-height: 80vh;
    overflow: hidden;
}

.leaderboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
}

.btn-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 2rem;
    font-weight: bold;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.btn-close:hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
}

.leaderboard-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 25px;
    padding: 5px;
}

.tab-button {
    flex: 1;
    padding: 10px 20px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-primary);
    font-weight: 600;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.tab-button.active {
    background: var(--neon-blue);
    color: white;
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

.tab-button:not(.active):hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
}

.leaderboard-list {
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 50px 1fr 100px 60px 60px;
    gap: 15px;
    align-items: center;
    padding: 15px 20px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: var(--border-radius);
    margin-bottom: 10px;
    transition: all 0.3s ease;
}

.leaderboard-entry:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: var(--neon-blue);
}

.entry-rank {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--neon-blue);
    text-align: center;
}

.entry-rank.gold { color: var(--neon-yellow); }
.entry-rank.silver { color: #c0c0c0; }
.entry-rank.bronze { color: #cd7f32; }

.entry-name {
    font-weight: 600;
    color: var(--text-primary);
}

.entry-score {
    font-weight: 700;
    color: var(--neon-green);
    text-align: right;
}

.entry-lines, .entry-level {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-align: center;
}

.loading {
    text-align: center;
    color: var(--text-secondary);
    padding: 40px;
    font-size: 1.1rem;
}

.error-message {
    text-align: center;
    color: var(--neon-red);
    padding: 20px;
    background: rgba(255, 0, 64, 0.1);
    border: 1px solid rgba(255, 0, 64, 0.3);
    border-radius: var(--border-radius);
    margin: 10px 0;
}

/* Settings Modal Styles */
.settings-overlay, .help-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    animation: fade-in 0.3s ease-out;
}

.settings-content, .help-content {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--border-radius);
    padding: 30px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: var(--shadow-strong);
    position: relative;
}

.settings-header, .help-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
}

.settings-header h2, .help-header h2 {
    color: var(--neon-blue);
    font-size: 1.8rem;
    margin: 0;
    text-shadow: var(--shadow-glow);
}

.settings-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 25px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 25px;
    padding: 5px;
}

.settings-tab-button {
    flex: 1;
    padding: 12px 20px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-primary);
    font-weight: 600;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.settings-tab-button.active {
    background: var(--neon-blue);
    color: white;
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

.settings-tab-button:not(.active):hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
}

.settings-panel {
    animation: fade-in 0.3s ease-out;
}

.setting-group {
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--border-radius);
    border: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.setting-group > label {
    color: var(--text-primary);
    font-weight: 600;
    font-size: 1.1rem;
    margin: 0;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 15px;
}

.volume-control input[type="range"] {
    flex: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
}

.volume-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--neon-blue);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

.volume-control input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--neon-blue);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

.volume-control span {
    color: var(--neon-blue);
    font-weight: 700;
    min-width: 40px;
    text-align: center;
}

.setting-toggle {
    display: flex;
    align-items: center;
    justify-content: flex-start;
}

.toggle-switch {
    display: flex;
    align-items: center;
    gap: 15px;
    cursor: pointer;
}

.toggle-switch input[type="checkbox"] {
    display: none;
}

.toggle-slider {
    position: relative;
    width: 50px;
    height: 26px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 13px;
    transition: all 0.3s ease;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 22px;
    height: 22px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle-switch input[type="checkbox"]:checked + .toggle-slider {
    background: var(--neon-blue);
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
}

.toggle-switch input[type="checkbox"]:checked + .toggle-slider::before {
    transform: translateX(24px);
}

.toggle-label {
    color: var(--text-primary);
    font-weight: 600;
}

/* Controls Display */
.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 25px;
}

.control-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.control-key {
    background: var(--neon-blue);
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    font-family: var(--font-primary);
    font-weight: 700;
    font-size: 0.9rem;
    min-width: 50px;
    text-align: center;
    box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
}

.control-action {
    color: var(--text-primary);
    font-weight: 500;
}

.controls-info h3 {
    color: var(--neon-blue);
    margin-bottom: 15px;
    margin-top: 25px;
    font-size: 1.2rem;
    text-shadow: 0 0 8px currentColor;
}

.controls-info h3:first-child {
    margin-top: 0;
}

/* Touch Controls */
.touch-controls-info {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.touch-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.touch-gesture {
    font-size: 1rem;
    min-width: 100px;
    background: var(--neon-purple);
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    font-weight: 600;
    text-align: center;
    box-shadow: 0 0 8px rgba(157, 78, 221, 0.3);
}

/* Help Modal Specific Styles */
.help-sections {
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.help-section h3 {
    color: var(--neon-blue);
    font-size: 1.3rem;
    margin-bottom: 15px;
    text-shadow: 0 0 8px currentColor;
}

.help-section p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 15px;
}

.special-moves, .scoring-info {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.special-item, .score-item {
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.special-item {
    color: var(--text-secondary);
    line-height: 1.5;
}

.special-item strong {
    color: var(--text-accent);
}

.score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.score-item span:first-child {
    color: var(--text-secondary);
}

.score-item span:last-child {
    color: var(--neon-green);
    font-weight: 700;
}

.quick-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
}

/* Offline Mode Indicators */
.offline-indicator {
    position: fixed;
    top: 70px;
    right: 20px;
    background: var(--bg-dark);
    border: 2px solid var(--neon-orange);
    border-radius: 10px;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9rem;
    z-index: 1000;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(255, 159, 64, 0.3);
}

.offline-indicator.visible {
    opacity: 1;
    transform: translateY(0);
}

.offline-indicator.offline {
    border-color: var(--neon-red);
    box-shadow: 0 0 20px rgba(255, 89, 94, 0.3);
}

.offline-indicator.syncing {
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
}

.offline-indicator .offline-icon,
.offline-indicator .sync-icon {
    font-size: 1.2rem;
    animation: pulse 2s infinite;
}

.offline-indicator .pending-count {
    background: var(--neon-orange);
    color: var(--bg-dark);
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: bold;
    font-size: 0.8rem;
}

/* Offline Notifications */
.offline-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--bg-dark);
    border: 2px solid var(--neon-blue);
    border-radius: 10px;
    padding: 15px 20px;
    max-width: 300px;
    z-index: 10000;
    opacity: 0;
    transform: translateX(400px);
    transition: all 0.3s ease;
}

.offline-notification.visible {
    opacity: 1;
    transform: translateX(0);
}

.offline-notification.success {
    border-color: var(--neon-green);
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.offline-notification.warning {
    border-color: var(--neon-orange);
    box-shadow: 0 0 20px rgba(255, 159, 64, 0.3);
}

.offline-notification.error {
    border-color: var(--neon-red);
    box-shadow: 0 0 20px rgba(255, 89, 94, 0.3);
}

.offline-notification.info {
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
}

/* Update Notification */
.update-notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-dark);
    border: 2px solid var(--neon-green);
    border-radius: 10px;
    padding: 15px 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 10001;
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
    animation: slideDown 0.5s ease;
}

.update-notification button {
    background: var(--neon-green);
    color: var(--bg-dark);
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.update-notification button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
}

/* PWA Install Button */
.pwa-install {
    background: linear-gradient(135deg, var(--neon-purple), var(--neon-blue));
    border: 2px solid transparent;
    animation: gradient-border 3s ease infinite;
}

.pwa-install:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(187, 134, 252, 0.5);
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-100px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes gradient-border {
    0%, 100% {
        border-color: var(--neon-purple);
    }
    50% {
        border-color: var(--neon-blue);
    }
}

/* styles/animations.css */
/* Modern Tetris - Animations */

/* Gradient Animation */
@keyframes gradient-shift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Piece Drop Animation */
@keyframes piece-drop {
    0% { transform: translateY(-20px) scale(1.1); opacity: 0.8; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

/* Line Clear Animation */
@keyframes line-clear {
    0% { 
        background: rgba(255, 255, 255, 0.9);
        transform: scaleX(1);
        opacity: 1;
    }
    50% { 
        background: var(--neon-blue);
        transform: scaleX(1.1);
        opacity: 0.8;
    }
    100% { 
        background: transparent;
        transform: scaleX(0);
        opacity: 0;
    }
}

/* Glow Pulse Animation */
@keyframes glow-pulse {
    0%, 100% { 
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        filter: brightness(1);
    }
    50% { 
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.6);
        filter: brightness(1.2);
    }
}

/* Particle Animation */
@keyframes particle-float {
    0% {
        transform: translateY(0) rotate(0deg) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-100px) rotate(360deg) scale(0);
        opacity: 0;
    }
}

/* Shake Animation for Game Over */
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Bounce Animation for Piece Landing */
@keyframes bounce-land {
    0% { transform: translateY(0); }
    20% { transform: translateY(-5px); }
    40% { transform: translateY(0); }
    60% { transform: translateY(-2px); }
    80% { transform: translateY(0); }
    100% { transform: translateY(0); }
}

/* Score Pop Animation */
@keyframes score-pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); color: var(--neon-green); }
    100% { transform: scale(1); }
}

/* Hold Piece Swap Animation */
@keyframes hold-swap {
    0% { transform: scale(1) rotate(0deg); opacity: 1; }
    50% { transform: scale(0.8) rotate(180deg); opacity: 0.5; }
    100% { transform: scale(1) rotate(360deg); opacity: 1; }
}

/* Next Piece Slide Animation */
@keyframes next-slide {
    0% { transform: translateX(100px); opacity: 0; }
    100% { transform: translateX(0); opacity: 1; }
}

/* Button Hover Effect */
@keyframes button-glow {
    0% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }
    100% { box-shadow: 0 0 30px rgba(0, 212, 255, 0.8); }
}

/* Level Up Animation */
@keyframes level-up {
    0% { 
        transform: scale(1);
        color: var(--text-accent);
    }
    25% { 
        transform: scale(1.2);
        color: var(--neon-green);
        text-shadow: 0 0 20px var(--neon-green);
    }
    50% { 
        transform: scale(1.1);
        color: var(--neon-yellow);
        text-shadow: 0 0 15px var(--neon-yellow);
    }
    75% { 
        transform: scale(1.15);
        color: var(--neon-pink);
        text-shadow: 0 0 25px var(--neon-pink);
    }
    100% { 
        transform: scale(1);
        color: var(--text-accent);
        text-shadow: var(--shadow-glow);
    }
}

/* Ghost Piece Fade */
@keyframes ghost-fade {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
}

/* T-Spin Flash */
@keyframes tspin-flash {
    0% { background: transparent; }
    25% { background: var(--neon-purple); }
    50% { background: var(--neon-pink); }
    75% { background: var(--neon-blue); }
    100% { background: transparent; }
}

/* Combo Multiplier */
@keyframes combo-multiplier {
    0% { 
        transform: scale(1) rotate(0deg);
        color: var(--text-primary);
    }
    50% { 
        transform: scale(1.5) rotate(5deg);
        color: var(--neon-orange);
        text-shadow: 0 0 30px var(--neon-orange);
    }
    100% { 
        transform: scale(1) rotate(0deg);
        color: var(--text-primary);
    }
}

/* Background Pattern Animation */
@keyframes bg-pattern {
    0% { transform: translateX(0) translateY(0); }
    100% { transform: translateX(-50px) translateY(-50px); }
}

/* Piece Rotation Effect */
@keyframes piece-rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(90deg); }
}

/* Game Over Screen Animation */
@keyframes game-over {
    0% { 
        transform: scale(0.8);
        opacity: 0;
    }
    50% { 
        transform: scale(1.1);
        opacity: 0.8;
    }
    100% { 
        transform: scale(1);
        opacity: 1;
    }
}

/* Utility Classes for Animations */
.animate-drop { animation: piece-drop 0.3s ease-out; }
.animate-clear { animation: line-clear 0.5s ease-in-out; }
.animate-glow { animation: glow-pulse 2s ease-in-out infinite; }
.animate-bounce { animation: bounce-land 0.4s ease-out; }
.animate-score-pop { animation: score-pop 0.4s ease-out; }
.animate-shake { animation: shake 0.5s ease-in-out; }
.animate-level-up { animation: level-up 1s ease-in-out; }
.animate-ghost { animation: ghost-fade 1.5s ease-in-out infinite; }
.animate-tspin { animation: tspin-flash 0.3s ease-in-out; }
.animate-combo { animation: combo-multiplier 0.6s ease-out; }
.animate-game-over { animation: game-over 0.8s ease-out; }

/* Particle Effects */
.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: var(--neon-blue);
    border-radius: 50%;
    pointer-events: none;
    animation: particle-float 2s ease-out forwards;
}

.particle.pink { background: var(--neon-pink); }
.particle.green { background: var(--neon-green); }
.particle.yellow { background: var(--neon-yellow); }
.particle.purple { background: var(--neon-purple); }

/* Transition Effects */
.smooth-transition {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.fade-in {
    animation: fade-in 0.5s ease-out;
}

@keyframes fade-in {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-in-right {
    animation: slide-in-right 0.4s ease-out;
}

@keyframes slide-in-right {
    from { transform: translateX(100px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

/* styles/responsive.css */
/* Modern Tetris - Responsive Styles */

/* Mobile First Approach */

/* Small Mobile Devices (320px - 480px) */
@media (max-width: 480px) {
    .app {
        padding: 10px;
    }
    
    
    .logo {
        height: 40px;
    }
    
    .logo-container {
        gap: 10px;
    }
    
    .title {
        font-size: 2rem;
        margin-bottom: 10px;
    }
    
    /* Better mobile controls hint */
    .controls-hint {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.75rem;
        padding: 12px;
        background: rgba(0, 255, 255, 0.1);
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.3);
        margin-bottom: 15px;
    }
    
    .controls-hint span {
        padding: 6px 10px;
        font-size: 0.7rem;
        background: rgba(0, 255, 255, 0.2);
        border-radius: 4px;
        text-align: center;
        flex: 1;
        min-width: 120px;
    }
    
    /* Header controls with better spacing */
    .header-controls {
        gap: 12px;
    }
    
    .btn-icon {
        padding: 10px;
        font-size: 1.1rem;
    }
    
    /* Hide desktop layout, show compact mobile layout */
    .game-sidebar {
        display: none !important;
    }
    
    .info-panel, .next-panel {
        display: block !important;
    }
    
    /* Compact two-column layout */
    .game-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 12px;
        max-width: 100%;
    }
    
    /* Info panel (hold + stats combined) */
    .info-panel {
        grid-column: 1;
        grid-row: 1;
    }
    
    .hold-stats-card {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .hold-section {
        text-align: center;
    }
    
    .hold-section h4 {
        margin: 0 0 8px 0;
        font-size: 0.9rem;
        color: var(--neon-blue);
        font-weight: 600;
    }
    
    .hold-piece {
        width: 45px;
        height: 45px;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 4px;
    }
    
    .stats-section {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    .stat-compact {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 2px 0;
    }
    
    .stat-label-small {
        font-size: 0.75rem;
        color: var(--text-secondary);
        font-weight: 500;
    }
    
    .stat-value-small {
        font-size: 0.85rem;
        color: var(--neon-blue);
        font-weight: 600;
        font-family: 'Orbitron', monospace;
    }
    
    /* Next pieces panel */
    .next-panel {
        grid-column: 2;
        grid-row: 1;
    }
    
    .next-pieces-card {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 12px;
        text-align: center;
    }
    
    .next-pieces-card h4 {
        margin: 0 0 10px 0;
        font-size: 0.9rem;
        color: var(--neon-blue);
        font-weight: 600;
    }
    
    .next-pieces-compact {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: center;
    }
    
    .next-piece-small {
        width: 35px;
        height: 35px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 3px;
    }
    
    /* Game board spans both columns */
    .game-board {
        grid-column: 1 / -1;
        grid-row: 2;
        display: flex;
        justify-content: center;
    }
    
    #game-canvas {
        width: 100%;
        max-width: 280px;
        height: 560px;
    }
    
    #overlay-title {
        font-size: 1.8rem;
    }
    
    #overlay-message {
        font-size: 1rem;
    }
    
    .btn-primary, .btn-secondary {
        padding: 15px 24px;
        font-size: 1rem;
        margin: 8px;
        min-height: 50px;
        border-radius: 8px;
    }
}

/* Large Mobile / Small Tablet (481px - 768px) */
@media (min-width: 481px) and (max-width: 768px) {
    /* Hide desktop layout, show compact layout */
    .game-sidebar {
        display: none !important;
    }
    
    .info-panel, .next-panel {
        display: block !important;
    }
    
    .game-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 20px;
        max-width: 500px;
        margin: 0 auto;
    }
    
    .info-panel {
        grid-column: 1;
        grid-row: 1;
    }
    
    .hold-stats-card {
        padding: 15px;
    }
    
    .hold-piece {
        width: 55px;
        height: 55px;
    }
    
    .stat-label-small {
        font-size: 0.8rem;
    }
    
    .stat-value-small {
        font-size: 0.9rem;
    }
    
    .next-panel {
        grid-column: 2;
        grid-row: 1;
    }
    
    .next-pieces-card {
        padding: 15px;
    }
    
    .next-piece-small {
        width: 40px;
        height: 40px;
    }
    
    .game-board {
        grid-column: 1 / -1;
        grid-row: 2;
        display: flex;
        justify-content: center;
    }
    
    #game-canvas {
        width: 100%;
        max-width: 350px;
        height: 700px;
    }
    
    .title {
        font-size: 3rem;
    }
    
    .controls-hint {
        font-size: 0.8rem;
    }
}

/* Tablets (769px - 1024px) */
@media (min-width: 769px) and (max-width: 1024px) {
    /* Use traditional 3-column layout for tablets */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 180px 1fr 180px;
        gap: 25px;
        max-width: 800px;
    }
    
    #game-canvas {
        width: 350px;
        height: 700px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 18px;
    }
    
    .hold-piece, .next-piece {
        width: 70px;
        height: 70px;
    }
    
    .title {
        font-size: 3.5rem;
    }
}

/* Desktop (1025px and up) */
@media (min-width: 1025px) {
    /* Use traditional 3-column layout for desktop */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 220px 1fr 220px;
        gap: 35px;
    }
    
    #game-canvas {
        width: 400px;
        height: 800px;
    }
    
    .title {
        font-size: 4rem;
    }
}

/* Large Desktop (1441px and up) */
@media (min-width: 1441px) {
    /* Use traditional 3-column layout for large desktop */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 250px 1fr 250px;
        gap: 40px;
    }
    
    #game-canvas {
        width: 450px;
        height: 900px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 25px;
    }
    
    .hold-piece, .next-piece {
        width: 90px;
        height: 90px;
    }
}

/* Landscape Orientation for Mobile */
@media (max-height: 600px) and (orientation: landscape) {
    .app {
        padding: 10px;
    }
    
    .header {
        margin-bottom: 15px;
    }
    
    .title {
        font-size: 2rem;
        margin-bottom: 5px;
    }
    
    .controls-hint {
        display: none;
    }
    
    .game-container {
        grid-template-columns: 150px 1fr 150px;
        gap: 15px;
        max-width: 100%;
    }
    
    #game-canvas {
        width: 300px;
        height: 450px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 10px;
        font-size: 0.85rem;
    }
    
    .hold-area h3, .next-area h3 {
        font-size: 0.9rem;
        margin-bottom: 10px;
    }
    
    .hold-piece, .next-piece {
        width: 50px;
        height: 50px;
    }
    
    .stat {
        padding: 6px 0;
    }
    
    .stat-value {
        font-size: 0.9rem;
    }
}

/* High DPI / Retina Displays */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    #game-canvas {
        image-rendering: -webkit-crisp-edges;
        image-rendering: crisp-edges;
    }
}

/* Reduced Motion Preference */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .title {
        animation: none;
        background: var(--neon-blue);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .animate-glow {
        animation: none;
        box-shadow: var(--shadow-glow);
    }
    
    .animate-ghost {
        animation: none;
        opacity: 0.4;
    }
}

/* Dark Mode (System Preference) */
@media (prefers-color-scheme: dark) {
    :root {
        --primary-bg: #000000;
        --secondary-bg: #111111;
        --accent-bg: #1a1a1a;
    }
}

/* Light Mode Override */
@media (prefers-color-scheme: light) {
    :root {
        --primary-bg: #1a1a2e;
        --secondary-bg: #16213e;
        --accent-bg: #0f0f1a;
    }
}

/* Focus States for Keyboard Navigation */
@media (any-hover: none) {
    .btn-primary:focus,
    .btn-secondary:focus {
        outline: 2px solid var(--neon-blue);
        outline-offset: 2px;
    }
    
    .hold-piece:focus,
    .next-piece:focus {
        outline: 1px solid var(--neon-blue);
    }
}

/* Touch Device Optimizations */
@media (hover: none) and (pointer: coarse) {
    /* Improve button touch targets and feedback */
    .btn-primary, .btn-secondary, .btn-icon, .btn-close {
        min-height: 44px; /* Apple's recommended minimum touch target */
        min-width: 44px;
        touch-action: manipulation; /* Prevents double-tap zoom */
        user-select: none; /* Prevents text selection on long press */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* Remove tap highlight */
    }
    
    /* Active state for better touch feedback */
    .btn-primary.touch-active,
    .btn-secondary.touch-active,
    .btn-icon.touch-active,
    .btn-close.touch-active {
        transform: scale(0.95);
        opacity: 0.8;
        transition: all 0.1s ease;
    }
    
    /* Remove hover effects that don't work on touch */
    .controls-hint span:hover {
        background: var(--glass-bg);
        box-shadow: none;
    }
    
    .btn-primary:hover,
    .btn-secondary:hover {
        transform: none;
    }
    
    .hold-area:hover::before,
    .next-area:hover::before,
    .stats:hover::before {
        opacity: 0;
    }
    
    /* Better touch targets for modal interactions */
    .name-input-content, .leaderboard-content, .settings-content, .help-content {
        touch-action: manipulation;
    }
    
    /* Improve input field touch experience */
    input, select, textarea {
        touch-action: manipulation;
        min-height: 44px;
        font-size: 16px; /* Prevents zoom on iOS */
    }
    
    /* Game canvas touch optimization */
    #game-canvas {
        touch-action: none; /* Allow custom touch handling */
        user-select: none;
    }
    
    /* Tab buttons in modals */
    .tab-button, .settings-tab-button {
        min-height: 44px;
        touch-action: manipulation;
    }
    
    /* Leaderboard entries should be easier to see on touch */
    .leaderboard-entry {
        min-height: 50px;
    }
}

/* Modal Responsive Styles */
@media (max-width: 480px) {
    .name-input-content, .leaderboard-content {
        padding: 20px;
        margin: 10px;
        max-width: 95%;
    }
    
    .name-input-content h2 {
        font-size: 1.5rem;
    }
    
    .score-summary {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .input-buttons {
        flex-direction: column;
        gap: 10px;
    }
    
    .btn-primary, .btn-secondary {
        width: 100%;
        margin: 5px 0;
        min-height: 50px;
    }
    
    .leaderboard-entry {
        grid-template-columns: 40px 1fr 80px;
        gap: 10px;
        padding: 12px 15px;
        font-size: 0.9rem;
    }
    
    .entry-lines, .entry-level {
        display: none;
    }
    
    .leaderboard-tabs {
        flex-direction: column;
        gap: 5px;
    }
    
    .tab-button {
        padding: 12px;
    }
}

@media (min-width: 481px) and (max-width: 768px) {
    .name-input-content, .leaderboard-content {
        padding: 25px;
        max-width: 90%;
    }
    
    .score-summary {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .leaderboard-entry {
        grid-template-columns: 45px 1fr 90px 50px 50px;
        font-size: 0.95rem;
    }
}

/* Print Styles */
@media print {
    .app {
        background: white;
        color: black;
    }
    
    .game-container {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .game-sidebar {
        display: none;
    }
    
    #game-canvas {
        border: 2px solid black;
        background: white;
    }
    
    .particles-container {
        display: none;
    }
    
    .name-input-overlay, .leaderboard-overlay {
        display: none !important;
    }
}

/* styles/modes.css */
/* Game Modes Styles */

/* Mode Selector Modal */
.mode-selector-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease;
}

.mode-selector-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
    border: 2px solid var(--neon-blue);
    border-radius: 20px;
    padding: 40px;
    max-width: 900px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
}

.mode-selector-content h2 {
    text-align: center;
    color: var(--neon-blue);
    margin-bottom: 30px;
    font-size: 2rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

/* Mode Grid */
.mode-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.mode-card {
    background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
    border: 2px solid transparent;
    border-radius: 15px;
    padding: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.mode-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.05), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.mode-card:hover::before {
    transform: translateX(100%);
}

.mode-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

/* Mode specific colors */
.mode-card[data-mode="classic"] {
    border-color: #00ffff;
}
.mode-card[data-mode="classic"]:hover {
    border-color: #00ffff;
    box-shadow: 0 10px 30px rgba(0, 255, 255, 0.3);
}

.mode-card[data-mode="sprint"] {
    border-color: #ff00ff;
}
.mode-card[data-mode="sprint"]:hover {
    border-color: #ff00ff;
    box-shadow: 0 10px 30px rgba(255, 0, 255, 0.3);
}

.mode-card[data-mode="marathon"] {
    border-color: #ffff00;
}
.mode-card[data-mode="marathon"]:hover {
    border-color: #ffff00;
    box-shadow: 0 10px 30px rgba(255, 255, 0, 0.3);
}

.mode-card[data-mode="zen"] {
    border-color: #00ff00;
}
.mode-card[data-mode="zen"]:hover {
    border-color: #00ff00;
    box-shadow: 0 10px 30px rgba(0, 255, 0, 0.3);
}

.mode-card[data-mode="puzzle"] {
    border-color: #ff8800;
}
.mode-card[data-mode="puzzle"]:hover {
    border-color: #ff8800;
    box-shadow: 0 10px 30px rgba(255, 136, 0, 0.3);
}

.mode-card[data-mode="battle"] {
    border-color: #ff0000;
}
.mode-card[data-mode="battle"]:hover {
    border-color: #ff0000;
    box-shadow: 0 10px 30px rgba(255, 0, 0, 0.3);
}

.mode-icon {
    font-size: 3rem;
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

.mode-card h3 {
    color: #fff;
    margin-bottom: 10px;
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.mode-card p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    line-height: 1.4;
}

/* Close button */
.close-mode-selector {
    position: absolute;
    top: 20px;
    right: 20px;
    background: transparent;
    border: 2px solid var(--neon-blue);
    color: var(--neon-blue);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-mode-selector:hover {
    background: var(--neon-blue);
    color: #0f0f23;
    transform: rotate(90deg);
}

/* Mode UI Elements */
.mode-indicator {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
    border: 2px solid var(--neon-blue);
    border-radius: 20px;
    padding: 5px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 100;
}

.mode-indicator-icon {
    font-size: 1.2rem;
}

.mode-indicator-name {
    color: var(--neon-blue);
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Mode Specific UI Container */
.mode-specific-ui {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    pointer-events: none;
}

/* Sprint Mode Timer */
#mode-timer,
.sprint-timer {
    font-size: 1.8rem;
    color: #ff00ff;
    text-align: center;
    font-family: 'Courier New', 'Orbitron', monospace;
    font-variant-numeric: tabular-nums;
    text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    min-width: 240px;
    width: 240px;
    display: block;
    background: rgba(0, 0, 0, 0.8);
    padding: 12px 15px;
    border-radius: 10px;
    border: 2px solid #ff00ff;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    letter-spacing: 2px;
}

.sprint-best-time {
    font-size: 1rem;
    color: rgba(255, 0, 255, 0.7);
    text-align: center;
    margin-top: 5px;
}

/* Marathon Mode Progress */
.marathon-progress {
    width: 100%;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #ffff00;
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
}

.marathon-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #ffff00, #ff8800);
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
}

.marathon-checkpoint {
    color: #ffff00;
    text-align: center;
    font-weight: bold;
    margin-top: 5px;
}

/* Zen Mode Stats */
.zen-stats {
    background: rgba(0, 255, 0, 0.1);
    border: 1px solid #00ff00;
    border-radius: 10px;
    padding: 10px;
    margin: 10px 0;
}

.zen-stat-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    color: rgba(0, 255, 0, 0.9);
}

.zen-export-btn {
    background: #00ff00;
    color: #0f0f23;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.3s ease;
}

.zen-export-btn:hover {
    background: #00cc00;
    transform: scale(1.05);
}

/* Puzzle Mode UI */
.puzzle-number {
    background: rgba(255, 136, 0, 0.2);
    border: 1px solid #ff8800;
    border-radius: 8px;
    padding: 8px 15px;
    margin: 5px 0;
    text-align: center;
    min-width: 150px;
}

.puzzle-number-text {
    color: #ff8800;
    font-size: 1.1rem;
    font-weight: bold;
    text-transform: uppercase;
}

.puzzle-objective {
    background: linear-gradient(135deg, rgba(255, 136, 0, 0.2), rgba(255, 136, 0, 0.1));
    border: 2px solid #ff8800;
    border-radius: 10px;
    padding: 15px 20px;
    margin: 10px 0;
    text-align: center;
    box-shadow: 0 0 15px rgba(255, 136, 0, 0.3);
    min-width: 280px;
}

.puzzle-objective-title {
    color: #ff8800;
    font-size: 1.3rem;
    font-weight: bold;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(255, 136, 0, 0.5);
}

#puzzle-objective-text {
    color: #ffffff;
    font-size: 1.1rem;
    font-weight: 600;
    background: rgba(0, 0, 0, 0.3);
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.puzzle-pieces {
    background: rgba(100, 100, 255, 0.1);
    border: 2px solid #6666ff;
    border-radius: 10px;
    padding: 12px 20px;
    margin: 10px 0;
    text-align: center;
    min-width: 200px;
}

.puzzle-pieces-title {
    color: #6666ff;
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 5px;
    text-transform: uppercase;
}

#puzzle-pieces-count {
    color: #ffffff;
    font-size: 1.2rem;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    font-variant-numeric: tabular-nums;
    letter-spacing: 1px;
}

.puzzle-pieces-remaining {
    display: flex;
    justify-content: center;
    gap: 5px;
    margin: 10px 0;
}

.puzzle-piece-icon {
    width: 30px;
    height: 30px;
    background: rgba(255, 136, 0, 0.2);
    border: 1px solid #ff8800;
    border-radius: 5px;
}

.puzzle-piece-icon.used {
    opacity: 0.3;
}

/* Battle Mode UI */
.battle-grid-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
}

.battle-player-side,
.battle-ai-side {
    border: 2px solid #ff0000;
    border-radius: 10px;
    padding: 10px;
    position: relative;
}

.battle-player-side {
    border-color: #00ffff;
}

.battle-ai-side {
    border-color: #ff0000;
}

.battle-side-label {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: #0f0f23;
    padding: 0 10px;
    font-weight: bold;
    text-transform: uppercase;
}

.battle-garbage-indicator {
    position: absolute;
    right: -30px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.garbage-line {
    width: 20px;
    height: 10px;
    background: #ff0000;
    border: 1px solid #fff;
    animation: blink 0.5s infinite;
}

.battle-powerups {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 10px 0;
}

.powerup-btn {
    width: 50px;
    height: 50px;
    border: 2px solid #666;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.5);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.powerup-btn.ready {
    border-color: #00ff00;
    animation: glow 1s infinite;
}

.powerup-btn:hover.ready {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
}

.powerup-cooldown {
    position: absolute;
    bottom: -15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.8rem;
    color: #ff0000;
}

/* Animations */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

@keyframes glow {
    0%, 100% {
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
    }
    50% {
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }
}

@keyframes blink {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    .mode-selector-content {
        padding: 20px;
    }
    
    .mode-grid {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .mode-card {
        padding: 20px;
    }
    
    .mode-icon {
        font-size: 2rem;
    }
    
    .mode-card h3 {
        font-size: 1.2rem;
    }
    
    .battle-grid-container {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 480px) {
    .mode-selector-content h2 {
        font-size: 1.5rem;
    }
    
    .mode-card {
        padding: 15px;
    }
    
    .mode-icon {
        font-size: 1.5rem;
    }
    
    .mode-card h3 {
        font-size: 1rem;
    }
    
    .mode-card p {
        font-size: 0.8rem;
    }
}

</style>
</head>
<body data-standalone="true">
    <div class="app">
        <header class="header">
            <div class="header-top">
                <div class="logo-container">
                    <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMjAwIDgwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzPgogICAgPCEtLSBOZW9uIGdsb3cgZWZmZWN0cyAtLT4KICAgIDxmaWx0ZXIgaWQ9Im5lb25HbG93IiB4PSItMjAlIiB5PSItMjAlIiB3aWR0aD0iMTQwJSIgaGVpZ2h0PSIxNDAlIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIgcmVzdWx0PSJjb2xvcmVkQmx1ciIvPgogICAgICA8ZmVNZXJnZT4gCiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJjb2xvcmVkQmx1ciIvPgogICAgICAgIDxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPgogICAgICA8L2ZlTWVyZ2U+CiAgICA8L2ZpbHRlcj4KICAgIAogICAgPGZpbHRlciBpZD0ic3Ryb25nR2xvdyIgeD0iLTMwJSIgeT0iLTMwJSIgd2lkdGg9IjE2MCUiIGhlaWdodD0iMTYwJSI+CiAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjMiIHJlc3VsdD0iY29sb3JlZEJsdXIiLz4KICAgICAgPGZlTWVyZ2U+IAogICAgICAgIDxmZU1lcmdlTm9kZSBpbj0iY29sb3JlZEJsdXIiLz4KICAgICAgICA8ZmVNZXJnZU5vZGUgaW49IlNvdXJjZUdyYXBoaWMiLz4KICAgICAgPC9mZU1lcmdlPgogICAgPC9maWx0ZXI+CiAgICAKICAgIDwhLS0gR3JhZGllbnRzIC0tPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJ0ZXRyaXNHcmFkaWVudCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMzlGRjE0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjI1JSIgc3R5bGU9InN0b3AtY29sb3I6IzAwRkZGRjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRjE0OTM7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iNzUlIiBzdHlsZT0ic3RvcC1jb2xvcjojRkZENzAwO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM5RDAwRkY7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgCiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImJsb2NrR3JhZGllbnQiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMDBGRkZGO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDgwRkY7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICAKICA8IS0tIEJhY2tncm91bmQgLS0+CiAgPHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI4MCIgZmlsbD0icmdiYSgwLDAsMCwwLjgpIiByeD0iMTAiIHJ5PSIxMCIvPgogIAogIDwhLS0gVGV0cmlzIGJsb2NrcyBhcnJhbmdlbWVudCAoZm9ybWluZyBULUUtVC1SLUktUyBwYXR0ZXJuKSAtLT4KICA8IS0tIFQgc2hhcGUgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBFIHNoYXBlIC0tPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1LCAxNSkiPgogICAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjgiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjgiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMDBGRkZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIxNiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBUIHNoYXBlIChzZWNvbmQgVCkgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjUsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGMTQ5MyIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGMTQ5MyIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBSIHNoYXBlIC0tPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkwLCAxNSkiPgogICAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjgiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjgiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjE2IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkZENzAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgPC9nPgogIAogIDwhLS0gSSBzaGFwZSAtLT4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzlEMDBGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjE2IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iMjQiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiM5RDAwRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgPC9nPgogIAogIDwhLS0gUyBzaGFwZSAtLT4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzUsIDE1KSI+CiAgICA8cmVjdCB4PSI4IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkY2QjAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMTYiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRjZCMDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIwIiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkY2QjAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGNkIwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBBZGRpdGlvbmFsIGRlY29yYXRpdmUgZWxlbWVudHMgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY1LCAxNSkiPgogICAgPCEtLSBTbWFsbCBhY2NlbnQgYmxvY2tzIC0tPgogICAgPHJlY3QgeD0iMCIgeT0iNCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiIG9wYWNpdHk9IjAuOCIvPgogICAgPHJlY3QgeD0iNiIgeT0iMCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiIG9wYWNpdHk9IjAuOCIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjgiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNGRjE0OTMiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIiBvcGFjaXR5PSIwLjgiLz4KICAgIDxyZWN0IHg9IjYiIHk9IjE2IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjRkZENzAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIgb3BhY2l0eT0iMC44Ii8+CiAgICA8cmVjdCB4PSIxOCIgeT0iMTIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiM5RDAwRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIiBvcGFjaXR5PSIwLjgiLz4KICA8L2c+CiAgCiAgPCEtLSBTdWJ0aXRsZSAtLT4KICA8dGV4dCB4PSIxMDAiIHk9IjY1IiBmb250LWZhbWlseT0iJ09yYml0cm9uJywgbW9ub3NwYWNlIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNzAwIiAKICAgICAgICBmaWxsPSJ1cmwoI3RldHJpc0dyYWRpZW50KSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsdGVyPSJ1cmwoI3N0cm9uZ0dsb3cpIj4KICAgIE1PREVSTiBFRElUSU9OCiAgPC90ZXh0PgogIAogIDwhLS0gQWRkaXRpb25hbCBnbG93IGVmZmVjdHMgLS0+CiAgPHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI4MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2JhKDU3LCAyNTUsIDIwLCAwLjMpIiBzdHJva2Utd2lkdGg9IjIiIHJ4PSIxMCIgcnk9IjEwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIi8+Cjwvc3ZnPg==" alt="Modern Tetris" class="logo">
                    <h1 class="title sr-only">TETRIS</h1>
                </div>
                <div class="header-controls">
                    <button id="mode-selector-button" class="btn-icon" title="Select Mode">🎮</button>
                    <button id="header-leaderboard-button" class="btn-icon" title="View Leaderboard">🏆</button>
                    <button id="settings-button" class="btn-icon" title="Settings">⚙️</button>
                    <button id="help-button" class="btn-icon" title="Controls">❓</button>
                    <button id="mute-button" class="btn-icon" title="Toggle Sound">🔊</button>
                </div>
            </div>
        </header>

        <!-- Mobile controls hint - only visible on touch devices -->
        <div class="controls-hint" id="mobile-controls-hint" style="display: none;">
            <span>👆 Tap to rotate (or resume from pause)</span>
            <span>👈👉 Swipe to move</span>
            <span>👇 Hold & drag down for fast drop</span>
            <span>🤏 Long press (0.8s) to hold piece</span>
        </div>

        <main class="game-container">
            <!-- Desktop layout - traditional 3-column -->
            <div class="game-sidebar left">
                <div class="hold-area">
                    <h3>Hold</h3>
                    <div class="hold-piece"></div>
                </div>
                
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Lines</span>
                        <span class="stat-value" id="lines">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Level</span>
                        <span class="stat-value" id="level">1</span>
                    </div>
                </div>
            </div>

            <!-- Game board -->
            <div class="game-board">
                <canvas id="game-canvas" width="400" height="800"></canvas>
                <div class="game-overlay" id="game-overlay">
                    <div class="overlay-content">
                        <h2 id="overlay-title">Game Paused</h2>
                        <p id="overlay-message">Press P to resume</p>
                        <button id="start-button" class="btn-primary">Start Game</button>
                        <button id="restart-button" class="btn-secondary" style="display: none;">Restart</button>
                        <button id="leaderboard-button" class="btn-secondary" style="display: none;">View Leaderboard</button>
                    </div>
                </div>
            </div>

            <div class="game-sidebar right">
                <div class="next-area">
                    <h3>Next</h3>
                    <div class="next-pieces">
                        <div class="next-piece" id="next-0"></div>
                        <div class="next-piece" id="next-1"></div>
                        <div class="next-piece" id="next-2"></div>
                    </div>
                </div>
            </div>

            <!-- Mobile compact panels - hidden by default, shown on small screens -->
            <div class="info-panel">
                <div class="hold-stats-card">
                    <div class="hold-section">
                        <h4>Hold</h4>
                        <div class="hold-piece" id="mobile-hold-piece"></div>
                    </div>
                    <div class="stats-section">
                        <div class="stat-compact">
                            <span class="stat-label-small">Score</span>
                            <span class="stat-value-small" data-sync="score">0</span>
                        </div>
                        <div class="stat-compact">
                            <span class="stat-label-small">Lines</span>
                            <span class="stat-value-small" data-sync="lines">0</span>
                        </div>
                        <div class="stat-compact">
                            <span class="stat-label-small">Level</span>
                            <span class="stat-value-small" data-sync="level">1</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="next-panel">
                <div class="next-pieces-card">
                    <h4>Next</h4>
                    <div class="next-pieces-compact">
                        <div class="next-piece-small" id="mobile-next-0"></div>
                        <div class="next-piece-small" id="mobile-next-1"></div>
                        <div class="next-piece-small" id="mobile-next-2"></div>
                    </div>
                </div>
            </div>
        </main>

        <div class="particles-container" id="particles"></div>
        
        <!-- Mode Selection Modal -->
        <div class="mode-selector-modal" id="mode-selector" style="display: none;">
            <div class="mode-selector-content">
                <h2>Select Game Mode</h2>
                <div class="mode-grid">
                    <div class="mode-card" data-mode="classic">
                        <div class="mode-icon">🎮</div>
                        <h3>Classic</h3>
                        <p>The original endless Tetris experience</p>
                    </div>
                    <div class="mode-card" data-mode="sprint">
                        <div class="mode-icon">⏱️</div>
                        <h3>Sprint</h3>
                        <p>Clear 40 lines as fast as possible</p>
                    </div>
                    <div class="mode-card" data-mode="marathon">
                        <div class="mode-icon">🏃</div>
                        <h3>Marathon</h3>
                        <p>Survive 150 lines with increasing difficulty</p>
                    </div>
                    <div class="mode-card" data-mode="zen">
                        <div class="mode-icon">🧘</div>
                        <h3>Zen</h3>
                        <p>Relaxing endless mode with no pressure</p>
                    </div>
                    <div class="mode-card" data-mode="puzzle">
                        <div class="mode-icon">🧩</div>
                        <h3>Puzzle</h3>
                        <p>Solve 150 unique challenges</p>
                    </div>
                    <div class="mode-card" data-mode="battle">
                        <div class="mode-icon">⚔️</div>
                        <h3>Battle</h3>
                        <p>Face off against intelligent AI opponents</p>
                    </div>
                </div>
                <button class="close-mode-selector" id="close-mode-selector">×</button>
            </div>
        </div>
        
        <!-- Player Name Input Modal -->
        <div class="name-input-overlay" id="name-input-overlay" style="display: none;">
            <div class="name-input-content">
                <h2>New High Score!</h2>
                <p>Enter your name for the leaderboard:</p>
                <div class="input-group">
                    <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="50" autocomplete="name">
                    <div class="input-buttons">
                        <button id="save-score-button" class="btn-primary">Save Score</button>
                        <button id="skip-save-button" class="btn-secondary">Skip</button>
                    </div>
                </div>
                <div class="score-summary" id="score-summary">
                    <div class="score-item">
                        <span>Score:</span>
                        <span id="final-score">0</span>
                    </div>
                    <div class="score-item">
                        <span>Lines:</span>
                        <span id="final-lines">0</span>
                    </div>
                    <div class="score-item">
                        <span>Level:</span>
                        <span id="final-level">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Leaderboard Modal -->
        <div class="leaderboard-overlay" id="leaderboard-overlay" style="display: none;">
            <div class="leaderboard-content">
                <div class="leaderboard-header">
                    <h2>🏆 Leaderboard</h2>
                    <button id="close-leaderboard" class="btn-close">×</button>
                </div>
                <div class="leaderboard-tabs">
                    <button class="tab-button active" data-tab="top-scores">Top Scores</button>
                    <button class="tab-button" data-tab="recent">Recent Games</button>
                </div>
                <div class="leaderboard-list" id="leaderboard-list">
                    <div class="loading">Loading scores...</div>
                </div>
            </div>
        </div>
        
        <!-- Settings Modal -->
        <div class="settings-overlay" id="settings-overlay" style="display: none;">
            <div class="settings-content">
                <div class="settings-header">
                    <h2>⚙️ Settings</h2>
                    <button id="close-settings" class="btn-close">×</button>
                </div>
                
                <div class="settings-tabs">
                    <button class="settings-tab-button active" data-tab="audio">🔊 Audio</button>
                    <button class="settings-tab-button" data-tab="controls">⌨️ Controls</button>
                </div>
                
                <div class="settings-panel" id="audio-panel">
                    <div class="setting-group">
                        <label>Master Volume</label>
                        <div class="volume-control">
                            <input type="range" id="master-volume" min="0" max="100" value="80">
                            <span id="master-volume-value">80%</span>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>Music Volume</label>
                        <div class="volume-control">
                            <input type="range" id="music-volume" min="0" max="100" value="80">
                            <span id="music-volume-value">80%</span>
                        </div>
                        <div class="setting-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="music-enabled" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">Background Music</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>Sound Effects Volume</label>
                        <div class="volume-control">
                            <input type="range" id="sfx-volume" min="0" max="100" value="70">
                            <span id="sfx-volume-value">70%</span>
                        </div>
                        <div class="setting-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="sfx-enabled" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">Sound Effects</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-panel" id="controls-panel" style="display: none;">
                    <div class="controls-info">
                        <h3>Keyboard Controls</h3>
                        <div class="controls-grid">
                            <div class="control-item">
                                <span class="control-key">←→</span>
                                <span class="control-action">Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">↓</span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">↑</span>
                                <span class="control-action">Rotate Clockwise</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">Space</span>
                                <span class="control-action">Hard Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">C</span>
                                <span class="control-action">Hold Piece</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">P</span>
                                <span class="control-action">Pause</span>
                            </div>
                        </div>
                        
                        <h3>Alternative Keys (WASD)</h3>
                        <div class="controls-grid">
                            <div class="control-item">
                                <span class="control-key">A/D</span>
                                <span class="control-action">Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">S</span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">W/E</span>
                                <span class="control-action">Rotate</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">Q</span>
                                <span class="control-action">Rotate Counter-clockwise</span>
                            </div>
                        </div>
                        
                        <h3>Mobile/Touch Controls</h3>
                        <div class="touch-controls-info">
                            <div class="touch-item">
                                <span class="touch-gesture">👆 Tap</span>
                                <span class="control-action">Rotate</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture">👈👉 Swipe Left/Right</span>
                                <span class="control-action">Move</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture">👇 Swipe Down</span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture">👆 Swipe Up</span>
                                <span class="control-action">Hard Drop</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture">🤏 Long Press</span>
                                <span class="control-action">Hold Piece</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Help Modal -->
        <div class="help-overlay" id="help-overlay" style="display: none;">
            <div class="help-content">
                <div class="help-header">
                    <h2>❓ How to Play</h2>
                    <button id="close-help" class="btn-close">×</button>
                </div>
                
                <div class="help-sections">
                    <div class="help-section">
                        <h3>🎯 Objective</h3>
                        <p>Arrange falling tetrominoes (puzzle pieces) to create complete horizontal lines. Completed lines disappear, giving you points and more space to play.</p>
                    </div>
                    
                    <div class="help-section">
                        <h3>🎮 Basic Controls</h3>
                        <div class="quick-controls" id="quick-controls">
                            <!-- Will be populated by JavaScript based on device -->
                        </div>
                    </div>
                    
                    <div class="help-section">
                        <h3>⭐ Special Moves</h3>
                        <div class="special-moves">
                            <div class="special-item">
                                <strong>T-Spin:</strong> Rotate a T-piece into a tight spot for bonus points
                            </div>
                            <div class="special-item">
                                <strong>Tetris:</strong> Clear 4 lines at once for maximum points
                            </div>
                            <div class="special-item">
                                <strong>Combo:</strong> Clear lines consecutively for multiplier bonuses
                            </div>
                            <div class="special-item">
                                <strong>Perfect Clear:</strong> Clear the entire board for massive bonus
                            </div>
                        </div>
                    </div>
                    
                    <div class="help-section">
                        <h3>📊 Scoring System</h3>
                        <div class="scoring-info">
                            <div class="score-item">
                                <span>Single Line:</span>
                                <span>100 × Level</span>
                            </div>
                            <div class="score-item">
                                <span>Double Lines:</span>
                                <span>300 × Level</span>
                            </div>
                            <div class="score-item">
                                <span>Triple Lines:</span>
                                <span>500 × Level</span>
                            </div>
                            <div class="score-item">
                                <span>Tetris (4 lines):</span>
                                <span>800 × Level</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    
    <!-- Context Detection and Service Worker Registration -->
    
<script>

// Simple module system for standalone version
window.TetrisModules = {};
window.TetrisExports = {};

function defineModule(name, factory) {
    const module = { exports: {} };
    const exports = module.exports;
    factory(exports, module);
    window.TetrisModules[name] = module.exports;
    // Make exports available globally
    if (typeof module.exports === 'object') {
        Object.assign(window.TetrisExports, module.exports);
    }
}

// Override import/export for standalone

/* scripts/pieces.js */
(function() {
// Modern Tetris - Piece Definitions and Logic

window.PIECE_TYPES = const PIECE_TYPES = {
    I: 'I', O: 'O', T: 'T', S: 'S', Z: 'Z', J: 'J', L: 'L'
};

window.PIECE_COLORS = const PIECE_COLORS = {
    I: '#00d4ff',  // Neon Blue
    O: '#ffff00',  // Neon Yellow
    T: '#9d4edd',  // Neon Purple
    S: '#39ff14',  // Neon Green
    Z: '#ff0040',  // Neon Red
    J: '#0066ff',  // Blue
    L: '#ff8500'   // Neon Orange
};

// SRS (Super Rotation System) piece definitions
// Each piece has 4 rotation states (0, 1, 2, 3)
window.PIECE_SHAPES = const PIECE_SHAPES = {
    I: [
        [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]], // 90°
        [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]], // 180°
        [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]  // 270°
    ],
    O: [
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]], // All rotations same
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]]
    ],
    T: [
        [[0,1,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,1,0,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]], // 90°
        [[0,0,0,0], [1,1,1,0], [0,1,0,0], [0,0,0,0]], // 180°
        [[0,1,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270°
    ],
    S: [
        [[0,1,1,0], [1,1,0,0], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,1,0,0], [0,1,1,0], [0,0,1,0], [0,0,0,0]], // 90°
        [[0,0,0,0], [0,1,1,0], [1,1,0,0], [0,0,0,0]], // 180°
        [[1,0,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270°
    ],
    Z: [
        [[1,1,0,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,0,1,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]], // 90°
        [[0,0,0,0], [1,1,0,0], [0,1,1,0], [0,0,0,0]], // 180°
        [[0,1,0,0], [1,1,0,0], [1,0,0,0], [0,0,0,0]]  // 270°
    ],
    J: [
        [[1,0,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,1,1,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]], // 90°
        [[0,0,0,0], [1,1,1,0], [0,0,1,0], [0,0,0,0]], // 180°
        [[0,1,0,0], [0,1,0,0], [1,1,0,0], [0,0,0,0]]  // 270°
    ],
    L: [
        [[0,0,1,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0°
        [[0,1,0,0], [0,1,0,0], [0,1,1,0], [0,0,0,0]], // 90°
        [[0,0,0,0], [1,1,1,0], [1,0,0,0], [0,0,0,0]], // 180°
        [[1,1,0,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270°
    ]
};

// SRS Wall Kick Data
window.WALL_KICKS = const WALL_KICKS = {
    // Standard pieces (J, L, S, T, Z)
    JLSTZ: {
        '0->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
        '1->0': [[1, 0], [1, -1], [0, 2], [1, 2]],
        '1->2': [[1, 0], [1, -1], [0, 2], [1, 2]],
        '2->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
        '2->3': [[1, 0], [1, 1], [0, -2], [1, -2]],
        '3->2': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
        '3->0': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
        '0->3': [[1, 0], [1, 1], [0, -2], [1, -2]]
    },
    // I piece has different wall kicks
    I: {
        '0->1': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
        '1->0': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
        '1->2': [[-1, 0], [2, 0], [-1, 2], [2, -1]],
        '2->1': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
        '2->3': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
        '3->2': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
        '3->0': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
        '0->3': [[-1, 0], [2, 0], [-1, 2], [2, -1]]
    }
};

window.Piece = class Piece {
    constructor(type, x = 3, y = 0) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.rotation = 0;
        this.color = PIECE_COLORS[type];
        this.shape = PIECE_SHAPES[type];
        this.lockDelay = 0;
        this.maxLockDelay = 500; // 500ms lock delay
        this.moved = false;
    }

    // Get current shape based on rotation
    getCurrentShape() {
        return this.shape[this.rotation];
    }

    // Get piece blocks with absolute positions
    getBlocks() {
        const blocks = [];
        const shape = this.getCurrentShape();
        
        for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                    blocks.push({
                        x: this.x + x,
                        y: this.y + y,
                        color: this.color
                    });
                }
            }
        }
        
        return blocks;
    }

    // Create a copy of the piece
    copy() {
        const newPiece = new Piece(this.type, this.x, this.y);
        newPiece.rotation = this.rotation;
        newPiece.lockDelay = this.lockDelay;
        newPiece.moved = this.moved;
        return newPiece;
    }

    // Move piece
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.moved = true;
        this.resetLockDelay();
    }

    // Rotate piece (returns new rotation state)
    getRotatedState(direction = 1) {
        const newRotation = (this.rotation + direction + 4) % 4;
        return newRotation;
    }

    // Apply rotation
    rotate(direction = 1) {
        this.rotation = this.getRotatedState(direction);
        this.moved = true;
        this.resetLockDelay();
    }

    // Reset lock delay when piece moves or rotates
    resetLockDelay() {
        this.lockDelay = 0;
    }

    // Update lock delay
    updateLockDelay(deltaTime) {
        this.lockDelay += deltaTime;
        return this.lockDelay >= this.maxLockDelay;
    }

    // Check if piece should lock
    shouldLock(grid) {
        // Check if piece can move down
        const testPiece = this.copy();
        testPiece.y += 1;
        return grid.checkCollision(testPiece);
    }
    
    // Save piece state
    saveState() {
        return {
            type: this.type,
            x: this.x,
            y: this.y,
            rotation: this.rotation,
            color: this.color
        };
    }
    
    // Load piece state
    loadState(state) {
        if (state) {
            this.type = state.type;
            this.x = state.x;
            this.y = state.y;
            this.rotation = state.rotation;
            this.color = state.color;
        }
    }
}

// 7-Bag Random Generator for fair piece distribution
window.PieceBag = class PieceBag {
    constructor() {
        this.bag = [];
        this.refillBag();
    }

    refillBag() {
        const pieces = Object.values(PIECE_TYPES);
        // Shuffle using Fisher-Yates algorithm
        for (let i = pieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        this.bag = pieces;
    }

    getNextPiece() {
        if (this.bag.length === 0) {
            this.refillBag();
        }
        const pieceType = this.bag.pop();
        return new Piece(pieceType);
    }

    // Preview next N pieces without removing them
    previewPieces(count = 3) {
        const preview = [];
        let tempBag = [...this.bag];
        let tempPieces = Object.values(PIECE_TYPES);
        
        for (let i = 0; i < count; i++) {
            if (tempBag.length === 0) {
                // Shuffle new bag
                for (let j = tempPieces.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [tempPieces[j], tempPieces[k]] = [tempPieces[k], tempPieces[j]];
                }
                tempBag = [...tempPieces];
            }
            preview.push(tempBag.pop());
        }
        
        return preview;
    }
}

// T-Spin Detection
window.TSpinDetector = class TSpinDetector {
    static isTSpin(piece, grid, previousPosition) {
        if (piece.type !== 'T') return { type: 'none', mini: false };
        
        const corners = this.getCorners(piece);
        let filledCorners = 0;
        let frontCorners = 0;
        
        // Check which corners are filled
        corners.forEach((corner, index) => {
            if (grid.isOccupied(corner.x, corner.y)) {
                filledCorners++;
                if (index < 2) frontCorners++; // Front corners (relative to rotation)
            }
        });
        
        // T-Spin requires at least 3 filled corners
        if (filledCorners < 3) return { type: 'none', mini: false };
        
        // Check if the piece was rotated into position
        const wasRotated = previousPosition && 
            (previousPosition.rotation !== piece.rotation);
        
        if (!wasRotated) return { type: 'none', mini: false };
        
        // T-Spin Mini: Only 3 corners filled, or back corners filled
        const isMini = filledCorners === 3 || frontCorners < 2;
        
        return {
            type: 'tspin',
            mini: isMini
        };
    }
    
    static getCorners(piece) {
        const rotation = piece.rotation;
        const baseCorners = [
            { x: piece.x, y: piece.y },         // Top-left
            { x: piece.x + 2, y: piece.y },     // Top-right
            { x: piece.x, y: piece.y + 2 },     // Bottom-left
            { x: piece.x + 2, y: piece.y + 2 }  // Bottom-right
        ];
        
        // Adjust corners based on T-piece rotation
        switch (rotation) {
            case 0: return [baseCorners[0], baseCorners[1], baseCorners[2], baseCorners[3]];
            case 1: return [baseCorners[1], baseCorners[3], baseCorners[0], baseCorners[2]];
            case 2: return [baseCorners[3], baseCorners[2], baseCorners[1], baseCorners[0]];
            case 3: return [baseCorners[2], baseCorners[0], baseCorners[3], baseCorners[1]];
        }
    }
}
})();

/* scripts/grid.js */
(function() {
// Modern Tetris - Grid Management and Collision Detection

window.GRID_WIDTH = const GRID_WIDTH = 10;
window.GRID_HEIGHT = const GRID_HEIGHT = 20;
window.GRID_HIDDEN_ROWS = const GRID_HIDDEN_ROWS = 4; // Hidden rows above visible area

window.Grid = class Grid {
    constructor() {
        this.width = GRID_WIDTH;
        this.height = GRID_HEIGHT + GRID_HIDDEN_ROWS;
        this.cells = this.createEmptyGrid();
        this.linesCleared = 0;
        this.totalLines = 0;
    }

    // Create empty grid
    createEmptyGrid() {
        return Array(this.height).fill(null).map(() => 
            Array(this.width).fill(null)
        );
    }

    // Check if coordinates are within grid bounds
    isInBounds(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height;
    }

    // Check if cell is occupied
    isOccupied(x, y) {
        if (!this.isInBounds(x, y)) return true; // Out of bounds = occupied
        return this.cells[y][x] !== null;
    }

    // Get cell value
    getCell(x, y) {
        if (!this.isInBounds(x, y)) return null;
        return this.cells[y][x];
    }

    // Set cell value
    setCell(x, y, value) {
        if (this.isInBounds(x, y)) {
            this.cells[y][x] = value;
        }
    }

    // Check collision with piece
    checkCollision(piece) {
        const blocks = piece.getBlocks();
        
        for (const block of blocks) {
            if (this.isOccupied(block.x, block.y)) {
                return true;
            }
        }
        
        return false;
    }

    // Place piece on grid
    placePiece(piece) {
        const blocks = piece.getBlocks();
        
        for (const block of blocks) {
            if (this.isInBounds(block.x, block.y)) {
                this.cells[block.y][block.x] = {
                    color: block.color,
                    type: piece.type
                };
            }
        }
    }

    // Check for completed lines
    getCompletedLines() {
        const completedLines = [];
        
        for (let y = 0; y < this.height; y++) {
            if (this.isLineFull(y)) {
                completedLines.push(y);
            }
        }
        
        return completedLines;
    }

    // Check if line is full
    isLineFull(y) {
        if (!this.isInBounds(0, y)) return false;
        
        for (let x = 0; x < this.width; x++) {
            if (this.cells[y][x] === null) {
                return false;
            }
        }
        
        return true;
    }

    // Clear completed lines and return line count
    clearLines(linesToClear = null) {
        let completedLines = linesToClear || this.getCompletedLines();
        
        if (completedLines.length === 0) return 0;
        
        // Create a new grid without the completed lines
        const newCells = [];
        let actualClearedCount = 0;
        
        // Add empty lines at the top for each cleared line
        for (let i = 0; i < completedLines.length; i++) {
            newCells.push(Array(this.width).fill(null));
        }
        
        // Copy all non-completed lines to the new grid
        for (let y = 0; y < this.height; y++) {
            if (!completedLines.includes(y)) {
                newCells.push([...this.cells[y]]);
            } else {
                actualClearedCount++;
            }
        }
        
        // Replace the old grid with the new one
        this.cells = newCells;
        
        this.linesCleared = actualClearedCount;
        this.totalLines += actualClearedCount;
        
        return actualClearedCount;
    }

    // Get line clearing info for animations
    getLineClearInfo() {
        const completedLines = this.getCompletedLines();
        return {
            lines: completedLines,
            count: completedLines.length,
            isSpecial: this.isSpecialClear(completedLines.length)
        };
    }

    // Check for special clears
    isSpecialClear(lineCount) {
        switch (lineCount) {
            case 1: return 'single';
            case 2: return 'double';
            case 3: return 'triple';
            case 4: return 'tetris';
            default: return null;
        }
    }

    // Check for perfect clear (empty grid)
    isPerfectClear() {
        for (let y = GRID_HIDDEN_ROWS; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    return false;
                }
            }
        }
        return true;
    }

    // Get visible grid (without hidden rows)
    getVisibleGrid() {
        return this.cells.slice(GRID_HIDDEN_ROWS);
    }

    // Check game over condition
    isGameOver() {
        // Check if any blocks are above the visible area
        for (let y = 0; y < GRID_HIDDEN_ROWS; y++) {
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Reset grid
    reset() {
        this.cells = this.createEmptyGrid();
        this.linesCleared = 0;
        this.totalLines = 0;
    }
    
    // Load grid from array (for puzzle mode)
    loadFromArray(gridArray) {
        if (!gridArray || !Array.isArray(gridArray)) return;
        
        // Create a new grid with the provided data
        this.cells = this.createEmptyGrid();
        
        // The gridArray represents the visible portion of the grid (20 rows)
        // We need to map it to our internal grid which has hidden rows at the top
        const startRow = GRID_HIDDEN_ROWS; // Start after hidden rows
        
        for (let row = 0; row < gridArray.length && row < GRID_HEIGHT; row++) {
            if (!gridArray[row]) continue;
            for (let col = 0; col < gridArray[row].length && col < this.width; col++) {
                // Map non-zero values to colors (1-7 for standard pieces)
                const value = gridArray[row][col];
                if (value > 0) {
                    // Place in the visible area of the grid
                    this.cells[startRow + row][col] = value;
                }
            }
        }
    }
    
    // Check if grid is empty (for perfect clear)
    isEmpty() {
        for (let row = 0; row < this.height; row++) {
            for (let col = 0; col < this.width; col++) {
                if (this.cells[row][col] !== null && this.cells[row][col] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    
    // Save grid state
    saveState() {
        return {
            cells: this.cells.map(row => [...row]),
            linesCleared: this.linesCleared,
            totalLines: this.totalLines
        };
    }
    
    // Load grid state
    loadState(state) {
        if (state && state.cells) {
            this.cells = state.cells.map(row => [...row]);
            this.linesCleared = state.linesCleared || 0;
            this.totalLines = state.totalLines || 0;
        }
    }
    
    // Check for game over
    checkGameOver() {
        // Check if any cells in the hidden rows (top 4 rows) are occupied
        for (let row = 0; row < GRID_HIDDEN_ROWS; row++) {
            for (let col = 0; col < this.width; col++) {
                if (this.cells[row][col] !== null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Get grid state for rendering
    getRenderData() {
        const visibleGrid = this.getVisibleGrid();
        const renderData = [];
        
        for (let y = 0; y < visibleGrid.length; y++) {
            for (let x = 0; x < this.width; x++) {
                const cell = visibleGrid[y][x];
                if (cell !== null) {
                    renderData.push({
                        x,
                        y,
                        color: cell.color,
                        type: cell.type
                    });
                }
            }
        }
        
        return renderData;
    }

    // Test piece movement (returns valid position or null)
    testPieceMovement(piece, dx, dy) {
        const testPiece = piece.copy();
        testPiece.move(dx, dy);
        
        return this.checkCollision(testPiece) ? null : testPiece;
    }

    // Test piece rotation with wall kicks
    testPieceRotation(piece, direction = 1) {
        const newRotation = piece.getRotatedState(direction);
        const testPiece = piece.copy();
        testPiece.rotation = newRotation;
        
        // Get wall kick tests
        const wallKicks = this.getWallKicks(piece, direction);
        
        // Test original position first
        if (!this.checkCollision(testPiece)) {
            return testPiece;
        }
        
        // Try wall kicks
        for (const kick of wallKicks) {
            const kickTestPiece = testPiece.copy();
            kickTestPiece.x += kick[0];
            kickTestPiece.y += kick[1];
            
            if (!this.checkCollision(kickTestPiece)) {
                return kickTestPiece;
            }
        }
        
        return null; // Rotation not possible
    }

    // Get wall kick tests for rotation
    getWallKicks(piece, direction) {
        // Import WALL_KICKS synchronously from pieces module
        // This will be handled by the game engine which has already imported the module
        
        const from = piece.rotation;
        const to = piece.getRotatedState(direction);
        const kickKey = `${from}->${to}`;
        
        // Wall kick data defined here to avoid async import issues
        const WALL_KICKS = {
            JLSTZ: {
                '0->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '1->0': [[1, 0], [1, -1], [0, 2], [1, 2]],
                '1->2': [[1, 0], [1, -1], [0, 2], [1, 2]],
                '2->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '2->3': [[1, 0], [1, 1], [0, -2], [1, -2]],
                '3->2': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '3->0': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '0->3': [[1, 0], [1, 1], [0, -2], [1, -2]]
            },
            I: {
                '0->1': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
                '1->0': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
                '1->2': [[-1, 0], [2, 0], [-1, 2], [2, -1]],
                '2->1': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
                '2->3': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
                '3->2': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
                '3->0': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
                '0->3': [[-1, 0], [2, 0], [-1, 2], [2, -1]]
            }
        };
        
        if (piece.type === 'I') {
            return WALL_KICKS.I[kickKey] || [];
        } else if (piece.type === 'O') {
            return []; // O piece doesn't need wall kicks
        } else {
            return WALL_KICKS.JLSTZ[kickKey] || [];
        }
    }

    // Get ghost piece position (hard drop preview)
    getGhostPosition(piece) {
        const ghostPiece = piece.copy();
        
        // Move down until collision
        while (!this.checkCollision(ghostPiece)) {
            ghostPiece.y += 1;
        }
        
        // Move back one step
        ghostPiece.y -= 1;
        
        return ghostPiece;
    }

    // Calculate drop distance for scoring
    getDropDistance(fromY, toY) {
        return Math.max(0, toY - fromY);
    }

    // Get grid statistics
    getStats() {
        let occupiedCells = 0;
        let highestRow = this.height;
        
        for (let y = GRID_HIDDEN_ROWS; y < this.height; y++) {
            let rowHasCells = false;
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    occupiedCells++;
                    rowHasCells = true;
                }
            }
            if (rowHasCells && y < highestRow) {
                highestRow = y;
            }
        }
        
        return {
            occupiedCells,
            height: highestRow === this.height ? 0 : (this.height - highestRow),
            totalLines: this.totalLines,
            isEmpty: occupiedCells === 0
        };
    }


    // Deep copy grid state
    copy() {
        const newGrid = new Grid();
        newGrid.cells = this.cells.map(row => [...row]);
        newGrid.linesCleared = this.linesCleared;
        newGrid.totalLines = this.totalLines;
        return newGrid;
    }
}
})();

/* scripts/storage-adapter.js */
(function() {
// Unified Storage Adapter - Works in both file:// and http:// contexts
window.StorageAdapter = class StorageAdapter {
    constructor() {
        // Detect execution context
        this.isFileProtocol = window.location.protocol === 'file:';
        this.hasServiceWorker = 'serviceWorker' in navigator && !this.isFileProtocol;
        this.hasIndexedDB = 'indexedDB' in window && !this.isFileProtocol;
        
        // Choose storage method based on context
        this.storageMethod = this.isFileProtocol ? 'localStorage' : 'hybrid';
        
        // Storage limits
        this.localStorageLimit = 5 * 1024 * 1024; // 5MB typical limit
        this.compressionEnabled = true;
        
        // Initialize IndexedDB if available
        this.db = null;
        this.dbName = 'TetrisUnifiedDB';
        this.dbVersion = 1;
        
        if (this.hasIndexedDB) {
            this.initIndexedDB();
        }
        
        console.log(`Storage Adapter initialized - Mode: ${this.storageMethod}, File Protocol: ${this.isFileProtocol}`);
    }
    
    // Initialize IndexedDB for http:// context
    async initIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.warn('IndexedDB not available, falling back to localStorage');
                this.storageMethod = 'localStorage';
                resolve(null);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                console.log('IndexedDB initialized successfully');
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create stores for different data types
                if (!db.objectStoreNames.contains('gameStates')) {
                    db.createObjectStore('gameStates', { keyPath: 'key' });
                }
                if (!db.objectStoreNames.contains('scores')) {
                    db.createObjectStore('scores', { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
        });
    }
    
    // Compress data if needed (for localStorage)
    compress(data) {
        if (!this.compressionEnabled) return data;
        
        try {
            // Simple compression using JSON stringify and base64
            const jsonStr = JSON.stringify(data);
            // For better compression, we could use LZ-string library if available
            if (typeof LZString !== 'undefined') {
                return LZString.compressToUTF16(jsonStr);
            }
            return jsonStr;
        } catch (e) {
            console.error('Compression failed:', e);
            return JSON.stringify(data);
        }
    }
    
    // Decompress data
    decompress(data) {
        if (!this.compressionEnabled || !data) return null;
        
        try {
            // Check if LZ-string is available
            if (typeof LZString !== 'undefined' && data.charAt(0) !== '{' && data.charAt(0) !== '[') {
                const decompressed = LZString.decompressFromUTF16(data);
                return JSON.parse(decompressed);
            }
            return JSON.parse(data);
        } catch (e) {
            console.error('Decompression failed:', e);
            return null;
        }
    }
    
    // Save data - unified interface
    async save(key, data, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.saveToLocalStorage(key, data);
        } else {
            return this.saveToIndexedDB(key, data, store);
        }
    }
    
    // Load data - unified interface
    async load(key, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.loadFromLocalStorage(key);
        } else {
            return this.loadFromIndexedDB(key, store);
        }
    }
    
    // Delete data - unified interface
    async delete(key, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.deleteFromLocalStorage(key);
        } else {
            return this.deleteFromIndexedDB(key, store);
        }
    }
    
    // LocalStorage operations
    saveToLocalStorage(key, data) {
        try {
            const compressed = this.compress(data);
            const fullKey = `tetris_${key}`;
            
            // Check storage quota
            const dataSize = compressed.length * 2; // Rough estimate (UTF-16)
            if (dataSize > this.localStorageLimit) {
                console.warn(`Data too large for localStorage (${dataSize} bytes)`);
                // Try to clean old data
                this.cleanOldLocalStorageData();
            }
            
            localStorage.setItem(fullKey, compressed);
            return Promise.resolve(true);
        } catch (e) {
            console.error('localStorage save failed:', e);
            if (e.name === 'QuotaExceededError') {
                this.cleanOldLocalStorageData();
                // Retry once
                try {
                    const compressed = this.compress(data);
                    localStorage.setItem(`tetris_${key}`, compressed);
                    return Promise.resolve(true);
                } catch (retryError) {
                    return Promise.reject(retryError);
                }
            }
            return Promise.reject(e);
        }
    }
    
    loadFromLocalStorage(key) {
        try {
            const fullKey = `tetris_${key}`;
            const compressed = localStorage.getItem(fullKey);
            if (!compressed) return Promise.resolve(null);
            
            const data = this.decompress(compressed);
            return Promise.resolve(data);
        } catch (e) {
            console.error('localStorage load failed:', e);
            return Promise.resolve(null);
        }
    }
    
    deleteFromLocalStorage(key) {
        try {
            const fullKey = `tetris_${key}`;
            localStorage.removeItem(fullKey);
            return Promise.resolve(true);
        } catch (e) {
            console.error('localStorage delete failed:', e);
            return Promise.reject(e);
        }
    }
    
    // IndexedDB operations
    async saveToIndexedDB(key, data, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.saveToLocalStorage(key, data);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const record = {
                key: key,
                data: data,
                timestamp: Date.now()
            };
            
            const request = store.put(record);
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                console.error('IndexedDB save failed:', request.error);
                // Fallback to localStorage
                this.saveToLocalStorage(key, data).then(resolve).catch(reject);
            };
        });
    }
    
    async loadFromIndexedDB(key, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.loadFromLocalStorage(key);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            
            request.onsuccess = () => {
                const result = request.result;
                resolve(result ? result.data : null);
            };
            
            request.onerror = () => {
                console.error('IndexedDB load failed:', request.error);
                // Fallback to localStorage
                this.loadFromLocalStorage(key).then(resolve).catch(reject);
            };
        });
    }
    
    async deleteFromIndexedDB(key, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.deleteFromLocalStorage(key);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(key);
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                console.error('IndexedDB delete failed:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Clean old localStorage data to free space
    cleanOldLocalStorageData() {
        const keysToCheck = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('tetris_')) {
                keysToCheck.push(key);
            }
        }
        
        // Sort by timestamp if available, otherwise delete oldest entries
        const itemsWithTime = keysToCheck.map(key => {
            try {
                const data = localStorage.getItem(key);
                const parsed = this.decompress(data);
                return {
                    key,
                    timestamp: parsed?.timestamp || 0,
                    size: data.length * 2
                };
            } catch {
                return { key, timestamp: 0, size: 0 };
            }
        });
        
        // Sort by timestamp (oldest first)
        itemsWithTime.sort((a, b) => a.timestamp - b.timestamp);
        
        // Remove oldest 25% of items
        const toRemove = Math.floor(itemsWithTime.length * 0.25);
        for (let i = 0; i < toRemove; i++) {
            localStorage.removeItem(itemsWithTime[i].key);
            console.log(`Cleaned old data: ${itemsWithTime[i].key}`);
        }
    }
    
    // Get storage info
    async getStorageInfo() {
        const info = {
            method: this.storageMethod,
            isFileProtocol: this.isFileProtocol,
            hasServiceWorker: this.hasServiceWorker,
            hasIndexedDB: this.hasIndexedDB
        };
        
        if (this.storageMethod === 'localStorage') {
            let totalSize = 0;
            let itemCount = 0;
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tetris_')) {
                    const value = localStorage.getItem(key);
                    totalSize += (key.length + value.length) * 2; // UTF-16
                    itemCount++;
                }
            }
            
            info.localStorage = {
                itemCount,
                estimatedSize: totalSize,
                estimatedSizeMB: (totalSize / (1024 * 1024)).toFixed(2)
            };
        }
        
        if (this.db && navigator.storage && navigator.storage.estimate) {
            const estimate = await navigator.storage.estimate();
            info.indexedDB = {
                usage: estimate.usage,
                quota: estimate.quota,
                usageMB: (estimate.usage / (1024 * 1024)).toFixed(2),
                quotaMB: (estimate.quota / (1024 * 1024)).toFixed(2)
            };
        }
        
        return info;
    }
    
    // Check if running in offline-capable context
    isOfflineCapable() {
        return true; // Always capable with this adapter
    }
    
    // Get appropriate asset path based on context
    getAssetPath(path) {
        if (this.isFileProtocol) {
            // For file:// protocol, use relative paths
            return path.startsWith('/') ? '.' + path : path;
        }
        return path;
    }
}

// Create singleton instance
window.storage = const storage = new StorageAdapter();

// Expose globally for debugging
if (typeof window !== 'undefined') {
    window.TetrisStorage = storage;
}
})();

/* scripts/offline-storage.js */
(function() {
// Offline Storage Manager using IndexedDB
window.OfflineStorage = class OfflineStorage {
    constructor() {
        this.dbName = 'TetrisOfflineDB';
        this.dbVersion = 1;
        this.db = null;
        this.isOnline = navigator.onLine;
        this.pendingSyncCount = 0;
        
        this.initializeDB();
        this.setupEventListeners();
        this.checkPendingScores();
    }
    
    // Initialize IndexedDB
    async initializeDB() {
        // Check if IndexedDB is available and not in private mode
        if (!window.indexedDB) {
            console.warn('IndexedDB not available');
            return null;
        }
        
        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = () => {
                    console.warn('Failed to open IndexedDB:', request.error);
                    // Don't reject, just resolve with null to fallback to localStorage
                    resolve(null);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    
                    // Handle database closing errors
                    this.db.onerror = (event) => {
                        console.error('Database error:', event.target.error);
                    };
                    
                    this.db.onabort = (event) => {
                        console.error('Database transaction aborted:', event.target.error);
                    };
                    
                    console.log('IndexedDB initialized successfully');
                    resolve(this.db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains('scores')) {
                        const scoresStore = db.createObjectStore('scores', { 
                            keyPath: 'id', 
                            autoIncrement: true 
                        });
                        // Only create index if it doesn't exist
                        if (!scoresStore.indexNames.contains('synced')) {
                            scoresStore.createIndex('synced', 'synced', { unique: false });
                        }
                        if (!scoresStore.indexNames.contains('timestamp')) {
                            scoresStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    }
                    
                    if (!db.objectStoreNames.contains('leaderboard_cache')) {
                        const cacheStore = db.createObjectStore('leaderboard_cache', { 
                            keyPath: 'type' 
                        });
                        if (!cacheStore.indexNames.contains('timestamp')) {
                            cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    }
                    
                    console.log('IndexedDB schema created/updated');
                };
                
                request.onblocked = () => {
                    console.warn('IndexedDB blocked - close other tabs using this site');
                    resolve(null);
                };
            } catch (error) {
                console.warn('IndexedDB initialization error:', error);
                resolve(null);
            }
        });
    }
    
    // Setup online/offline event listeners
    setupEventListeners() {
        window.addEventListener('online', () => {
            console.log('Connection restored');
            this.isOnline = true;
            this.syncPendingScores();
            this.showNotification('Back online! Syncing scores...', 'success');
        });
        
        window.addEventListener('offline', () => {
            console.log('Connection lost');
            this.isOnline = false;
            this.showNotification('You are offline. Scores will be saved locally.', 'warning');
        });
        
        // Listen for messages from Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'SYNC_SCORES') {
                    this.syncPendingScores();
                }
            });
        }
    }
    
    // Save score locally
    async saveScoreLocally(scoreData) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readwrite');
        const store = transaction.objectStore('scores');
        
        const score = {
            ...scoreData,
            timestamp: Date.now(),
            synced: false
        };
        
        return new Promise((resolve, reject) => {
            const request = store.add(score);
            
            request.onsuccess = () => {
                console.log('Score saved locally:', request.result);
                this.pendingSyncCount++;
                this.updateSyncIndicator();
                resolve(request.result);
            };
            
            request.onerror = () => {
                console.error('Failed to save score locally:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Get all unsynced scores
    async getUnsyncedScores() {
        if (!this.db) {
            await this.initializeDB();
        }
        
        // If still no DB (IndexedDB not available), return empty array
        if (!this.db) {
            console.warn('IndexedDB not available, cannot get unsynced scores');
            return [];
        }
        
        try {
            const transaction = this.db.transaction(['scores'], 'readonly');
            const store = transaction.objectStore('scores');
            
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                
                request.onsuccess = () => {
                    // Filter for unsynced scores manually
                    const allScores = request.result || [];
                    const unsyncedScores = allScores.filter(score => score.synced === false);
                    resolve(unsyncedScores);
                };
                
                request.onerror = () => {
                    console.warn('Error getting unsynced scores:', request.error);
                    resolve([]); // Return empty array instead of rejecting
                };
            });
        } catch (error) {
            console.warn('Transaction error:', error);
            return [];
        }
    }
    
    // Mark score as synced
    async markScoreAsSynced(scoreId) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readwrite');
        const store = transaction.objectStore('scores');
        
        return new Promise((resolve, reject) => {
            const getRequest = store.get(scoreId);
            
            getRequest.onsuccess = () => {
                const score = getRequest.result;
                if (score) {
                    score.synced = true;
                    const updateRequest = store.put(score);
                    
                    updateRequest.onsuccess = () => {
                        this.pendingSyncCount = Math.max(0, this.pendingSyncCount - 1);
                        this.updateSyncIndicator();
                        resolve();
                    };
                    
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve();
                }
            };
            
            getRequest.onerror = () => reject(getRequest.error);
        });
    }
    
    // Sync pending scores with server
    async syncPendingScores() {
        if (!this.isOnline) {
            console.log('Cannot sync: offline');
            return;
        }
        
        const unsyncedScores = await this.getUnsyncedScores();
        
        if (unsyncedScores.length === 0) {
            console.log('No scores to sync');
            return;
        }
        
        console.log(`Syncing ${unsyncedScores.length} pending scores...`);
        this.showNotification(`Syncing ${unsyncedScores.length} pending scores...`, 'info');
        
        let syncedCount = 0;
        
        for (const score of unsyncedScores) {
            try {
                const response = await fetch('/tetris/api/scores.php?action=save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerName: score.playerName,
                        score: score.score,
                        lines: score.lines,
                        level: score.level,
                        gameDuration: score.gameDuration,
                        specialAchievements: score.specialAchievements || {}
                    })
                });
                
                if (response.ok) {
                    await this.markScoreAsSynced(score.id);
                    syncedCount++;
                }
            } catch (error) {
                console.error('Failed to sync score:', error);
            }
        }
        
        if (syncedCount > 0) {
            this.showNotification(`${syncedCount} scores synced successfully!`, 'success');
        }
        
        return syncedCount;
    }
    
    // Cache leaderboard data
    async cacheLeaderboardData(type, data) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['leaderboard_cache'], 'readwrite');
        const store = transaction.objectStore('leaderboard_cache');
        
        const cacheEntry = {
            type: type, // 'top-scores' or 'recent'
            data: data,
            timestamp: Date.now()
        };
        
        return new Promise((resolve, reject) => {
            const request = store.put(cacheEntry);
            
            request.onsuccess = () => {
                console.log(`Cached ${type} leaderboard data`);
                resolve();
            };
            
            request.onerror = () => {
                console.error('Failed to cache leaderboard data:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Get cached leaderboard data
    async getCachedLeaderboardData(type) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['leaderboard_cache'], 'readonly');
        const store = transaction.objectStore('leaderboard_cache');
        
        return new Promise((resolve, reject) => {
            const request = store.get(type);
            
            request.onsuccess = () => {
                const cached = request.result;
                if (cached) {
                    // Check if cache is less than 1 hour old
                    const isRecent = (Date.now() - cached.timestamp) < 3600000;
                    resolve({
                        data: cached.data,
                        timestamp: cached.timestamp,
                        isRecent: isRecent
                    });
                } else {
                    resolve(null);
                }
            };
            
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    
    // Get all local scores (synced and unsynced)
    async getAllLocalScores() {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readonly');
        const store = transaction.objectStore('scores');
        
        return new Promise((resolve, reject) => {
            const request = store.getAll();
            
            request.onsuccess = () => {
                const scores = request.result || [];
                // Sort by score descending
                scores.sort((a, b) => b.score - a.score);
                resolve(scores);
            };
            
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    
    // Check for pending scores on startup
    async checkPendingScores() {
        try {
            const unsyncedScores = await this.getUnsyncedScores();
            this.pendingSyncCount = unsyncedScores.length;
            this.updateSyncIndicator();
            
            // Auto-sync if online
            if (this.isOnline && this.pendingSyncCount > 0) {
                setTimeout(() => this.syncPendingScores(), 2000);
            }
        } catch (error) {
            console.warn('Could not check pending scores:', error);
            this.pendingSyncCount = 0;
            this.updateSyncIndicator();
        }
    }
    
    // Update UI sync indicator
    updateSyncIndicator() {
        // Disabled - using mode-indicator in index.html instead
        // to avoid duplicate indicators
        return;
        
        /* Original code commented out to prevent conflicts
        const indicator = document.getElementById('offline-indicator');
        if (!indicator) {
            // Create indicator if it doesn't exist
            const div = document.createElement('div');
            div.id = 'offline-indicator';
            div.className = 'offline-indicator';
            document.body.appendChild(div);
        }
        
        const indicatorEl = document.getElementById('offline-indicator');
        
        if (!this.isOnline) {
            indicatorEl.innerHTML = `
                <span class="offline-icon">📴</span>
                <span>Offline Mode</span>
                ${this.pendingSyncCount > 0 ? `<span class="pending-count">${this.pendingSyncCount} pending</span>` : ''}
            `;
            indicatorEl.classList.add('visible', 'offline');
            indicatorEl.classList.remove('online');
        } else if (this.pendingSyncCount > 0) {
            indicatorEl.innerHTML = `
                <span class="sync-icon">🔄</span>
                <span>Syncing ${this.pendingSyncCount} scores...</span>
            `;
            indicatorEl.classList.add('visible', 'syncing');
            indicatorEl.classList.remove('offline', 'online');
        } else {
            indicatorEl.classList.remove('visible', 'offline', 'syncing');
            indicatorEl.classList.add('online');
        }
        */
    }
    
    // Show notification
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `offline-notification ${type}`;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => notification.classList.add('visible'), 10);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.classList.remove('visible');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
    
    // Register background sync
    async registerBackgroundSync() {
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
            try {
                const registration = await navigator.serviceWorker.ready;
                await registration.sync.register('sync-scores');
                console.log('Background sync registered');
            } catch (error) {
                console.error('Failed to register background sync:', error);
            }
        }
    }
}

// Export singleton instance
window.offlineStorage = const offlineStorage = new OfflineStorage();
})();

/* scripts/audio.js */
(function() {
// Modern Tetris - 80s Style Audio System

window.AudioManager = class AudioManager {
    constructor() {
        this.audioContext = null;
        this.masterGain = null;
        this.musicGain = null;
        this.sfxGain = null;
        
        // Audio settings - Balanced for comfortable extended play
        this.settings = {
            masterVolume: 0.7,    // Reduced master for better headroom
            musicVolume: 0.5,     // Background music level - present but not overwhelming
            sfxVolume: 0.7,       // Clear sound effects that cut through
            musicEnabled: true,
            sfxEnabled: true
        };
        
        // Master mute state
        this.masterMuted = false;
        
        // Load settings from localStorage
        this.loadSettings();
        
        // Background music state
        this.currentMusic = null;
        this.musicLoop = null;
        this.musicTimeout = null;
        this.currentMusicNotes = [];
        this.currentGameLevel = 1; // Track game level for adaptive music
        
        this.initializeAudioContext();
    }

    async initializeAudioContext() {
        try {
            // Check if Web Audio API is supported
            if (!(window.AudioContext || window.webkitAudioContext)) {
                throw new Error('Web Audio API not supported');
            }
            
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create gain nodes for volume control
            this.masterGain = this.audioContext.createGain();
            this.musicGain = this.audioContext.createGain();
            this.sfxGain = this.audioContext.createGain();
            
            // Connect gain nodes
            this.musicGain.connect(this.masterGain);
            this.sfxGain.connect(this.masterGain);
            this.masterGain.connect(this.audioContext.destination);
            
            // Set initial volumes
            this.updateVolumes();
            
        } catch (error) {
            this.audioContext = null;
            this.showAudioError('Audio not available: ' + error.message);
        }
    }

    // Show audio error to user
    showAudioError(message) {
        // Silent error handling - removed console.warn
        
        // Create a temporary notification element
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 10000;
            font-family: Arial, sans-serif;
            font-size: 14px;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    // Ensure audio context is resumed (required for user interaction)
    async resumeAudioContext() {
        if (!this.audioContext) {
            return false;
        }
        
        if (this.audioContext.state === 'suspended') {
            try {
                await this.audioContext.resume();
                return true;
            } catch (error) {
                this.showAudioError('Failed to resume audio: ' + error.message);
                return false;
            }
        }
        
        return this.audioContext.state === 'running';
    }

    // Load audio settings from localStorage
    loadSettings() {
        const saved = localStorage.getItem('tetris_audio_settings');
        if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
        }
    }

    // Save audio settings to localStorage
    saveSettings() {
        localStorage.setItem('tetris_audio_settings', JSON.stringify(this.settings));
    }

    // Update all volume levels
    updateVolumes() {
        if (!this.audioContext) return;
        
        // Only update master volume if not muted
        if (!this.masterMuted) {
            this.masterGain.gain.value = this.settings.masterVolume;
        }
        this.musicGain.gain.value = this.settings.musicEnabled ? this.settings.musicVolume : 0;
        this.sfxGain.gain.value = this.settings.sfxEnabled ? this.settings.sfxVolume : 0;
    }

    // Generate 80s-style synthesizer tones
    createOscillator(frequency, type = 'square', duration = 0.1) {
        if (!this.audioContext) return null;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        
        // 80s-style envelope (attack, decay, sustain, release)
        const now = this.audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack
        gainNode.gain.exponentialRampToValueAtTime(0.1, now + duration * 0.3); // Decay
        gainNode.gain.setValueAtTime(0.1, now + duration * 0.7); // Sustain
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Release
        
        oscillator.connect(gainNode);
        gainNode.connect(this.sfxGain);
        
        return { oscillator, gainNode, duration };
    }

    // Play a synthesized sound effect
    async playSFX(type) {
        if (!this.settings.sfxEnabled || !this.audioContext) {
            return;
        }
        
        // Ensure audio context is resumed before playing
        const resumed = await this.resumeAudioContext();
        if (!resumed) {
            return;
        }
        
        try {
            switch (type) {
                case 'move':
                    this.playMoveSound();
                    break;
                case 'rotate':
                    this.playRotateSound();
                    break;
                case 'drop':
                    this.playDropSound();
                    break;
                case 'lock':
                    this.playLockSound();
                    break;
                case 'lineClear':
                    this.playLineClearSound();
                    break;
                case 'tetris':
                    this.playTetrisSound();
                    break;
                case 'levelUp':
                    this.playLevelUpSound();
                    break;
                case 'gameOver':
                    this.playGameOverSound();
                    break;
                case 'hold':
                    this.playHoldSound();
                    break;
                case 'tspin':
                    this.playTSpinSound();
                    break;
            }
        } catch (error) {
            this.showAudioError(`Sound effect error: ${error.message}`);
        }
    }

    playMoveSound() {
        const sound = this.createOscillator(220, 'square', 0.05);
        if (sound) {
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playRotateSound() {
        const sound = this.createOscillator(330, 'sawtooth', 0.08);
        if (sound) {
            // Add frequency sweep for rotation effect
            sound.oscillator.frequency.exponentialRampToValueAtTime(
                440, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playDropSound() {
        const sound = this.createOscillator(110, 'square', 0.1);
        if (sound) {
            // Descending pitch for drop effect
            sound.oscillator.frequency.exponentialRampToValueAtTime(
                55, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playLockSound() {
        // Two-tone lock sound
        const sound1 = this.createOscillator(660, 'square', 0.06);
        const sound2 = this.createOscillator(440, 'square', 0.06);
        
        if (sound1 && sound2) {
            const now = this.audioContext.currentTime;
            sound1.oscillator.start(now);
            sound1.oscillator.stop(now + 0.03);
            
            sound2.oscillator.start(now + 0.03);
            sound2.oscillator.stop(now + 0.06);
        }
    }

    playLineClearSound() {
        // Ascending arpeggio for line clear
        const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6
        frequencies.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'square', 0.15);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.05);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.15);
            }
        });
    }

    playTetrisSound() {
        // Epic Tetris chord progression
        const chord1 = [523, 659, 784]; // C major
        const chord2 = [587, 740, 880]; // D major
        const chord3 = [659, 831, 988]; // E major
        
        [chord1, chord2, chord3].forEach((chord, chordIndex) => {
            chord.forEach((freq, noteIndex) => {
                const sound = this.createOscillator(freq, 'sawtooth', 0.3);
                if (sound) {
                    const startTime = this.audioContext.currentTime + (chordIndex * 0.1);
                    sound.oscillator.start(startTime);
                    sound.oscillator.stop(startTime + 0.3);
                }
            });
        });
    }

    playLevelUpSound() {
        // Victory fanfare
        const melody = [523, 659, 784, 1047, 1319]; // C5 to E6
        melody.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'triangle', 0.2);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.1);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.2);
            }
        });
    }

    playGameOverSound() {
        // Descending minor scale
        const melody = [523, 494, 440, 415, 392, 370, 330]; // C5 down
        melody.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'sawtooth', 0.4);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.15);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.4);
            }
        });
    }

    playHoldSound() {
        const sound = this.createOscillator(880, 'triangle', 0.12);
        if (sound) {
            sound.oscillator.frequency.linearRampToValueAtTime(
                660, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playTSpinSound() {
        // Special T-Spin sound with rapid frequency changes
        const sound = this.createOscillator(1000, 'square', 0.2);
        if (sound) {
            const now = this.audioContext.currentTime;
            sound.oscillator.frequency.setValueAtTime(1000, now);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.05);
            sound.oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
            
            sound.oscillator.start();
            sound.oscillator.stop(now + sound.duration);
        }
    }

    // Background Music System - Classic Tetris Style
    // Features authentic chiptune melodies inspired by Korobeiniki,
    // proper square wave instrumentation, and energetic rhythms
    startBackgroundMusic() {
        // Start background music
        if (!this.settings.musicEnabled || this.musicLoop) return;
        
        this.resumeAudioContext();
        this.playBackgroundLoop();
    }

    stopBackgroundMusic() {
        if (this.musicLoop) {
            clearTimeout(this.musicLoop);
            this.musicLoop = null;
        }
        
        // Clear any scheduled timeouts
        if (this.musicTimeout) {
            clearTimeout(this.musicTimeout);
            this.musicTimeout = null;
        }
        
        // Gradually fade out currently playing notes instead of abrupt stop
        if (this.currentMusicNotes) {
            const now = this.audioContext ? this.audioContext.currentTime : 0;
            this.currentMusicNotes.forEach(note => {
                if (note.gainNode && this.audioContext) {
                    try {
                        // Fade out over 2 seconds for smooth transition
                        note.gainNode.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
                        if (note.oscillator) {
                            setTimeout(() => {
                                try {
                                    note.oscillator.stop();
                                } catch (e) {
                                    // Ignore if already stopped
                                }
                            }, 2100);
                        }
                    } catch (e) {
                        // Fallback to immediate stop if smooth fade fails
                        if (note.oscillator) {
                            try {
                                note.oscillator.stop();
                            } catch (e2) {
                                // Ignore if already stopped
                            }
                        }
                    }
                }
            });
            // Clear the array after fade completes
            setTimeout(() => {
                this.currentMusicNotes = [];
            }, 2200);
        }
    }

    playBackgroundLoop() {
        // Play background loop
        // ENHANCED TETRIS THEME - Korobeiniki-inspired but unique composition
        // Optimized for extended gameplay with perfect looping and non-fatiguing mix
        const composition = [
            // === PART A: THE ICONIC OPENING (8 bars) ===
            // More accurate to the original Tetris theme rhythm and intervals
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5 - Iconic opening
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'main' }, // B4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'main' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'main' }, // B4
            
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'main' }, // A4
            { note: 440.00, duration: 0.5, harmony: [220.00], section: 'main' }, // A4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'main' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            
            { note: 493.88, duration: 1.5, harmony: [246.94], section: 'main' }, // B4 - extended
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'main' }, // D5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5
            
            { note: 523.25, duration: 1.0, harmony: [261.63], section: 'main' }, // C5
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'main' }, // A4
            { note: 440.00, duration: 2.0, harmony: [220.00], section: 'main' }, // A4 - hold
            
            // === PART B: THE ASCENDING SECTION (8 bars) ===
            // Creates variety and maintains interest
            { note: 0, duration: 0.5, harmony: [], section: 'bridge' }, // Rest
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'bridge' }, // D5
            { note: 698.46, duration: 1.0, harmony: [349.23], section: 'bridge' }, // F5
            { note: 880.00, duration: 1.0, harmony: [440.00], section: 'bridge' }, // A5
            
            { note: 784.00, duration: 0.5, harmony: [392.00], section: 'bridge' }, // G5
            { note: 698.46, duration: 0.5, harmony: [349.23], section: 'bridge' }, // F5
            { note: 659.25, duration: 1.5, harmony: [329.63], section: 'bridge' }, // E5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'bridge' }, // E5
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'bridge' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            { note: 493.88, duration: 2.0, harmony: [246.94], section: 'bridge' }, // B4 - hold
            
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'bridge' }, // B4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'bridge' }, // D5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'bridge' }, // E5
            
            { note: 523.25, duration: 1.0, harmony: [261.63], section: 'bridge' }, // C5
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'bridge' }, // A4
            { note: 440.00, duration: 2.0, harmony: [220.00], section: 'bridge' }, // A4 - hold
        ];
        
        // OPTIMIZED BASS LINE - More subtle and supportive, less fatiguing
        // Uses walking bass patterns that complement without overwhelming
        const bassPatterns = {
            main: [
                164.81, 0, 164.81, 0,      // E3 with rests - less constant
                110.00, 0, 110.00, 0,      // A2 with rests
                146.83, 0, 130.81, 0,      // D3, C3 walking pattern
                123.47, 0, 110.00, 0       // B2, A2 resolution
            ],
            bridge: [
                146.83, 0, 174.61, 0,      // D3, F3 with space
                220.00, 0, 196.00, 0,      // A3, G3 higher register
                164.81, 0, 130.81, 0,      // E3, C3 return
                123.47, 0, 146.83, 0       // B2, D3 turnaround
            ]
        };
        
        let noteIndex = 0;
        let sectionBassIndex = 0;
        this.currentMusicNotes = [];
        
        const playNextNote = async () => {
            if (!this.settings.musicEnabled) return;
            
            // Playing note
            
            // Clean up old notes to prevent memory leaks
            const now = this.audioContext ? this.audioContext.currentTime : 0;
            this.currentMusicNotes = this.currentMusicNotes.filter(note => {
                if (note.startTime && (now - note.startTime) > 5) { // Reduced from 10 to 5 seconds
                    try {
                        if (note.oscillator) {
                            note.oscillator.stop();
                            note.oscillator.disconnect();
                        }
                        if (note.gainNode) note.gainNode.disconnect();
                        if (note.filterNode) note.filterNode.disconnect();
                    } catch (e) {
                        // Already stopped or disconnected
                    }
                    return false;
                }
                return true;
            });
            
            const currentNote = composition[noteIndex];
            const currentSection = currentNote.section;
            const bassPattern = bassPatterns[currentSection];
            const bassNote = bassPattern[sectionBassIndex % bassPattern.length];
            
            // Play main melody note (skip if it's a rest - note frequency 0)
            if (currentNote.note > 0) {
                const mainSound = this.createMusicNote(currentNote.note, currentNote.duration, 'lead');
                if (mainSound) {
                    mainSound.startTime = now;
                    mainSound.oscillator.start(now);
                    this.currentMusicNotes.push(mainSound);
                }
                
                // Play harmony notes with tight, precise chiptune timing
                currentNote.harmony.forEach((harmonyFreq, index) => {
                    const harmonySound = this.createMusicNote(harmonyFreq, currentNote.duration, 'harmony');
                    if (harmonySound) {
                        const delay = index * 0.01; // Very tight timing for authentic chiptune feel
                        harmonySound.startTime = now + delay;
                        harmonySound.oscillator.start(now + delay);
                        this.currentMusicNotes.push(harmonySound);
                    }
                });
            }
            
            // Play bass line (only if melody isn't resting - bass follows melody rhythm)
            if (currentNote.note > 0 && bassNote > 0) {
                const bassSound = this.createMusicNote(bassNote, currentNote.duration, 'bass');
                if (bassSound) {
                    bassSound.startTime = now;
                    bassSound.oscillator.start(now);
                    this.currentMusicNotes.push(bassSound);
                }
            }
            
            noteIndex = (noteIndex + 1) % composition.length;
            sectionBassIndex++;
            
            // Reset bass index when changing sections
            const nextSection = composition[noteIndex].section;
            if (nextSection !== currentSection) {
                sectionBassIndex = 0;
            }
        };
        
        // Start playing with authentic Tetris tempo - fast, energetic, and addictive
        const scheduleNextNote = () => {
            if (!this.settings.musicEnabled) return;
            
            playNextNote();
            const currentNote = composition[noteIndex];
            // ADAPTIVE TEMPO - Starts moderate and can speed up with game level
            // Base tempo around 120 BPM for comfortable extended listening
            const tempoMultiplier = this.getMusicSpeedMultiplier ? this.getMusicSpeedMultiplier() : 1.0;
            const baseDelay = 250; // More relaxed base tempo (120 BPM)
            const nextDelay = (currentNote.duration * baseDelay) / tempoMultiplier;
            this.musicTimeout = setTimeout(scheduleNextNote, nextDelay);
        };
        
        // Set musicLoop to indicate music is playing (use timeout ID)
        this.musicLoop = setTimeout(scheduleNextNote, 50); // Start quickly
    }

    createMusicNote(frequency, duration, instrument = 'lead') {
        if (!this.audioContext || frequency === 0) return null; // Support rests
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filterNode = this.audioContext.createBiquadFilter();
        
        // Get current time first for consistent timing
        const now = this.audioContext.currentTime;
        
        // ENHANCED CHIPTUNE SYNTHESIS with better mixing
        switch (instrument) {
            case 'lead':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Subtle vibrato for character without being overwhelming
                const vibratoDepth = 0.002; // Much subtler vibrato
                const vibratoRate = 5; // Hz
                const lfo = this.audioContext.createOscillator();
                const lfoGain = this.audioContext.createGain();
                lfo.frequency.value = vibratoRate;
                lfoGain.gain.value = frequency * vibratoDepth;
                lfo.connect(lfoGain);
                lfoGain.connect(oscillator.frequency);
                lfo.start(now);
                lfo.stop(now + duration + 0.1);
                
                // Add gentle low-pass filter to soften harsh harmonics
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 2000;
                filterNode.Q.value = 0.5;
                break;
                
            case 'harmony':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Softer filter for harmony to sit behind lead
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 1500;
                filterNode.Q.value = 0.3;
                break;
                
            case 'bass':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Gentle pitch envelope for character
                oscillator.frequency.setValueAtTime(frequency * 0.98, now);
                oscillator.frequency.exponentialRampToValueAtTime(frequency, now + 0.01);
                
                // Low-pass filter to keep bass clean
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 800;
                filterNode.Q.value = 1.0;
                break;
                
            default:
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 2000;
        }
        
        // BALANCED MIXING - Pleasant for extended listening
        let volume;
        
        switch (instrument) {
            case 'lead':
                volume = 0.35; // Reduced but still prominent
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.002); // Quick attack
                gainNode.gain.linearRampToValueAtTime(volume * 0.85, now + 0.01); // Slight decay
                gainNode.gain.setValueAtTime(volume * 0.85, now + duration * 0.8); // Sustain
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.02); // Release
                break;
                
            case 'harmony':
                volume = 0.20; // Supportive, not overwhelming
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.003);
                gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.015);
                gainNode.gain.setValueAtTime(volume * 0.8, now + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.03);
                break;
                
            case 'bass':
                volume = 0.25; // Present but not boomy
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.001); // Tight attack
                gainNode.gain.linearRampToValueAtTime(volume * 0.9, now + 0.005);
                gainNode.gain.setValueAtTime(volume * 0.9, now + duration * 0.9);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.01);
                break;
                
            default:
                volume = 0.2;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.1);
        }
        
        // Connect with filter for better sound quality
        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(this.musicGain);
        
        return { oscillator, gainNode, filterNode };
    }

    // Volume Controls
    setMasterVolume(volume) {
        this.settings.masterVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    setMusicVolume(volume) {
        this.settings.musicVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    setSFXVolume(volume) {
        this.settings.sfxVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    // Toggle Controls
    toggleMusic() {
        this.settings.musicEnabled = !this.settings.musicEnabled;
        this.updateVolumes();
        this.saveSettings();
        
        if (this.settings.musicEnabled) {
            this.startBackgroundMusic();
        } else {
            this.stopBackgroundMusic();
        }
    }

    toggleSFX() {
        this.settings.sfxEnabled = !this.settings.sfxEnabled;
        this.updateVolumes();
        this.saveSettings();
    }

    // Master mute control (for window focus/blur)
    setMasterMute(muted) {
        if (!this.masterGain) return;
        
        this.masterMuted = muted;
        
        if (muted) {
            // Store current volume before muting
            this.previousMasterVolume = this.settings.masterVolume;
            this.masterGain.gain.value = 0;
        } else {
            // Restore previous volume or use current setting
            const volumeToRestore = this.previousMasterVolume ?? this.settings.masterVolume;
            this.masterGain.gain.value = volumeToRestore;
        }
    }

    // Get current settings for UI
    getSettings() {
        return { ...this.settings };
    }

    // Set game level for adaptive music tempo
    setGameLevel(level) {
        this.currentGameLevel = Math.max(1, Math.min(level, 20)); // Cap at level 20
    }
    
    // Get music speed multiplier based on game level
    getMusicSpeedMultiplier() {
        // Start at 1.0x speed, increase by 2% per level, max 1.4x at level 20
        return Math.min(1.4, 1.0 + (this.currentGameLevel - 1) * 0.02);
    }
    
    // Cleanup
    destroy() {
        this.stopBackgroundMusic();
        // Clean up all audio nodes
        this.currentMusicNotes.forEach(note => {
            try {
                if (note.oscillator) {
                    note.oscillator.stop();
                    note.oscillator.disconnect();
                }
                if (note.gainNode) note.gainNode.disconnect();
                if (note.filterNode) note.filterNode.disconnect();
            } catch (e) {
                // Ignore cleanup errors
            }
        });
        this.currentMusicNotes = [];
        
        if (this.audioContext) {
            this.audioContext.close();
        }
    }
}
})();

/* scripts/input.js */
(function() {
// Modern Tetris - Input Management System

window.InputManager = class InputManager {
    constructor(game) {
        this.game = game;
        this.keys = {};
        this.keyBindings = {
            // Movement
            'ArrowLeft': 'moveLeft',
            'ArrowRight': 'moveRight',
            'ArrowDown': 'softDrop',
            'ArrowUp': 'rotateClockwise',
            
            // Alternative controls
            'KeyA': 'moveLeft',
            'KeyD': 'moveRight',
            'KeyS': 'softDrop',
            'KeyW': 'rotateClockwise',
            'KeyQ': 'rotateCounterclockwise',
            'KeyE': 'rotateClockwise',
            
            // Special actions
            'Space': 'hardDrop',
            'KeyC': 'hold',
            'KeyP': 'pause',
            'Escape': 'pause',
            'KeyR': 'restart',
            'Enter': 'confirm'
        };
        
        // DAS (Delayed Auto Shift) settings
        this.das = {
            delay: 100,     // 100ms initial delay (more responsive)
            repeat: 20,     // 20ms repeat rate (50Hz, much faster)
            leftTime: 0,
            rightTime: 0,
            downTime: 0
        };
        
        // Track if first press was handled
        this.firstPress = {
            left: false,
            right: false,
            down: false
        };
        
        this.touchControls = {
            startX: 0,
            startY: 0,
            threshold: 25, // Reduced threshold for more responsive swipe detection
            isActive: false,
            startTime: 0,
            longPressThreshold: 800, // 800ms for long press (increased to avoid conflicts with continuous drop)
            longPressTriggered: false,
            isDownSwipe: false,
            downSwipeSpeed: 0,
            continuousDropActive: false
        };
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Keyboard events
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
        
        // Prevent default for game controls and handle key repeat issues
        document.addEventListener('keydown', (e) => {
            // Don't prevent default when modals are active to allow typing
            if (this.isNameInputActive() || this.isLeaderboardActive() || 
                this.isSettingsActive() || this.isHelpActive()) {
                return;
            }
            
            if (this.keyBindings[e.code]) {
                e.preventDefault();
                // Also stop propagation to prevent multiple handlers
                e.stopImmediatePropagation();
            }
        });
        
        // Touch and mouse events for canvas interactions
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
            canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
            canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            
            // Mouse events
            canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        }
        
        // Also add touch events to game overlay for pause/resume functionality
        const gameOverlay = document.getElementById('game-overlay');
        if (gameOverlay) {
            gameOverlay.addEventListener('touchstart', (e) => this.handleTouchStart(e));
            gameOverlay.addEventListener('touchmove', (e) => this.handleTouchMove(e));
            gameOverlay.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            gameOverlay.addEventListener('click', (e) => this.handleCanvasClick(e));
        }
        
        // Add touch support for UI elements
        this.initializeTouchUI();
        
        // Show mobile controls hint on touch devices
        this.showMobileControlsHint();
        
        // Focus management
        window.addEventListener('blur', () => this.handleWindowBlur());
        window.addEventListener('focus', () => this.handleWindowFocus());
        
        // Page visibility API for better mobile support
        document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
    }

    handleKeyDown(e) {
        // Check if any modal is active - if so, ignore game controls
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) {
            // Only allow specific keys during name input
            if (this.isNameInputActive()) {
                // Allow normal typing, Enter for save, Escape to close
                if (e.code === 'Enter') {
                    const saveButton = document.getElementById('save-score-button');
                    if (saveButton) saveButton.click();
                    return;
                } else if (e.code === 'Escape') {
                    const skipButton = document.getElementById('skip-save-button');
                    if (skipButton) skipButton.click();
                    return;
                }
                // Let all other keys pass through for typing
                return;
            }
            
            // For leaderboard, only allow Escape to close
            if (this.isLeaderboardActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-leaderboard');
                if (closeButton) closeButton.click();
                return;
            }
            
            // For settings, only allow Escape to close
            if (this.isSettingsActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-settings');
                if (closeButton) closeButton.click();
                return;
            }
            
            // For help, only allow Escape to close
            if (this.isHelpActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-help');
                if (closeButton) closeButton.click();
                return;
            }
            
            // Block all other game controls when modals are open
            e.preventDefault();
            return;
        }
        
        const action = this.keyBindings[e.code];
        if (!action) return;
        
        // Prevent key repeat for certain actions
        if (this.keys[e.code] && this.isInstantAction(action)) {
            return;
        }
        
        const wasPressed = this.keys[e.code];
        this.keys[e.code] = true;
        
        // Handle instant actions immediately
        if (this.isInstantAction(action)) {
            this.executeAction(action);
        } else if (!wasPressed) {
            // For movement actions, execute immediately on first press
            if (action === 'moveLeft') {
                this.executeAction(action);
                this.firstPress.left = true;
                this.das.leftTime = 0;
            } else if (action === 'moveRight') {
                this.executeAction(action);
                this.firstPress.right = true;
                this.das.rightTime = 0;
            } else if (action === 'softDrop') {
                this.executeAction(action);
                this.firstPress.down = true;
                this.das.downTime = 0;
            }
        }
    }

    handleKeyUp(e) {
        // Check if any modal is active - if so, ignore game key releases
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) {
            return;
        }
        
        this.keys[e.code] = false;
        
        // Reset DAS timers and first press flags
        const action = this.keyBindings[e.code];
        if (action === 'moveLeft') {
            this.das.leftTime = 0;
            this.firstPress.left = false;
        }
        if (action === 'moveRight') {
            this.das.rightTime = 0;
            this.firstPress.right = false;
        }
        if (action === 'softDrop') {
            this.das.downTime = 0;
            this.firstPress.down = false;
        }
    }

    handleTouchStart(e) {
        // Only prevent default for game canvas touches
        e.preventDefault();
        const touch = e.touches[0];
        
        // Get touch coordinates relative to canvas
        const rect = e.target.getBoundingClientRect();
        this.touchControls.startX = touch.clientX - rect.left;
        this.touchControls.startY = touch.clientY - rect.top;
        this.touchControls.startTime = Date.now();
        this.touchControls.isActive = true;
        this.touchControls.longPressTriggered = false;
        
        // Set timeout for long press detection
        this.longPressTimeout = setTimeout(() => {
            if (this.touchControls.isActive && 
                !this.touchControls.longPressTriggered && 
                !this.touchControls.isDownSwipe && 
                !this.touchControls.continuousDropActive) {
                this.touchControls.longPressTriggered = true;
                this.executeAction('hold');
            }
        }, this.touchControls.longPressThreshold);
    }

    handleTouchMove(e) {
        if (!this.touchControls.isActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = e.target.getBoundingClientRect();
        const currentY = touch.clientY - rect.top;
        const deltaY = currentY - this.touchControls.startY;
        
        // Detect continuous down swipe
        if (deltaY > this.touchControls.threshold && !this.touchControls.longPressTriggered) {
            if (!this.touchControls.isDownSwipe) {
                this.touchControls.isDownSwipe = true;
                this.touchControls.continuousDropActive = true;
                
                // Calculate swipe speed (distance per time)
                const timeElapsed = Date.now() - this.touchControls.startTime;
                this.touchControls.downSwipeSpeed = Math.min(deltaY / Math.max(timeElapsed, 1), 2); // Cap at 2x speed
                
                // Start continuous soft drop
                this.startContinuousDrop();
            }
        }
    }

    handleTouchEnd(e) {
        if (!this.touchControls.isActive) return;
        e.preventDefault();
        
        // Clear long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
        
        // Stop continuous drop if active
        if (this.touchControls.continuousDropActive) {
            this.stopContinuousDrop();
        }
        
        // Check if game is paused - allow tap to unpause
        if (this.game && this.game.state === 'paused') {
            const touchDuration = Date.now() - this.touchControls.startTime;
            // Only unpause on quick tap (not long press or swipe)
            if (touchDuration < 300 && !this.touchControls.longPressTriggered && !this.touchControls.isDownSwipe) {
                this.game.togglePause();
                this.resetTouchControls();
                return;
            }
        }
        
        // If long press was triggered, don't process other gestures
        if (this.touchControls.longPressTriggered) {
            this.resetTouchControls();
            return;
        }
        
        // If continuous drop was active, don't process other gestures
        if (this.touchControls.isDownSwipe) {
            this.resetTouchControls();
            return;
        }
        
        const touch = e.changedTouches[0];
        const rect = e.target.getBoundingClientRect();
        const endX = touch.clientX - rect.left;
        const endY = touch.clientY - rect.top;
        const deltaX = endX - this.touchControls.startX;
        const deltaY = endY - this.touchControls.startY;
        const threshold = this.touchControls.threshold;
        const touchDuration = Date.now() - this.touchControls.startTime;
        
        // Determine gesture
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Horizontal swipe
            if (Math.abs(deltaX) > threshold) {
                if (deltaX > 0) {
                    this.executeAction('moveRight');
                } else {
                    this.executeAction('moveLeft');
                }
            }
        } else {
            // Vertical swipe
            if (Math.abs(deltaY) > threshold) {
                if (deltaY < 0) {
                    // Swipe up - hard drop
                    this.executeAction('hardDrop');
                }
                // Note: Down swipe is now handled by continuous drop in touchMove
            } else if (touchDuration < this.touchControls.longPressThreshold) {
                // Quick tap - rotate
                this.executeAction('rotateClockwise');
            }
        }
        
        this.resetTouchControls();
    }

    handleCanvasClick(e) {
        // Handle canvas clicks for piece placement or rotation
        // For now, just rotate on click
        this.executeAction('rotateClockwise');
    }

    handleWindowBlur() {
        // Clear all keys when window loses focus
        this.keys = {};
        // Reset DAS and first press flags
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Stop any continuous touch actions
        this.stopContinuousDrop();
        this.resetTouchControls();
        
        // Auto-pause if game is active and mute audio
        if (this.game && this.game.state === 'playing') {
            this.game.pause();
            this.wasAutoPaused = true; // Flag to remember this was auto-paused
        }
        
        // Mute audio when window loses focus
        if (this.game && this.game.audioManager) {
            this.game.audioManager.setMasterMute(true);
        }
    }

    handleWindowFocus() {
        // Reset DAS timers and first press flags
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Restore audio when window regains focus
        if (this.game && this.game.audioManager) {
            this.game.audioManager.setMasterMute(false);
        }
        
        // Note: We don't auto-resume the game to let the user decide when to continue
        // The game will remain paused and can be resumed with P key or touch
        this.wasAutoPaused = false;
    }

    handleVisibilityChange() {
        if (document.hidden) {
            // Page is now hidden (mobile browser switching, etc.)
            this.handleWindowBlur();
        } else {
            // Page is now visible
            this.handleWindowFocus();
        }
    }

    // Update input state (called every frame)
    update(deltaTime) {
        if (!this.game || this.game.state !== 'playing') return;
        
        // Check if any modal is active - if so, disable game controls
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) return;
        
        // Handle DAS (Delayed Auto Shift)
        this.updateDAS(deltaTime);
    }

    updateDAS(deltaTime) {
        // Left movement
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
            if (this.firstPress.left) {
                this.das.leftTime += deltaTime;
                if (this.das.leftTime >= this.das.delay) {
                    // After delay, start repeating
                    const repeatTime = this.das.leftTime - this.das.delay;
                    if (repeatTime >= this.das.repeat) {
                        this.executeAction('moveLeft');
                        this.das.leftTime = this.das.delay; // Reset repeat timer
                    }
                }
            }
        }
        
        // Right movement
        if (this.keys['ArrowRight'] || this.keys['KeyD']) {
            if (this.firstPress.right) {
                this.das.rightTime += deltaTime;
                if (this.das.rightTime >= this.das.delay) {
                    // After delay, start repeating
                    const repeatTime = this.das.rightTime - this.das.delay;
                    if (repeatTime >= this.das.repeat) {
                        this.executeAction('moveRight');
                        this.das.rightTime = this.das.delay; // Reset repeat timer
                    }
                }
            }
        }
        
        // Soft drop
        if (this.keys['ArrowDown'] || this.keys['KeyS']) {
            if (this.firstPress.down) {
                this.das.downTime += deltaTime;
                if (this.das.downTime >= this.das.repeat) {
                    this.executeAction('softDrop');
                    this.das.downTime = 0;
                }
            }
        }
    }

    // Execute game action
    executeAction(action) {
        if (!this.game) return;
        
        switch (action) {
            case 'moveLeft':
                this.game.movePiece(-1, 0);
                break;
            case 'moveRight':
                this.game.movePiece(1, 0);
                break;
            case 'softDrop':
                this.game.softDrop();
                break;
            case 'hardDrop':
                this.game.hardDrop();
                break;
            case 'rotateClockwise':
                this.game.rotatePiece(1);
                break;
            case 'rotateCounterclockwise':
                this.game.rotatePiece(-1);
                break;
            case 'hold':
                this.game.holdPiece();
                break;
            case 'pause':
                this.game.togglePause();
                break;
            case 'restart':
                this.game.restart();
                break;
            case 'confirm':
                this.game.handleConfirm();
                break;
        }
    }

    // Check if action should only happen once per keypress
    isInstantAction(action) {
        return [
            'rotateClockwise',
            'rotateCounterclockwise',
            'hardDrop',
            'hold',
            'pause',
            'restart',
            'confirm'
        ].includes(action);
    }

    // Get current input state
    getInputState() {
        return {
            left: this.keys['ArrowLeft'] || this.keys['KeyA'],
            right: this.keys['ArrowRight'] || this.keys['KeyD'],
            down: this.keys['ArrowDown'] || this.keys['KeyS'],
            rotateClockwise: this.keys['ArrowUp'] || this.keys['KeyW'] || this.keys['KeyE'],
            rotateCounterclockwise: this.keys['KeyQ'],
            hardDrop: this.keys['Space'],
            hold: this.keys['KeyC'],
            pause: this.keys['KeyP'] || this.keys['Escape'],
            restart: this.keys['KeyR'],
            confirm: this.keys['Enter']
        };
    }

    // Check if name input modal is active
    isNameInputActive() {
        const overlay = document.getElementById('name-input-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if leaderboard modal is active
    isLeaderboardActive() {
        const overlay = document.getElementById('leaderboard-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if settings modal is active
    isSettingsActive() {
        const overlay = document.getElementById('settings-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if help modal is active
    isHelpActive() {
        const overlay = document.getElementById('help-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }

    // Start continuous drop for touch down swipe
    startContinuousDrop() {
        if (!this.game || this.game.state !== 'playing') return;
        
        // Calculate drop interval based on swipe speed (faster swipe = faster drop)
        const baseInterval = 50; // Base 50ms interval
        const speedMultiplier = Math.max(0.3, 1 - this.touchControls.downSwipeSpeed * 0.3);
        const dropInterval = baseInterval * speedMultiplier; // Faster swipe = shorter interval
        
        // Clear any existing interval
        if (this.continuousDropInterval) {
            clearInterval(this.continuousDropInterval);
        }
        
        // Start continuous dropping
        this.continuousDropInterval = setInterval(() => {
            if (!this.touchControls.continuousDropActive || !this.game || this.game.state !== 'playing') {
                this.stopContinuousDrop();
                return;
            }
            this.executeAction('softDrop');
        }, dropInterval);
    }
    
    // Stop continuous drop
    stopContinuousDrop() {
        if (this.continuousDropInterval) {
            clearInterval(this.continuousDropInterval);
            this.continuousDropInterval = null;
        }
        this.touchControls.continuousDropActive = false;
    }
    
    // Reset touch controls state
    resetTouchControls() {
        this.touchControls.isActive = false;
        this.touchControls.isDownSwipe = false;
        this.touchControls.longPressTriggered = false;
        this.touchControls.continuousDropActive = false;
        this.touchControls.downSwipeSpeed = 0;
    }

    // Update DAS settings
    updateDASSettings(settings) {
        if (settings.delay !== undefined) this.das.delay = settings.delay;
        if (settings.repeat !== undefined) this.das.repeat = settings.repeat;
    }

    // Reset input state
    reset() {
        this.keys = {};
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Reset touch controls
        this.stopContinuousDrop();
        this.resetTouchControls();
        
        // Clear any pending long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
    }

    // Show mobile controls hint on touch devices
    showMobileControlsHint() {
        // Check if device supports touch
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const mobileControlsHint = document.getElementById('mobile-controls-hint');
        
        if (isTouchDevice && mobileControlsHint) {
            mobileControlsHint.style.display = 'flex';
            
            // Auto-hide after 5 seconds during gameplay
            const autoHide = () => {
                if (this.game && this.game.state === 'playing') {
                    mobileControlsHint.style.opacity = '0.7';
                    setTimeout(() => {
                        if (this.game && this.game.state === 'playing') {
                            mobileControlsHint.style.display = 'none';
                        }
                    }, 5000);
                }
            };
            
            // Hide hint after 10 seconds or when game starts
            setTimeout(autoHide, 10000);
            
            // Also hide when game starts
            if (this.game) {
                const originalStart = this.game.start?.bind(this.game);
                if (originalStart) {
                    this.game.start = (...args) => {
                        originalStart(...args);
                        setTimeout(autoHide, 3000);
                    };
                }
            }
        }
    }
    
    // Initialize touch support for UI elements
    initializeTouchUI() {
        // Add better touch support for all buttons
        const buttons = document.querySelectorAll('button, .btn-primary, .btn-secondary, .btn-icon, .btn-close');
        buttons.forEach(button => {
            // Ensure buttons are clickable on mobile
            button.style.touchAction = 'manipulation';
            
            // Add active state for better touch feedback
            button.addEventListener('touchstart', (e) => {
                button.classList.add('touch-active');
                e.stopPropagation(); // Prevent game touch handling
            }, { passive: false });
            
            button.addEventListener('touchend', (e) => {
                button.classList.remove('touch-active');
                e.stopPropagation();
            }, { passive: false });
            
            button.addEventListener('touchcancel', () => {
                button.classList.remove('touch-active');
            });
        });
        
        // Add touch support for modal overlays (to prevent closing on touch)
        const modals = document.querySelectorAll('.name-input-content, .leaderboard-content, .settings-content, .help-content');
        modals.forEach(modal => {
            modal.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });
            modal.addEventListener('touchend', (e) => {
                e.stopPropagation();
            });
        });
        
        // Ensure input fields work properly on touch devices
        const inputs = document.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.style.touchAction = 'manipulation';
            input.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });
        });
    }
    
    // Cleanup event listeners
    destroy() {
        document.removeEventListener('keydown', this.handleKeyDown);
        document.removeEventListener('keyup', this.handleKeyUp);
        
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            canvas.removeEventListener('touchstart', this.handleTouchStart);
            canvas.removeEventListener('touchmove', this.handleTouchMove);
            canvas.removeEventListener('touchend', this.handleTouchEnd);
        }
        
        // Clean up continuous drop
        this.stopContinuousDrop();
        
        // Clear long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
        
        window.removeEventListener('blur', this.handleWindowBlur);
        window.removeEventListener('focus', this.handleWindowFocus);
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
    }
}
})();

/* scripts/puzzles/puzzleData.js */
(function() {
// Puzzle Data - 150 unique puzzle challenges
window.PUZZLES = const PUZZLES = [
    // Beginner Puzzles (1-30) - Teaching basics
    {
        id: 1,
        name: "First Clear",
        category: "beginner",
        difficulty: 1,
        objective: "clear",
        targetLines: 1,
        description: "Clear 1 line",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,1,1,0,1,1,1]
        ],
        pieces: ['I'],
        maxPieces: 3,
        timeLimit: 0
    },
    {
        id: 2,
        name: "Double Trouble",
        category: "beginner",
        difficulty: 1,
        objective: "clear",
        targetLines: 2,
        description: "Clear 2 lines at once",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,0,0,1,1,1,1],
            [1,1,1,1,0,0,1,1,1,1]
        ],
        pieces: ['O', 'O'],  // Changed to 2 O pieces for feasibility
        maxPieces: 5,  // Increased to allow more attempts
        timeLimit: 0
    },
    {
        id: 3,
        name: "T-Spin Tutorial",
        category: "beginner",
        difficulty: 2,
        objective: "tspin",
        targetTSpins: 1,
        description: "Perform your first T-Spin",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1],
            [1,1,1,1,1,1,1,1,0,1]
        ],
        pieces: ['T'],
        maxPieces: 5,
        timeLimit: 0
    },
    {
        id: 4,
        name: "Tetris Time",
        category: "beginner",
        difficulty: 2,
        objective: "tetris",
        targetTetris: 1,
        description: "Clear 4 lines at once (Tetris)",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1]
        ],
        pieces: ['I'],
        maxPieces: 2,
        timeLimit: 0
    },
    {
        id: 5,
        name: "Perfect Clear",
        category: "beginner",
        difficulty: 3,
        objective: "perfectclear",
        description: "Clear the entire board",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,0,0,1,1,1,1]
        ],
        pieces: 'random',  // Changed to random for perfect clear
        maxPieces: 10,      // More pieces for flexibility
        timeLimit: 0
    }
];

// Generate additional puzzles programmatically
function generatePuzzles() {
    const additionalPuzzles = [];
    let id = 6;
    
    // Intermediate Puzzles (31-60)
    for (let i = 0; i < 25; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Challenge ${id}`,
            category: "intermediate",
            difficulty: 3 + Math.floor(i / 8),
            objective: ["clear", "tspin", "tetris", "perfectclear"][i % 4],
            targetLines: 2 + Math.floor(i / 5),
            description: `Clear ${2 + Math.floor(i / 5)} lines with style`,
            initialGrid: generateRandomGrid(10 + i % 5),
            pieces: generatePieceSet(3 + Math.floor(i / 10)),
            maxPieces: 10 + Math.floor(i / 5),  // Increased for better playability
            timeLimit: i > 15 ? 120 : 0
        });
    }
    
    // Advanced Puzzles (61-90)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Expert ${id}`,
            category: "advanced",
            difficulty: 6 + Math.floor(i / 10),
            objective: ["combo", "tspin", "tetris", "perfectclear"][i % 4],
            targetLines: 3 + Math.floor(i / 4),
            targetCombo: i % 4 === 0 ? 3 + Math.floor(i / 10) : undefined,
            targetTSpins: i % 4 === 1 ? 2 : undefined,
            targetTetris: i % 4 === 2 ? 1 : undefined,
            description: `Advanced technique required`,
            initialGrid: generateComplexGrid(12 + i % 6),
            pieces: generatePieceSet(4 + Math.floor(i / 8)),
            maxPieces: 12 + Math.floor(i / 8),  // Increased for better playability
            timeLimit: 90 - (i * 2)
        });
    }
    
    // Expert Puzzles (91-120)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Master ${id}`,
            category: "expert",
            difficulty: 8 + Math.floor(i / 15),
            objective: "mixed",
            targetLines: 4 + Math.floor(i / 3),
            targetTSpins: 1 + Math.floor(i / 15),
            targetCombo: 4 + Math.floor(i / 10),
            description: `Master-level challenge`,
            initialGrid: generateExpertGrid(14 + i % 4),
            pieces: generateMixedPieceSet(5 + Math.floor(i / 6)),
            maxPieces: 15 + Math.floor(i / 6),  // Increased for better playability
            timeLimit: 60
        });
    }
    
    // Grandmaster Puzzles (121-150)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Grandmaster ${id}`,
            category: "grandmaster",
            difficulty: 10,
            objective: "survival",
            targetLines: 5 + Math.floor(i / 2),
            minScore: 1000 * (i + 1),
            description: `Ultimate Tetris challenge`,
            initialGrid: generateGrandmasterGrid(16 + i % 3),
            pieces: "random",
            maxPieces: 20 + Math.floor(i / 3),  // Increased significantly for survival mode
            timeLimit: 45
        });
    }
    
    return additionalPuzzles;
}

// Helper functions to generate grids
function generateRandomGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    for (let row = 20 - filledRows; row < 20; row++) {
        for (let col = 0; col < 10; col++) {
            if (Math.random() > 0.2) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateComplexGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    for (let row = 20 - filledRows; row < 20; row++) {
        const holes = Math.floor(Math.random() * 3) + 1;
        const holePositions = [];
        for (let i = 0; i < holes; i++) {
            holePositions.push(Math.floor(Math.random() * 10));
        }
        for (let col = 0; col < 10; col++) {
            if (!holePositions.includes(col)) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateExpertGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    // Create challenging patterns
    for (let row = 20 - filledRows; row < 20; row++) {
        const pattern = row % 3;
        for (let col = 0; col < 10; col++) {
            if (pattern === 0 && col % 2 === 0) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            } else if (pattern === 1 && col % 2 === 1) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            } else if (pattern === 2 && col !== 4 && col !== 5) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateGrandmasterGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    // Create very challenging patterns with minimal clearing opportunities
    for (let row = 20 - filledRows; row < 20; row++) {
        const clearable = row === 19 || Math.random() > 0.7;
        if (clearable) {
            // Leave strategic holes
            const hole = Math.floor(Math.random() * 10);
            for (let col = 0; col < 10; col++) {
                if (col !== hole) {
                    grid[row][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        } else {
            // Complex pattern
            for (let col = 0; col < 10; col++) {
                if (Math.random() > 0.15) {
                    grid[row][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }
    }
    return grid;
}

function generatePieceSet(count) {
    const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    const set = [];
    for (let i = 0; i < count; i++) {
        set.push(pieces[Math.floor(Math.random() * pieces.length)]);
    }
    return set;
}

function generateMixedPieceSet(count) {
    const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    const set = [];
    // Ensure variety
    pieces.forEach(piece => {
        if (set.length < count) {
            set.push(piece);
        }
    });
    // Fill remaining with random
    while (set.length < count) {
        set.push(pieces[Math.floor(Math.random() * pieces.length)]);
    }
    return set;
}

// Add generated puzzles to the main array
PUZZLES.push(...generatePuzzles());

// Export puzzle utilities
window.getPuzzleById = function getPuzzleById(id) {
    return PUZZLES.find(p => p.id === id);
}

window.getPuzzlesByCategory = function getPuzzlesByCategory(category) {
    return PUZZLES.filter(p => p.category === category);
}

window.getPuzzlesByDifficulty = function getPuzzlesByDifficulty(difficulty) {
    return PUZZLES.filter(p => p.difficulty === difficulty);
}

window.getUnlockedPuzzles = function getUnlockedPuzzles(completedIds = []) {
    // First 5 puzzles are always unlocked
    // Each completed puzzle unlocks the next 2
    const baseUnlocked = 5;
    const unlockedCount = baseUnlocked + (completedIds.length * 2);
    return PUZZLES.slice(0, Math.min(unlockedCount, PUZZLES.length));
}

window.getNextPuzzle = function getNextPuzzle(currentId, completedIds = []) {
    const currentIndex = PUZZLES.findIndex(p => p.id === currentId);
    if (currentIndex === -1 || currentIndex === PUZZLES.length - 1) {
        return null;
    }
    
    const nextPuzzle = PUZZLES[currentIndex + 1];
    const unlockedPuzzles = getUnlockedPuzzles(completedIds);
    
    if (unlockedPuzzles.find(p => p.id === nextPuzzle.id)) {
        return nextPuzzle;
    }
    return null;
}

window.PUZZLE_CATEGORIES = const PUZZLE_CATEGORIES = [
    { id: 'beginner', name: 'Beginner', color: '#00ff00', icon: '🌱' },
    { id: 'intermediate', name: 'Intermediate', color: '#ffff00', icon: '⭐' },
    { id: 'advanced', name: 'Advanced', color: '#ff8800', icon: '🔥' },
    { id: 'expert', name: 'Expert', color: '#ff0000', icon: '💎' },
    { id: 'grandmaster', name: 'Grandmaster', color: '#ff00ff', icon: '👑' }
];

window.PUZZLE_OBJECTIVES = const PUZZLE_OBJECTIVES = {
    clear: { name: 'Line Clear', description: 'Clear specified number of lines' },
    tspin: { name: 'T-Spin', description: 'Perform T-Spin clears' },
    tetris: { name: 'Tetris', description: 'Clear 4 lines at once' },
    perfectclear: { name: 'Perfect Clear', description: 'Clear the entire board' },
    combo: { name: 'Combo', description: 'Achieve combo chains' },
    mixed: { name: 'Mixed', description: 'Complete multiple objectives' },
    survival: { name: 'Survival', description: 'Survive and score high' }
};

// Make PUZZLES available globally for UI
if (typeof window !== 'undefined') {
    window.PUZZLES = PUZZLES;
}
})();

/* scripts/modes/gameMode.js */
(function() {
// Abstract base class for all game modes
window.GameMode = class GameMode {
    constructor(game) {
        this.game = game;
        this.name = 'Base Mode';
        this.description = 'Base game mode';
        this.objectives = [];
        this.modeSpecificStats = {};
        this.isComplete = false;
        this.isPaused = false;
        this.startTime = null;
        this.endTime = null;
    }

    // Abstract methods that must be implemented by subclasses
    initialize() {
        throw new Error('initialize() must be implemented by subclass');
    }

    update(deltaTime) {
        throw new Error('update() must be implemented by subclass');
    }

    handleLineClears(linesCleared, specialClear) {
        throw new Error('handleLineClears() must be implemented by subclass');
    }

    getObjective() {
        throw new Error('getObjective() must be implemented by subclass');
    }

    getModeUI() {
        throw new Error('getModeUI() must be implemented by subclass');
    }

    // Common methods that can be overridden if needed
    start() {
        this.startTime = Date.now();
        this.isComplete = false;
        this.isPaused = false;
        this.initialize();
    }

    pause() {
        this.isPaused = true;
    }

    resume() {
        this.isPaused = false;
    }

    end(won = false) {
        this.endTime = Date.now();
        this.isComplete = true;
        const duration = this.endTime - this.startTime;
        return {
            mode: this.name,
            won: won,
            duration: duration,
            stats: this.getModeStats()
        };
    }

    getModeStats() {
        return {
            ...this.modeSpecificStats,
            duration: this.endTime ? this.endTime - this.startTime : Date.now() - this.startTime
        };
    }

    // Save and load state for offline support
    saveState() {
        return {
            name: this.name,
            startTime: this.startTime,
            modeSpecificStats: this.modeSpecificStats,
            isComplete: this.isComplete,
            isPaused: this.isPaused
        };
    }

    loadState(state) {
        this.startTime = state.startTime;
        this.modeSpecificStats = state.modeSpecificStats;
        this.isComplete = state.isComplete;
        this.isPaused = state.isPaused;
    }

    // Check if mode has special rules
    hasSpecialRules() {
        return false;
    }

    getSpecialRules() {
        return {};
    }

    // Handle mode-specific input
    handleInput(action) {
        // Override in subclasses if needed
        return false;
    }

    // Get current progress percentage
    getProgress() {
        return 0;
    }

    // Check if the mode should end
    shouldEnd() {
        return false;
    }

    // Get mode-specific scoring multiplier
    getScoreMultiplier() {
        return 1;
    }

    // Get mode-specific speed level
    getSpeedLevel() {
        return this.game.level;
    }

    // Check if hold piece is allowed
    isHoldAllowed() {
        return true;
    }

    // Check if ghost piece should be shown
    showGhostPiece() {
        return true;
    }

    // Get mode-specific background music tempo
    getMusicTempo() {
        return 1;
    }

    // Handle game over condition
    handleGameOver() {
        return this.end(false);
    }

    // Handle victory condition
    handleVictory() {
        return this.end(true);
    }

    // Render mode-specific UI elements
    renderModeSpecificUI(ctx, canvas) {
        // Override in subclasses to render custom UI
    }

    // Get leaderboard category for this mode
    getLeaderboardCategory() {
        return this.name.toLowerCase().replace(/\s+/g, '_');
    }

    // Check if mode supports saving mid-game
    supportsSaving() {
        return false;
    }

    // Get mode icon for UI
    getIcon() {
        return '🎮';
    }

    // Get mode color theme
    getThemeColor() {
        return 'var(--neon-blue)';
    }
}
})();

/* scripts/modes/classicMode.js */
(function() {
// Classic Tetris Mode - The original endless gameplay

window.ClassicMode = class ClassicMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Classic';
        this.description = 'The original endless Tetris experience';
        this.icon = '🎮';
        this.themeColor = 'var(--neon-blue)';
    }

    initialize() {
        // Classic mode starts at level 1
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Reset special achievements
        this.game.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        this.modeSpecificStats = {
            highestLevel: 1,
            maxCombo: 0,
            totalTSpins: 0,
            totalTetris: 0
        };
    }

    update(deltaTime) {
        // Classic mode has no special update logic
        // Game continues until game over
        return true;
    }

    handlePiecePlaced() {
        // Classic mode doesn't need special piece tracking
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines cleared
        this.game.lines += linesCleared;
        
        // Calculate score based on classic scoring
        let baseScore = 0;
        switch (linesCleared) {
            case 1:
                baseScore = 100;
                break;
            case 2:
                baseScore = 300;
                break;
            case 3:
                baseScore = 500;
                break;
            case 4:
                baseScore = 800;
                this.game.specialAchievements.tetris++;
                this.modeSpecificStats.totalTetris++;
                break;
        }
        
        // Apply level multiplier
        let score = baseScore * this.game.level;
        
        // Add combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo * this.game.level;
            this.game.specialAchievements.combos++;
        }
        
        // Add T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            score += 400 * this.game.level;
            this.game.specialAchievements.tspins++;
            this.modeSpecificStats.totalTSpins++;
        }
        
        // Add perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            score += 1000 * this.game.level;
            this.game.specialAchievements.perfectClears++;
        }
        
        this.game.score += score;
        
        // Update combo
        this.game.combo++;
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // Level progression - every 10 lines
        const newLevel = Math.floor(this.game.lines / 10) + 1;
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            if (newLevel > this.modeSpecificStats.highestLevel) {
                this.modeSpecificStats.highestLevel = newLevel;
            }
            
            // Increase game speed
            this.updateGameSpeed();
            
            // Update music tempo
            if (this.game.audioManager) {
                this.game.audioManager.setGameLevel(this.game.level);
            }
        }
    }

    updateGameSpeed() {
        // Classic speed curve
        const baseInterval = 1000;
        const speedMultiplier = Math.pow(0.9, this.game.level - 1);
        this.game.dropInterval = Math.max(50, baseInterval * speedMultiplier);
    }

    getObjective() {
        return 'Survive as long as possible!';
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: false,
            customDisplay: null
        };
    }

    getProgress() {
        // Classic mode has no completion, return level progress
        return ((this.game.lines % 10) / 10) * 100;
    }

    shouldEnd() {
        // Classic mode only ends on game over
        return false;
    }

    getScoreMultiplier() {
        // Classic mode uses standard scoring
        return 1;
    }

    getSpeedLevel() {
        return this.game.level;
    }

    isHoldAllowed() {
        return true;
    }

    showGhostPiece() {
        return true;
    }

    getMusicTempo() {
        // Tempo increases with level
        return 1 + (this.game.level - 1) * 0.02;
    }

    handleGameOver() {
        const result = super.handleGameOver();
        
        // Add final stats
        result.finalScore = this.game.score;
        result.finalLines = this.game.lines;
        result.finalLevel = this.game.level;
        result.achievements = this.game.specialAchievements;
        
        return result;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            score: this.game.score,
            lines: this.game.lines,
            level: this.game.level,
            combo: this.game.combo,
            specialAchievements: this.game.specialAchievements,
            dropInterval: this.game.dropInterval
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.score = state.score;
        this.game.lines = state.lines;
        this.game.level = state.level;
        this.game.combo = state.combo;
        this.game.specialAchievements = state.specialAchievements;
        this.game.dropInterval = state.dropInterval;
    }

    getLeaderboardCategory() {
        return 'classic';
    }

    supportsSaving() {
        return false; // Classic mode doesn't support mid-game saving
    }

    getIcon() {
        return '🎮';
    }

    getThemeColor() {
        return 'var(--neon-blue)';
    }
}
})();

/* scripts/modes/sprintMode.js */
(function() {
// Sprint Mode - Clear 40 lines as fast as possible

window.SprintMode = class SprintMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Sprint';
        this.description = 'Clear 40 lines as fast as possible!';
        this.icon = '⏱️';
        this.themeColor = '#ff00ff';
        
        this.targetLines = 40;
        this.timerInterval = null;
        this.elapsedTime = 0;
        this.bestTime = this.loadBestTime();
    }

    initialize() {
        // Sprint mode configuration
        this.game.level = 1; // Fixed level for fair competition
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Fixed speed for sprint mode
        this.game.dropInterval = 500; // Medium speed
        
        this.modeSpecificStats = {
            targetLines: this.targetLines,
            linesRemaining: this.targetLines,
            elapsedTime: 0,
            piecesUsed: 0,
            efficiency: 0,
            maxCombo: 0
        };
        
        // Start the timer
        this.startTimer();
    }

    startTimer() {
        this.elapsedTime = 0;
        this.timerInterval = setInterval(() => {
            if (!this.isPaused && !this.isComplete) {
                this.elapsedTime += 10; // Update every 10ms for precision
                this.modeSpecificStats.elapsedTime = this.elapsedTime;
            }
        }, 10);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    update(deltaTime) {
        // Check if target reached
        if (this.game.lines >= this.targetLines && !this.isComplete) {
            this.handleVictory();
            return false; // End the game
        }
        
        // Update remaining lines
        this.modeSpecificStats.linesRemaining = Math.max(0, this.targetLines - this.game.lines);
        
        // Update efficiency (lines per piece)
        if (this.modeSpecificStats.piecesUsed > 0) {
            this.modeSpecificStats.efficiency = 
                (this.game.lines / this.modeSpecificStats.piecesUsed * 100).toFixed(1);
        }
        
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines
        this.game.lines += linesCleared;
        
        // Update combo
        this.game.combo++;
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // Calculate score (minimal in sprint, focus is on time)
        let score = linesCleared * 100;
        if (specialClear && specialClear.type === 'tspin') {
            score += 200;
        }
        this.game.score += score;
        
        // Play sound effect
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('lineClear');
            
            // Special sound for getting close to goal
            if (this.game.lines >= this.targetLines - 5) {
                this.game.audioManager.playSFX('combo');
            }
        }
    }

    handlePiecePlaced() {
        this.modeSpecificStats.piecesUsed++;
    }

    getObjective() {
        const remaining = this.targetLines - this.game.lines;
        if (remaining > 0) {
            return `Clear ${remaining} more lines!`;
        }
        return 'Sprint Complete!';
    }

    getModeUI() {
        return {
            showScore: false, // Score not important in sprint
            showLines: true,
            showLevel: false, // Fixed level
            showHold: true,
            showNext: true,
            showTimer: true,
            showObjective: true,
            customDisplay: {
                timer: this.formatTime(this.elapsedTime),
                bestTime: this.bestTime ? this.formatTime(this.bestTime) : '--:--:--',
                linesRemaining: this.modeSpecificStats.linesRemaining,
                efficiency: `${this.modeSpecificStats.efficiency}%`
            }
        };
    }

    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const ms = Math.floor((milliseconds % 1000) / 10);
        
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }

    pause() {
        super.pause();
        // Timer is paused through isPaused flag
    }

    resume() {
        super.resume();
        // Timer resumes automatically
    }

    getProgress() {
        return (this.game.lines / this.targetLines) * 100;
    }

    shouldEnd() {
        return this.game.lines >= this.targetLines;
    }

    getMusicTempo() {
        // Faster tempo as approaching goal
        const progress = this.game.lines / this.targetLines;
        return 1 + progress * 0.3; // Up to 30% faster near the end
    }

    handleVictory() {
        this.stopTimer();
        const result = super.handleVictory();
        
        // Check if new record
        const isNewRecord = !this.bestTime || this.elapsedTime < this.bestTime;
        if (isNewRecord) {
            this.saveBestTime(this.elapsedTime);
        }
        
        result.time = this.elapsedTime;
        result.formattedTime = this.formatTime(this.elapsedTime);
        result.isNewRecord = isNewRecord;
        result.piecesUsed = this.modeSpecificStats.piecesUsed;
        result.efficiency = this.modeSpecificStats.efficiency;
        result.maxCombo = this.modeSpecificStats.maxCombo;
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('levelUp');
        }
        
        return result;
    }

    handleGameOver() {
        this.stopTimer();
        const result = super.handleGameOver();
        
        result.time = this.elapsedTime;
        result.formattedTime = this.formatTime(this.elapsedTime);
        result.linesCleared = this.game.lines;
        result.linesRemaining = this.targetLines - this.game.lines;
        
        return result;
    }

    loadBestTime() {
        const saved = localStorage.getItem('tetris_sprint_best_time');
        return saved ? parseInt(saved) : null;
    }

    saveBestTime(time) {
        this.bestTime = time;
        localStorage.setItem('tetris_sprint_best_time', time.toString());
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            elapsedTime: this.elapsedTime,
            piecesUsed: this.modeSpecificStats.piecesUsed
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.elapsedTime = state.elapsedTime;
        this.modeSpecificStats.piecesUsed = state.piecesUsed;
        this.modeSpecificStats.linesRemaining = this.targetLines - this.game.lines;
        
        // Restart timer from saved time
        this.startTimer();
    }

    cleanup() {
        this.stopTimer();
    }

    getLeaderboardCategory() {
        return 'sprint';
    }

    supportsSaving() {
        return false; // Sprint is a time attack, no mid-game saving
    }

    getIcon() {
        return '⏱️';
    }

    getThemeColor() {
        return '#ff00ff';
    }
}
})();

/* scripts/modes/marathonMode.js */
(function() {
// Marathon Mode - Survive 150 lines with increasing difficulty

window.MarathonMode = class MarathonMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Marathon';
        this.description = 'Survive 150 lines with increasing difficulty!';
        this.icon = '🏃';
        this.themeColor = '#ffff00';
        
        this.targetLines = 150;
        this.checkpoints = [50, 100, 150]; // Checkpoint levels
        this.lastCheckpoint = 0;
        this.savedState = null;
    }

    initialize() {
        // Marathon mode configuration
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Start with moderate speed
        this.game.dropInterval = 800;
        
        this.modeSpecificStats = {
            targetLines: this.targetLines,
            linesRemaining: this.targetLines,
            checkpointsReached: 0,
            nextCheckpoint: this.checkpoints[0],
            maxLevel: 1,
            totalScore: 0,
            maxCombo: 0,
            tspins: 0,
            tetris: 0
        };
        
        // Check for saved game
        this.loadSavedGame();
    }

    update(deltaTime) {
        // Check if target reached
        if (this.game.lines >= this.targetLines && !this.isComplete) {
            this.handleVictory();
            return false;
        }
        
        // Update remaining lines
        this.modeSpecificStats.linesRemaining = Math.max(0, this.targetLines - this.game.lines);
        
        // Check for checkpoint
        this.checkCheckpoint();
        
        // Auto-save at checkpoints
        if (this.shouldAutoSave()) {
            this.autoSave();
        }
        
        return true;
    }

    handlePiecePlaced() {
        // Marathon mode doesn't need special piece tracking
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines
        this.game.lines += linesCleared;
        
        // Calculate score with level multiplier
        let baseScore = 0;
        switch (linesCleared) {
            case 1:
                baseScore = 100;
                break;
            case 2:
                baseScore = 300;
                break;
            case 3:
                baseScore = 500;
                break;
            case 4:
                baseScore = 800;
                this.modeSpecificStats.tetris++;
                break;
        }
        
        let score = baseScore * this.game.level;
        
        // Combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo * this.game.level;
        }
        this.game.combo++;
        
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            score += 400 * this.game.level;
            this.modeSpecificStats.tspins++;
        }
        
        // Perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            score += 1000 * this.game.level;
        }
        
        this.game.score += score;
        this.modeSpecificStats.totalScore = this.game.score;
        
        // Level progression - every 10 lines
        const newLevel = Math.floor(this.game.lines / 10) + 1;
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            if (newLevel > this.modeSpecificStats.maxLevel) {
                this.modeSpecificStats.maxLevel = newLevel;
            }
            this.updateGameSpeed();
            
            // Update music tempo
            if (this.game.audioManager) {
                this.game.audioManager.setGameLevel(this.game.level);
            }
        }
    }

    updateGameSpeed() {
        // Progressive speed increase
        const baseInterval = 800;
        const speedMultiplier = Math.pow(0.92, this.game.level - 1);
        this.game.dropInterval = Math.max(50, baseInterval * speedMultiplier);
    }

    checkCheckpoint() {
        for (let i = 0; i < this.checkpoints.length; i++) {
            const checkpoint = this.checkpoints[i];
            if (this.game.lines >= checkpoint && this.lastCheckpoint < checkpoint) {
                this.lastCheckpoint = checkpoint;
                this.modeSpecificStats.checkpointsReached++;
                this.modeSpecificStats.nextCheckpoint = 
                    i < this.checkpoints.length - 1 ? this.checkpoints[i + 1] : this.targetLines;
                
                // Show checkpoint message
                if (this.game.uiManager) {
                    this.game.uiManager.showMessage(`Checkpoint ${checkpoint} lines reached!`);
                }
                
                // Play checkpoint sound
                if (this.game.audioManager) {
                    this.game.audioManager.playSFX('levelUp');
                }
                
                return true;
            }
        }
        return false;
    }

    shouldAutoSave() {
        // Auto-save every 10 lines
        return this.game.lines > 0 && this.game.lines % 10 === 0;
    }

    autoSave() {
        this.savedState = this.saveState();
        localStorage.setItem('tetris_marathon_saved', JSON.stringify(this.savedState));
    }

    loadSavedGame() {
        const saved = localStorage.getItem('tetris_marathon_saved');
        if (saved) {
            try {
                const state = JSON.parse(saved);
                // Ask user if they want to continue
                if (this.game.uiManager) {
                    this.game.uiManager.showContinuePrompt(state, (continueGame) => {
                        if (continueGame) {
                            this.loadState(state);
                        } else {
                            localStorage.removeItem('tetris_marathon_saved');
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load saved game:', e);
            }
        }
    }

    getObjective() {
        const checkpoint = this.modeSpecificStats.nextCheckpoint;
        const linesToCheckpoint = checkpoint - this.game.lines;
        
        if (this.game.lines >= this.targetLines) {
            return 'Marathon Complete!';
        } else if (linesToCheckpoint > 0) {
            return `${linesToCheckpoint} lines to checkpoint ${checkpoint}`;
        }
        return `Clear ${this.modeSpecificStats.linesRemaining} more lines!`;
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: true,
            customDisplay: {
                checkpoint: `${this.lastCheckpoint}/${this.targetLines}`,
                progress: `${Math.floor(this.getProgress())}%`
            }
        };
    }

    getProgress() {
        return (this.game.lines / this.targetLines) * 100;
    }

    shouldEnd() {
        return this.game.lines >= this.targetLines;
    }

    getMusicTempo() {
        // Tempo increases with level
        return 1 + (this.game.level - 1) * 0.03;
    }

    handleVictory() {
        const result = super.handleVictory();
        
        result.finalScore = this.game.score;
        result.finalLevel = this.game.level;
        result.checkpointsReached = this.modeSpecificStats.checkpointsReached;
        result.maxCombo = this.modeSpecificStats.maxCombo;
        result.tspins = this.modeSpecificStats.tspins;
        result.tetris = this.modeSpecificStats.tetris;
        
        // Clear saved game
        localStorage.removeItem('tetris_marathon_saved');
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('victory');
        }
        
        return result;
    }

    handleGameOver() {
        const result = super.handleGameOver();
        
        result.linesCleared = this.game.lines;
        result.linesRemaining = this.targetLines - this.game.lines;
        result.checkpointsReached = this.modeSpecificStats.checkpointsReached;
        result.finalScore = this.game.score;
        result.finalLevel = this.game.level;
        
        // Clear saved game
        localStorage.removeItem('tetris_marathon_saved');
        
        return result;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            score: this.game.score,
            level: this.game.level,
            combo: this.game.combo,
            lastCheckpoint: this.lastCheckpoint,
            dropInterval: this.game.dropInterval,
            grid: this.game.grid ? this.game.grid.saveState() : null,
            currentPiece: this.game.currentPiece ? this.game.currentPiece.saveState() : null,
            heldPiece: this.game.heldPiece ? this.game.heldPiece.saveState() : null,
            nextPieces: this.game.nextPieces
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.game.score = state.score;
        this.game.level = state.level;
        this.game.combo = state.combo;
        this.lastCheckpoint = state.lastCheckpoint;
        this.game.dropInterval = state.dropInterval;
        
        // Restore grid state
        if (state.grid && this.game.grid) {
            this.game.grid.loadState(state.grid);
        }
        
        // Restore pieces
        if (state.currentPiece && this.game.currentPiece) {
            this.game.currentPiece.loadState(state.currentPiece);
        }
        if (state.heldPiece && this.game.heldPiece) {
            this.game.heldPiece.loadState(state.heldPiece);
        }
        if (state.nextPieces) {
            this.game.nextPieces = state.nextPieces;
        }
        
        // Update stats
        this.modeSpecificStats.linesRemaining = this.targetLines - this.game.lines;
        for (let i = 0; i < this.checkpoints.length; i++) {
            if (this.checkpoints[i] > this.game.lines) {
                this.modeSpecificStats.nextCheckpoint = this.checkpoints[i];
                break;
            }
        }
    }

    pause() {
        super.pause();
        // Auto-save when pausing
        this.autoSave();
    }

    getLeaderboardCategory() {
        return 'marathon';
    }

    supportsSaving() {
        return true; // Marathon supports mid-game saving
    }

    getIcon() {
        return '🏃';
    }

    getThemeColor() {
        return '#ffff00';
    }
}
})();

/* scripts/modes/zenMode.js */
(function() {
// Zen Mode - Relaxing endless mode with no pressure

window.ZenMode = class ZenMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Zen';
        this.description = 'Relax and play without pressure. No game over!';
        this.icon = '🧘';
        this.themeColor = '#00ff00';
        
        // Zen mode settings
        this.customSpeed = this.loadCustomSpeed();
        this.autoSaveInterval = 30000; // Auto-save every 30 seconds
        this.lastAutoSave = Date.now();
        this.sessionStats = null;
        this.savedGames = [];
    }

    initialize() {
        // Zen mode configuration
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Use custom speed or default
        this.game.dropInterval = this.customSpeed || 1000;
        
        this.modeSpecificStats = {
            sessionTime: 0,
            totalPieces: 0,
            totalLines: 0,
            totalScore: 0,
            averageLinesPerMinute: 0,
            maxCombo: 0,
            tspins: 0,
            tetris: 0,
            perfectClears: 0,
            efficiency: 0,
            bestStreak: 0,
            currentStreak: 0
        };
        
        // Initialize session tracking
        this.sessionStats = {
            startTime: Date.now(),
            pieces: [],
            lineClears: [],
            scores: []
        };
        
        // Load any saved game
        this.checkForSavedGames();
    }

    update(deltaTime) {
        // Update session time
        this.modeSpecificStats.sessionTime = Date.now() - this.sessionStats.startTime;
        
        // Calculate statistics
        this.updateStatistics();
        
        // Auto-save periodically
        if (Date.now() - this.lastAutoSave > this.autoSaveInterval) {
            this.autoSave();
            this.lastAutoSave = Date.now();
        }
        
        // Zen mode never ends
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) {
            // Break streak
            if (this.modeSpecificStats.currentStreak > this.modeSpecificStats.bestStreak) {
                this.modeSpecificStats.bestStreak = this.modeSpecificStats.currentStreak;
            }
            this.modeSpecificStats.currentStreak = 0;
            return;
        }
        
        // Update lines
        this.game.lines += linesCleared;
        this.modeSpecificStats.totalLines = this.game.lines;
        
        // Track line clears
        this.sessionStats.lineClears.push({
            lines: linesCleared,
            time: Date.now() - this.sessionStats.startTime,
            special: specialClear
        });
        
        // Update streak
        this.modeSpecificStats.currentStreak++;
        
        // Calculate score (relaxed scoring)
        let score = linesCleared * 100;
        
        // Special clear bonuses
        if (specialClear) {
            if (specialClear.type === 'tspin') {
                score += 200;
                this.modeSpecificStats.tspins++;
            } else if (specialClear.type === 'perfectClear') {
                score += 500;
                this.modeSpecificStats.perfectClears++;
            }
        }
        
        // Tetris bonus
        if (linesCleared === 4) {
            score += 300;
            this.modeSpecificStats.tetris++;
        }
        
        // Combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo;
        }
        this.game.combo++;
        
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        this.game.score += score;
        this.modeSpecificStats.totalScore = this.game.score;
        
        // Track score
        this.sessionStats.scores.push({
            score: score,
            total: this.game.score,
            time: Date.now() - this.sessionStats.startTime
        });
        
        // Gentle level progression (optional)
        const newLevel = Math.floor(this.game.lines / 20) + 1; // Slower progression
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            // Don't change speed in Zen mode unless user wants
            if (!this.customSpeed) {
                this.updateGameSpeed();
            }
        }
    }

    handlePiecePlaced() {
        this.modeSpecificStats.totalPieces++;
        this.sessionStats.pieces.push(Date.now() - this.sessionStats.startTime);
    }

    updateGameSpeed() {
        // Very gentle speed increase in Zen mode
        const baseInterval = 1000;
        const speedMultiplier = Math.pow(0.98, this.game.level - 1);
        this.game.dropInterval = Math.max(200, baseInterval * speedMultiplier);
    }

    updateStatistics() {
        // Calculate lines per minute
        const minutesPlayed = this.modeSpecificStats.sessionTime / 60000;
        if (minutesPlayed > 0) {
            this.modeSpecificStats.averageLinesPerMinute = 
                (this.game.lines / minutesPlayed).toFixed(1);
        }
        
        // Calculate efficiency
        if (this.modeSpecificStats.totalPieces > 0) {
            this.modeSpecificStats.efficiency = 
                (this.game.lines / this.modeSpecificStats.totalPieces * 100).toFixed(1);
        }
    }

    // Special Zen mode features
    clearGrid() {
        // Allow clearing the grid in Zen mode
        if (this.game.grid) {
            this.game.grid.reset();
        }
    }

    setCustomSpeed(speed) {
        this.customSpeed = speed;
        this.game.dropInterval = speed;
        localStorage.setItem('tetris_zen_speed', speed.toString());
    }

    loadCustomSpeed() {
        const saved = localStorage.getItem('tetris_zen_speed');
        return saved ? parseInt(saved) : null;
    }

    exportStatistics() {
        // Export session statistics as JSON
        const exportData = {
            mode: 'zen',
            date: new Date().toISOString(),
            sessionTime: this.modeSpecificStats.sessionTime,
            stats: this.modeSpecificStats,
            sessionDetails: this.sessionStats
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], 
            { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `tetris_zen_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    autoSave() {
        const saveData = this.saveState();
        const saveId = `zen_${Date.now()}`;
        
        // Keep only last 5 saves
        this.savedGames.push({ id: saveId, data: saveData, time: Date.now() });
        if (this.savedGames.length > 5) {
            this.savedGames.shift();
        }
        
        localStorage.setItem('tetris_zen_saves', JSON.stringify(this.savedGames));
        
        // Show save indicator
        if (this.game.uiManager) {
            this.game.uiManager.showMessage('Game saved', 'success', 1000);
        }
    }

    checkForSavedGames() {
        const saved = localStorage.getItem('tetris_zen_saves');
        if (saved) {
            try {
                this.savedGames = JSON.parse(saved);
                if (this.savedGames.length > 0 && this.game.uiManager) {
                    // Show load game prompt
                    this.game.uiManager.showLoadGamePrompt(this.savedGames, (saveId) => {
                        const save = this.savedGames.find(s => s.id === saveId);
                        if (save) {
                            this.loadState(save.data);
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load saved games:', e);
            }
        }
    }

    getObjective() {
        return 'Relax and enjoy! No pressure.';
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: false,
            customDisplay: {
                time: this.formatTime(this.modeSpecificStats.sessionTime),
                lpm: `${this.modeSpecificStats.averageLinesPerMinute} LPM`,
                efficiency: `${this.modeSpecificStats.efficiency}%`,
                pieces: this.modeSpecificStats.totalPieces,
                streak: this.modeSpecificStats.currentStreak
            }
        };
    }

    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    getProgress() {
        // Zen mode has no completion
        return 0;
    }

    shouldEnd() {
        // Zen mode never ends
        return false;
    }

    getMusicTempo() {
        // Calm, consistent tempo for Zen mode
        return 0.8; // Slower than normal
    }

    handleGameOver() {
        // In Zen mode, there's no real game over
        // Just clear the grid and continue
        this.clearGrid();
        
        // Reset combo
        this.game.combo = 0;
        
        // Show message
        if (this.game.uiManager) {
            this.game.uiManager.showMessage('Grid cleared! Keep playing.', 'info', 2000);
        }
        
        // Don't actually end the game
        return null;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            score: this.game.score,
            level: this.game.level,
            customSpeed: this.customSpeed,
            sessionStats: this.sessionStats,
            grid: this.game.grid ? this.game.grid.saveState() : null,
            currentPiece: this.game.currentPiece ? this.game.currentPiece.saveState() : null,
            heldPiece: this.game.heldPiece ? this.game.heldPiece.saveState() : null,
            nextPieces: this.game.nextPieces
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.game.score = state.score;
        this.game.level = state.level;
        this.customSpeed = state.customSpeed;
        this.sessionStats = state.sessionStats;
        
        // Restore grid and pieces
        if (state.grid && this.game.grid) {
            this.game.grid.loadState(state.grid);
        }
        if (state.currentPiece && this.game.currentPiece) {
            this.game.currentPiece.loadState(state.currentPiece);
        }
        if (state.heldPiece && this.game.heldPiece) {
            this.game.heldPiece.loadState(state.heldPiece);
        }
        if (state.nextPieces) {
            this.game.nextPieces = state.nextPieces;
        }
        
        // Restore custom speed
        if (this.customSpeed) {
            this.game.dropInterval = this.customSpeed;
        }
    }

    handleInput(action) {
        // Special Zen mode inputs
        if (action === 'clearGrid') {
            this.clearGrid();
            return true;
        } else if (action === 'exportStats') {
            this.exportStatistics();
            return true;
        } else if (action === 'quickSave') {
            this.autoSave();
            return true;
        }
        return false;
    }

    getLeaderboardCategory() {
        return 'zen';
    }

    supportsSaving() {
        return true; // Zen mode fully supports saving
    }

    getIcon() {
        return '🧘';
    }

    getThemeColor() {
        return '#00ff00';
    }
}
})();

/* scripts/modes/puzzleMode.js */
(function() {
// Puzzle Mode - Solve 150 unique challenges




window.PuzzleMode = class PuzzleMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Puzzle';
        this.description = 'Solve 150 unique Tetris challenges!';
        this.icon = '🧩';
        this.themeColor = '#ff8800';
        
        this.currentPuzzle = null;
        this.puzzleId = 1;
        this.completedPuzzles = [];
        this.puzzleStats = {};
        // Load async data after initialization
        this.loadCompletedPuzzles().then(data => {
            this.completedPuzzles = data;
        });
        this.availablePieces = [];
        this.usedPieces = 0;
        this.timeElapsed = 0;
        this.timerInterval = null;
        this.pendingCompletion = false;
    }

    async initialize() {
        // Wait for completed puzzles to load
        this.completedPuzzles = await this.loadCompletedPuzzles();
        
        // Try to load saved progress first
        const progress = await this.loadCurrentProgress();
        if (progress && progress.currentPuzzleId) {
            this.puzzleId = progress.currentPuzzleId;
        } else {
            // Load first puzzle or continue from last
            this.puzzleId = this.getLastUncompletedPuzzle();
        }
        this.loadPuzzle(this.puzzleId);
        await this.saveCurrentProgress(); // Save current puzzle being played
    }

    loadPuzzle(puzzleId) {
        let puzzle = getPuzzleById(puzzleId);
        if (!puzzle) {
            console.error(`Puzzle ${puzzleId} not found`);
            return;
        }
        
        // Validate and auto-fix puzzle before loading
        puzzle = this.validateAndFixPuzzle(puzzle);
        this.currentPuzzle = puzzle;
        
        // Reset game state
        this.game.lines = 0;
        this.game.score = 0;
        this.game.level = 1;
        this.game.combo = 0;
        
        // Load puzzle grid
        if (this.game.grid && this.currentPuzzle.initialGrid) {
            this.game.grid.loadFromArray(this.currentPuzzle.initialGrid);
        }
        
        // Set available pieces
        if (this.currentPuzzle.pieces === 'random') {
            this.availablePieces = [];
        } else {
            this.availablePieces = [...this.currentPuzzle.pieces];
        }
        
        // Initialize puzzle stats
        this.puzzleStats = {
            puzzleId: puzzleId,
            objective: this.currentPuzzle.objective,
            targetLines: this.currentPuzzle.targetLines || 0,
            targetTSpins: this.currentPuzzle.targetTSpins || 0,
            targetTetris: this.currentPuzzle.targetTetris || 0,
            targetCombo: this.currentPuzzle.targetCombo || 0,
            minScore: this.currentPuzzle.minScore || 0,
            linesCleared: 0,
            tspinsPerformed: 0,
            tetrisPerformed: 0,
            maxCombo: 0,
            piecesUsed: 0,
            timeElapsed: 0
        };
        
        this.usedPieces = 0;
        this.timeElapsed = 0;
        this.pendingCompletion = false;
        this.isComplete = false;
        
        // Start timer if puzzle has time limit
        if (this.currentPuzzle.timeLimit > 0) {
            this.startTimer();
        }
        
        // Show puzzle info with validation status
        if (this.game.uiManager) {
            const validationMsg = this.currentPuzzle._wasFixed ? ' (Auto-adjusted)' : '';
            this.game.uiManager.showMessage(
                `Puzzle ${puzzleId}: ${this.currentPuzzle.name}${validationMsg}`,
                'info',
                3000
            );
        }
    }

    startTimer() {
        this.timeElapsed = 0;
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }
        
        this.timerInterval = setInterval(() => {
            if (!this.isPaused && !this.isComplete) {
                this.timeElapsed++;
                this.puzzleStats.timeElapsed = this.timeElapsed;
                
                // Check time limit
                if (this.currentPuzzle.timeLimit > 0 && 
                    this.timeElapsed >= this.currentPuzzle.timeLimit) {
                    this.handlePuzzleFailed('Time limit exceeded');
                }
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    update(deltaTime) {
        // If puzzle is already complete, don't process further
        if (this.isComplete) {
            return false;
        }
        
        if (!this.currentPuzzle) return false;
        
        // Handle pending completion from line clear
        if (this.pendingCompletion) {
            this.pendingCompletion = false;
            this.handlePuzzleComplete();
            return false;
        }
        
        // Check objective completion
        if (this.checkObjectiveComplete()) {
            this.handlePuzzleComplete();
            return false;
        }
        
        // Don't check failure conditions if objective is met
        if (!this.checkObjectiveComplete() && this.checkFailureConditions()) {
            this.handlePuzzleFailed('Objective failed');
            return false;
        }
        
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        // Don't process if puzzle is already complete
        if (this.isComplete) return;
        
        if (!linesCleared || linesCleared === 0) {
            // Reset combo
            if (this.game.combo > this.puzzleStats.maxCombo) {
                this.puzzleStats.maxCombo = this.game.combo;
            }
            this.game.combo = 0;
            return;
        }
        
        // Update stats BEFORE checking completion
        this.puzzleStats.linesCleared += linesCleared;
        this.game.lines += linesCleared;
        this.game.combo++;
        
        if (this.game.combo > this.puzzleStats.maxCombo) {
            this.puzzleStats.maxCombo = this.game.combo;
        }
        
        // Check for special clears
        if (specialClear) {
            if (specialClear.type === 'tspin') {
                this.puzzleStats.tspinsPerformed++;
            }
        }
        
        if (linesCleared === 4) {
            this.puzzleStats.tetrisPerformed++;
        }
        
        // Calculate score
        let score = linesCleared * 100;
        if (specialClear && specialClear.type === 'tspin') {
            score += 400;
        }
        if (linesCleared === 4) {
            score += 400;
        }
        this.game.score += score;
        
        // Check if objective is completed IMMEDIATELY
        if (this.checkObjectiveComplete()) {
            // Mark as complete immediately to prevent game over
            this.isComplete = true;
            this.pendingCompletion = true;
            
            // Call handlePuzzleComplete directly with a small delay
            setTimeout(() => {
                this.handlePuzzleComplete();
            }, 100);
        }
    }

    handlePiecePlaced() {
        // Don't process if puzzle is already complete
        if (this.isComplete) return;
        
        this.usedPieces++;
        this.puzzleStats.piecesUsed = this.usedPieces;
        
        // Check piece limit only if objective is not complete
        if (this.currentPuzzle.maxPieces > 0 && 
            this.usedPieces >= this.currentPuzzle.maxPieces) {
            // Give time for line clears to process
            setTimeout(() => {
                if (!this.isComplete && !this.checkObjectiveComplete()) {
                    this.handlePuzzleFailed('Piece limit exceeded');
                }
            }, 100);
        }
    }

    checkObjectiveComplete() {
        const stats = this.puzzleStats;
        const puzzle = this.currentPuzzle;
        
        switch (puzzle.objective) {
            case 'clear':
                return stats.linesCleared >= (puzzle.targetLines || 1);
                
            case 'tspin':
                return stats.tspinsPerformed >= (puzzle.targetTSpins || 1);
                
            case 'tetris':
                return stats.tetrisPerformed >= (puzzle.targetTetris || 1);
                
            case 'perfectclear':
                return this.game.grid && this.game.grid.isEmpty();
                
            case 'combo':
                return stats.maxCombo >= (puzzle.targetCombo || 3);
                
            case 'mixed':
                return (
                    stats.linesCleared >= (puzzle.targetLines || 0) &&
                    stats.tspinsPerformed >= (puzzle.targetTSpins || 0) &&
                    stats.maxCombo >= (puzzle.targetCombo || 0)
                );
                
            case 'survival':
                return (
                    stats.linesCleared >= (puzzle.targetLines || 0) &&
                    this.game.score >= (puzzle.minScore || 0)
                );
                
            default:
                return false;
        }
    }

    checkFailureConditions() {
        // Check if pieces exhausted without completing objective
        if (this.currentPuzzle.maxPieces > 0 && 
            this.usedPieces >= this.currentPuzzle.maxPieces) {
            return !this.checkObjectiveComplete();
        }
        
        // Check if specific pieces are exhausted
        if (this.availablePieces.length > 0 && 
            this.usedPieces >= this.availablePieces.length) {
            return !this.checkObjectiveComplete();
        }
        
        return false;
    }

    handlePuzzleComplete() {
        // Prevent multiple calls
        if (this.isComplete && this.game.state === 'victory') {
            return;
        }
        
        this.stopTimer();
        this.isComplete = true;
        
        // Calculate stars (1-3 based on performance)
        const stars = this.calculateStars();
        
        // Save completion
        this.savePuzzleCompletion(this.puzzleId, stars);
        
        // Show completion message
        if (this.game.uiManager) {
            this.game.uiManager.showPuzzleComplete(
                this.currentPuzzle,
                stars,
                this.puzzleStats
            );
            
            // Show success message
            this.game.uiManager.showMessage(
                `✨ Puzzle Complete! ${'\u2b50'.repeat(stars)}`,
                'success',
                3000
            );
        }
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('victory');
        }
        
        // Store results but don't end game immediately
        if (this.game) {
            // Store puzzle results for the game over screen
            this.game.puzzleResults = {
                puzzleId: this.puzzleId,
                puzzleName: this.currentPuzzle.name,
                stars: stars,
                stats: this.puzzleStats,
                nextPuzzle: getNextPuzzle(this.puzzleId, this.completedPuzzles),
                isVictory: true
            };
            
            // Set game state to prevent further input
            this.game.state = 'victory';
            
            // The UI will handle the next action (next puzzle or retry)
            // Don't call gameOver here
        }
        
        return {
            puzzleId: this.puzzleId,
            puzzleName: this.currentPuzzle.name,
            stars: stars,
            stats: this.puzzleStats,
            nextPuzzle: getNextPuzzle(this.puzzleId, this.completedPuzzles)
        };
    }

    handlePuzzleFailed(reason) {
        this.stopTimer();
        this.isComplete = true;
        
        // Show failure message
        if (this.game.uiManager) {
            this.game.uiManager.showPuzzleFailed(
                this.currentPuzzle,
                reason,
                this.puzzleStats
            );
        }
        
        // End the game with failure
        if (this.game) {
            // Store puzzle results for the game over screen
            this.game.puzzleResults = {
                puzzleId: this.puzzleId,
                puzzleName: this.currentPuzzle.name,
                failed: true,
                reason: reason,
                stats: this.puzzleStats
            };
            this.game.gameOver();
        }
        
        return {
            puzzleId: this.puzzleId,
            puzzleName: this.currentPuzzle.name,
            failed: true,
            reason: reason,
            stats: this.puzzleStats
        };
    }

    calculateStars() {
        let stars = 1; // Base star for completion
        
        // Efficiency bonus
        if (this.currentPuzzle.maxPieces > 0) {
            const efficiency = this.usedPieces / this.currentPuzzle.maxPieces;
            if (efficiency <= 0.5) stars++;
        }
        
        // Time bonus
        if (this.currentPuzzle.timeLimit > 0) {
            const timeRatio = this.timeElapsed / this.currentPuzzle.timeLimit;
            if (timeRatio <= 0.5) stars++;
        }
        
        // Perfect clear bonus
        if (this.currentPuzzle.objective === 'perfectclear' && 
            this.game.grid && this.game.grid.isEmpty()) {
            stars = 3;
        }
        
        return Math.min(3, stars);
    }

    getNextPiece() {
        if (this.currentPuzzle.pieces === 'random') {
            // Random pieces
            return null; // Let game generate random piece
        } else if (this.availablePieces.length > 0) {
            // Specific piece sequence
            if (this.usedPieces < this.availablePieces.length) {
                return this.availablePieces[this.usedPieces];
            }
            // After using all specified pieces, generate random ones
            return null; // Let game generate random piece
        }
        return null;
    }

    async loadCompletedPuzzles() {
        const saved = await storage.load('puzzle_completed');
        if (saved) {
            return saved;
        }
        // Try legacy localStorage fallback
        const legacySaved = localStorage.getItem('tetris_puzzle_completed');
        if (legacySaved) {
            try {
                const data = JSON.parse(legacySaved);
                // Migrate to new storage
                await storage.save('puzzle_completed', data);
                return data;
            } catch (e) {
                console.error('Failed to load completed puzzles:', e);
            }
        }
        return [];
    }

    savePuzzleCompletion(puzzleId, stars) {
        const completion = {
            puzzleId: puzzleId,
            stars: stars,
            timestamp: Date.now()
        };
        
        // Update completed list
        const existing = this.completedPuzzles.findIndex(p => p.puzzleId === puzzleId);
        if (existing >= 0) {
            // Update if better stars
            if (stars > this.completedPuzzles[existing].stars) {
                this.completedPuzzles[existing] = completion;
            }
        } else {
            this.completedPuzzles.push(completion);
        }
        
        storage.save('puzzle_completed', this.completedPuzzles);
        
        // Also save current progress
        this.saveCurrentProgress();
    }
    
    async saveCurrentProgress() {
        const progress = {
            currentPuzzleId: this.puzzleId,
            highestUnlocked: Math.max(...this.completedPuzzles.map(p => p.puzzleId), this.puzzleId),
            lastPlayed: Date.now()
        };
        await storage.save('puzzle_progress', progress);
    }
    
    async loadCurrentProgress() {
        const saved = await storage.load('puzzle_progress');
        if (saved) {
            return saved;
        }
        // Try legacy localStorage fallback
        const legacySaved = localStorage.getItem('tetris_puzzle_progress');
        if (legacySaved) {
            try {
                const data = JSON.parse(legacySaved);
                // Migrate to new storage
                await storage.save('puzzle_progress', data);
                return data;
            } catch (e) {
                console.error('Failed to load puzzle progress:', e);
            }
        }
        return null;
    }

    getLastUncompletedPuzzle() {
        const unlocked = getUnlockedPuzzles(this.completedPuzzles.map(p => p.puzzleId));
        for (let puzzle of unlocked) {
            if (!this.completedPuzzles.find(p => p.puzzleId === puzzle.id)) {
                return puzzle.id;
            }
        }
        return 1; // Default to first puzzle
    }

    selectPuzzle(puzzleId) {
        const unlocked = getUnlockedPuzzles(this.completedPuzzles.map(p => p.puzzleId));
        if (unlocked.find(p => p.id === puzzleId)) {
            this.loadPuzzle(puzzleId);
            return true;
        }
        return false;
    }

    getObjective() {
        if (!this.currentPuzzle) return 'Select a puzzle';
        
        // Return the current objective with progress
        return this.getObjectiveProgress();
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: false,
            showHold: true,
            showNext: true,
            showTimer: this.currentPuzzle && this.currentPuzzle.timeLimit > 0,
            showObjective: true,
            customDisplay: this.currentPuzzle ? {
                puzzle: `#${this.currentPuzzle.id}: ${this.currentPuzzle.name}`,
                pieces: this.currentPuzzle.maxPieces > 0 && this.currentPuzzle.maxPieces < 999 ? 
                    `Pieces: ${this.usedPieces}/${this.currentPuzzle.maxPieces}` : 
                    `Pieces: ${this.usedPieces}`,
                objective: this.getObjectiveProgress(),
                hint: this.currentPuzzle.hint || null
            } : {}
        };
    }

    getObjectiveProgress() {
        if (!this.currentPuzzle) return '';
        
        switch (this.currentPuzzle.objective) {
            case 'lines':
            case 'clearLines':
            case 'clear':
                const targetLines = this.currentPuzzle.targetLines || 1;
                return `🎯 Clear: ${this.puzzleStats.linesCleared}/${targetLines} line${targetLines > 1 ? 's' : ''}`;
            
            case 'clearAll':
            case 'clearBoard':
                const totalBlocks = this.countRemainingBlocks();
                return `🧹 Clear all blocks (${totalBlocks} left)`;
            
            case 'score':
            case 'minScore':
                const targetScore = this.currentPuzzle.minScore || 1000;
                return `💯 Score: ${this.game.score}/${targetScore}`;
            
            case 'tspin':
                const targetTSpins = this.currentPuzzle.targetTSpins || 1;
                return `🌀 T-Spins: ${this.puzzleStats.tspinsPerformed}/${targetTSpins}`;
            
            case 'tetris':
                const targetTetris = this.currentPuzzle.targetTetris || 1;
                return `⚡ Tetris: ${this.puzzleStats.tetrisPerformed}/${targetTetris}`;
            
            case 'combo':
                const targetCombo = this.currentPuzzle.targetCombo || 5;
                return `🔥 Combo: ${this.puzzleStats.maxCombo}/${targetCombo}`;
            
            case 'perfect':
                return `✨ Perfect Clear required`;
            
            case 'survive':
                const timeLimit = this.currentPuzzle.timeLimit || 60;
                const elapsed = Math.floor(this.timeElapsed / 1000);
                return `⏱️ Time: ${elapsed}/${timeLimit}s`;
            
            default:
                return this.currentPuzzle.description || 'Complete objective';
        }
    }
    
    countRemainingBlocks() {
        if (!this.game.grid || !this.game.grid.cells) return 0;
        let count = 0;
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (this.game.grid.cells[row][col] !== 0) {
                    count++;
                }
            }
        }
        return count;
    }

    pause() {
        super.pause();
    }

    resume() {
        super.resume();
    }

    cleanup() {
        this.stopTimer();
    }
    
    validateAndFixPuzzle(puzzle) {
        // Convert puzzle to validator format
        const puzzleConfig = {
            name: puzzle.name,
            grid: puzzle.initialGrid || Array(20).fill(null).map(() => Array(10).fill(0)),
            pieces: puzzle.pieces === 'random' ? ['I', 'O', 'T', 'S', 'Z', 'J', 'L'] : puzzle.pieces,
            maxPieces: puzzle.maxPieces || 999,
            objective: this.convertObjective(puzzle),
            hint: puzzle.hint
        };
        
        // Validate the puzzle
        const validation = puzzleValidator.validatePuzzle(puzzleConfig);
        
        if (!validation.valid) {
            console.warn(`Puzzle ${puzzle.id} "${puzzle.name}" has issues:`, validation.issues);
            
            // Auto-fix the puzzle
            const fixed = this.autoFixPuzzle(puzzle, validation);
            fixed._wasFixed = true;
            fixed._validationIssues = validation.issues;
            
            console.log(`Auto-fixed puzzle ${puzzle.id}:`, validation.suggestions);
            return fixed;
        }
        
        return puzzle;
    }
    
    convertObjective(puzzle) {
        const objective = { type: puzzle.objective };
        
        switch (puzzle.objective) {
            case 'lines':
            case 'clearLines':
                objective.type = 'lines';
                objective.count = puzzle.targetLines || 1;
                break;
            case 'score':
            case 'minScore':
                objective.type = 'score';
                objective.target = puzzle.minScore || 1000;
                break;
            case 'clearAll':
            case 'clearBoard':
                objective.type = 'clear';
                break;
            case 'tspin':
                objective.type = 'lines';
                objective.count = puzzle.targetTSpins || 1;
                break;
            case 'tetris':
                objective.type = 'lines';
                objective.count = (puzzle.targetTetris || 1) * 4;
                break;
            case 'combo':
                objective.type = 'lines';
                objective.count = puzzle.targetCombo || 3;
                break;
            default:
                objective.type = 'lines';
                objective.count = 1;
        }
        
        return objective;
    }
    
    autoFixPuzzle(puzzle, validation) {
        const fixed = { ...puzzle };
        
        // Fix piece count if needed
        if (validation.minPiecesRequired > 0) {
            if (!fixed.pieces || fixed.pieces === 'random') {
                fixed.pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            }
            
            // Ensure we have enough pieces
            while (fixed.pieces.length < validation.minPiecesRequired) {
                const allPieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
                const randomPiece = allPieces[Math.floor(Math.random() * allPieces.length)];
                fixed.pieces.push(randomPiece);
            }
            
            // Adjust maxPieces if too restrictive
            if (fixed.maxPieces < validation.minPiecesRequired + 2) {
                fixed.maxPieces = validation.minPiecesRequired + 5;
            }
        }
        
        // Fix objectives that are impossible
        if (validation.issues.some(issue => issue.includes('Objective requires'))) {
            switch (puzzle.objective) {
                case 'lines':
                case 'clearLines':
                    // Reduce line requirement
                    fixed.targetLines = Math.max(1, Math.floor((fixed.targetLines || 1) * 0.75));
                    break;
                case 'score':
                case 'minScore':
                    // Reduce score requirement
                    fixed.minScore = Math.max(100, Math.floor((fixed.minScore || 1000) * 0.5));
                    break;
                case 'tetris':
                    // Reduce tetris requirement or add I pieces
                    if (!fixed.pieces.includes('I')) {
                        fixed.pieces.push('I', 'I', 'I', 'I');
                    }
                    fixed.targetTetris = Math.max(1, Math.floor((fixed.targetTetris || 1) * 0.75));
                    break;
                case 'tspin':
                    // Add T pieces for T-spins
                    if (!fixed.pieces.includes('T')) {
                        fixed.pieces.push('T', 'T', 'T');
                    }
                    fixed.targetTSpins = Math.max(1, Math.floor((fixed.targetTSpins || 1) * 0.75));
                    break;
            }
        }
        
        // Fix grid issues (holes, impossible clears)
        if (validation.issues.some(issue => issue.includes('grid'))) {
            // Simplify the grid if it's too complex
            if (fixed.initialGrid) {
                fixed.initialGrid = this.simplifyGrid(fixed.initialGrid);
            }
        }
        
        return fixed;
    }
    
    simplifyGrid(grid) {
        const simplified = grid.map(row => [...row]);
        
        // Remove isolated blocks that create impossible situations
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (simplified[row][col] !== 0) {
                    // Check if this block is isolated (no neighbors)
                    let hasNeighbor = false;
                    
                    // Check adjacent cells
                    const neighbors = [
                        [row - 1, col], [row + 1, col],
                        [row, col - 1], [row, col + 1]
                    ];
                    
                    for (const [r, c] of neighbors) {
                        if (r >= 0 && r < 20 && c >= 0 && c < 10 && simplified[r][c] !== 0) {
                            hasNeighbor = true;
                            break;
                        }
                    }
                    
                    // Remove isolated blocks in upper rows (they're problematic)
                    if (!hasNeighbor && row < 10) {
                        simplified[row][col] = 0;
                    }
                }
            }
        }
        
        return simplified;
    }

    getLeaderboardCategory() {
        return 'puzzle';
    }

    supportsSaving() {
        return false; // Puzzles are quick challenges
    }

    getIcon() {
        return '🧩';
    }

    getThemeColor() {
        return '#ff8800';
    }
}
})();

/* scripts/modes/battleMode.js */
(function() {
// Battle Mode - Face off against intelligent AI opponents



window.BattleMode = class BattleMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Battle';
        this.description = 'Face off against intelligent AI opponents!';
        this.icon = '⚔️';
        this.themeColor = '#ff0000';
        
        // Battle settings
        this.aiDifficulty = 3; // Default to Hard
        this.roundsToWin = 2; // Best of 3
        this.currentRound = 1;
        this.playerWins = 0;
        this.aiWins = 0;
        
        // AI opponent
        this.ai = null;
        this.aiGrid = null;
        
        // Garbage lines system
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        
        // Power-ups
        this.powerUps = {
            freeze: { duration: 3000, cooldown: 20000 },
            bomb: { lines: 3, cooldown: 30000 },
            shield: { duration: 5000, cooldown: 25000 },
            speed: { multiplier: 2, duration: 5000, cooldown: 15000 }
        };
        this.activePowerUps = [];
        this.powerUpCooldowns = {};
        
        // Battle stats
        this.battleStats = {
            roundsPlayed: 0,
            totalDamageDealt: 0,
            totalDamageReceived: 0,
            powerUpsUsed: 0,
            maxCombo: 0
        };
    }

    initialize() {
        // Get selected difficulty from localStorage
        const savedDifficulty = localStorage.getItem('battle_ai_difficulty');
        if (savedDifficulty) {
            this.aiDifficulty = parseInt(savedDifficulty);
        }
        
        // Initialize AI opponent with selected difficulty
        this.ai = new TetrisAI(this.aiDifficulty);
        this.aiGrid = new Grid();
        
        // Reset battle state
        this.currentRound = 1;
        this.playerWins = 0;
        this.aiWins = 0;
        
        // Reset game state
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Clear queues
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        this.activePowerUps = [];
        
        // Initialize power-up cooldowns
        Object.keys(this.powerUps).forEach(powerUp => {
            this.powerUpCooldowns[powerUp] = 0;
        });
        
        // Start round
        this.startRound();
    }

    startRound() {
        // Reset grids
        if (this.game.grid) {
            this.game.grid.reset();
        }
        this.aiGrid.reset();
        this.ai.reset();
        
        // Reset tracking
        this.lastAILines = 0;
        
        // Clear garbage
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        
        // Show round message
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(
                `Round ${this.currentRound} - FIGHT!`,
                'battle',
                2000
            );
        }
        
        // Play battle music
        if (this.game.audioManager) {
            this.game.audioManager.startBackgroundMusic();
        }
    }

    update(deltaTime) {
        // Update AI with current game state
        if (this.ai) {
            // Give AI the current piece if needed
            if (this.game.currentPiece && !this.ai.currentPiece) {
                // Mirror player's piece sequence for fairness
                this.ai.setPiece(this.game.currentPiece);
            }
            
            this.ai.update(deltaTime);
            
            // Process AI moves
            const aiMove = this.ai.executeNextMove();
            if (aiMove) {
                this.processAIMove(aiMove);
            }
        }
        
        // Update power-ups
        this.updatePowerUps(deltaTime);
        
        // Update cooldowns
        this.updateCooldowns(deltaTime);
        
        // Process garbage lines
        this.processGarbageLines();
        
        // Check round end conditions
        if (this.checkRoundEnd()) {
            return false;
        }
        
        return true;
    }

    handlePiecePlaced() {
        // Battle mode tracks pieces for AI simulation
        this.battleStats.piecesPlaced = (this.battleStats.piecesPlaced || 0) + 1;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) {
            this.game.combo = 0;
            return;
        }
        
        // Update stats
        this.game.lines += linesCleared;
        this.game.combo++;
        
        if (this.game.combo > this.battleStats.maxCombo) {
            this.battleStats.maxCombo = this.game.combo;
        }
        
        // Calculate garbage to send
        let garbageLines = 0;
        switch (linesCleared) {
            case 1:
                garbageLines = 0;
                break;
            case 2:
                garbageLines = 1;
                break;
            case 3:
                garbageLines = 2;
                break;
            case 4:
                garbageLines = 4; // Tetris sends 4 lines
                break;
        }
        
        // Combo bonus
        if (this.game.combo > 2) {
            garbageLines += Math.floor(this.game.combo / 2);
        }
        
        // T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            garbageLines += 2;
        }
        
        // Perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            garbageLines += 6;
        }
        
        // Send garbage to AI
        if (garbageLines > 0) {
            this.sendGarbageToAI(garbageLines);
        }
        
        // Calculate score
        let score = linesCleared * 100 * this.game.level;
        if (specialClear) {
            score *= 2;
        }
        this.game.score += score;
    }

    sendGarbageToAI(lines) {
        // Check if shield is active
        const hasShield = this.activePowerUps.find(p => p.type === 'shield' && p.target === 'ai');
        if (hasShield) {
            lines = Math.floor(lines / 2);
        }
        
        if (lines > 0) {
            this.aiGarbageQueue.push(lines);
            this.ai.addGarbageLines(lines);
            this.battleStats.totalDamageDealt += lines;
            
            // Visual feedback
            if (this.game.uiManager) {
                this.game.uiManager.showDamage('ai', lines);
            }
        }
    }

    receiveGarbageFromAI(lines) {
        // Check if player has shield
        const hasShield = this.activePowerUps.find(p => p.type === 'shield' && p.target === 'player');
        if (hasShield) {
            lines = Math.floor(lines / 2);
        }
        
        if (lines > 0) {
            this.playerGarbageQueue.push(lines);
            this.battleStats.totalDamageReceived += lines;
            
            // Visual feedback
            if (this.game.uiManager) {
                this.game.uiManager.showDamage('player', lines);
            }
        }
    }

    processGarbageLines() {
        // Process player garbage
        if (this.playerGarbageQueue.length > 0 && this.game.grid) {
            const lines = this.playerGarbageQueue.shift();
            this.addGarbageLinesToGrid(this.game.grid, lines);
        }
        
        // Process AI garbage
        if (this.aiGarbageQueue.length > 0 && this.ai) {
            const lines = this.aiGarbageQueue.shift();
            // Let AI handle garbage intelligently
            this.ai.addGarbageLines(lines);
            this.ai.processGarbage();
        }
    }

    addGarbageLinesToGrid(grid, count) {
        for (let i = 0; i < count; i++) {
            // Remove top row
            grid.cells.shift();
            
            // Create garbage line with one hole
            const garbageLine = Array(grid.width).fill(8); // Gray blocks
            const hole = Math.floor(Math.random() * grid.width);
            garbageLine[hole] = 0;
            
            // Add to bottom
            grid.cells.push(garbageLine);
        }
    }

    processAIMove(move) {
        // Simulate AI playing
        switch (move) {
            case 'left':
            case 'right':
            case 'rotate':
            case 'drop':
                // Update AI grid visualization
                if (this.game.uiManager) {
                    this.game.uiManager.updateAIGrid(this.aiGrid);
                }
                break;
        }
        
        // Check if AI cleared lines
        const aiLines = this.checkAILineClears();
        if (aiLines > 0) {
            this.receiveGarbageFromAI(this.calculateGarbageFromLines(aiLines));
        }
    }

    checkAILineClears() {
        // Check actual AI line clears from AI state
        if (!this.ai) return 0;
        
        // The AI should track its own line clears
        const aiLines = this.ai.lines;
        const clearedThisTurn = aiLines - (this.lastAILines || 0);
        this.lastAILines = aiLines;
        
        return clearedThisTurn;
    }

    calculateGarbageFromLines(lines) {
        let garbage = 0;
        
        switch (lines) {
            case 1: 
                garbage = 0;
                break;
            case 2: 
                garbage = 1;
                break;
            case 3: 
                garbage = 2;
                break;
            case 4: 
                garbage = 4; // Tetris sends more
                break;
            default: 
                garbage = 0;
        }
        
        // Add combo multiplier if AI has combos
        if (this.ai && this.ai.combo > 1) {
            garbage += Math.floor(this.ai.combo / 2);
        }
        
        return garbage;
    }

    usePowerUp(type) {
        // Check cooldown
        if (this.powerUpCooldowns[type] > 0) {
            return false;
        }
        
        const powerUp = this.powerUps[type];
        if (!powerUp) return false;
        
        // Apply power-up effect
        switch (type) {
            case 'freeze':
                this.activateFreeze(powerUp.duration);
                break;
            case 'bomb':
                this.activateBomb(powerUp.lines);
                break;
            case 'shield':
                this.activateShield(powerUp.duration);
                break;
            case 'speed':
                this.activateSpeed(powerUp.multiplier, powerUp.duration);
                break;
        }
        
        // Set cooldown
        this.powerUpCooldowns[type] = powerUp.cooldown;
        this.battleStats.powerUpsUsed++;
        
        return true;
    }

    activateFreeze(duration) {
        this.activePowerUps.push({
            type: 'freeze',
            target: 'ai',
            duration: duration,
            remaining: duration
        });
        
        // Freeze AI
        this.ai.params.thinkingDelay *= 3;
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('freeze', 'ai');
        }
    }

    activateBomb(lines) {
        // Clear random lines from AI grid
        for (let i = 0; i < lines && i < this.aiGrid.cells.length; i++) {
            const row = Math.floor(Math.random() * this.aiGrid.cells.length);
            this.aiGrid.cells[row] = Array(this.aiGrid.width).fill(0);
        }
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('bomb', 'ai');
        }
    }

    activateShield(duration) {
        this.activePowerUps.push({
            type: 'shield',
            target: 'player',
            duration: duration,
            remaining: duration
        });
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('shield', 'player');
        }
    }

    activateSpeed(multiplier, duration) {
        this.activePowerUps.push({
            type: 'speed',
            target: 'player',
            duration: duration,
            remaining: duration,
            multiplier: multiplier
        });
        
        // Speed up player drop rate
        this.game.dropInterval /= multiplier;
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('speed', 'player');
        }
    }

    updatePowerUps(deltaTime) {
        this.activePowerUps = this.activePowerUps.filter(powerUp => {
            powerUp.remaining -= deltaTime;
            
            if (powerUp.remaining <= 0) {
                // Remove power-up effect
                this.removePowerUpEffect(powerUp);
                return false;
            }
            return true;
        });
    }

    removePowerUpEffect(powerUp) {
        switch (powerUp.type) {
            case 'freeze':
                // Restore AI speed
                if (this.ai) {
                    this.ai.setupDifficultyParams();
                }
                break;
            case 'speed':
                // Restore player speed
                this.game.dropInterval *= powerUp.multiplier;
                break;
        }
    }

    updateCooldowns(deltaTime) {
        Object.keys(this.powerUpCooldowns).forEach(key => {
            if (this.powerUpCooldowns[key] > 0) {
                this.powerUpCooldowns[key] = Math.max(0, this.powerUpCooldowns[key] - deltaTime);
            }
        });
    }

    checkRoundEnd() {
        // Check if player lost
        if (this.game.grid && this.game.grid.checkGameOver()) {
            this.aiWins++;
            this.endRound(false);
            return true;
        }
        
        // Check if AI lost (simplified)
        if (this.aiGrid && this.aiGrid.checkGameOver()) {
            this.playerWins++;
            this.endRound(true);
            return true;
        }
        
        return false;
    }

    endRound(playerWon) {
        this.battleStats.roundsPlayed++;
        
        // Show round result
        if (this.game.uiManager) {
            this.game.uiManager.showRoundResult(
                playerWon,
                this.currentRound,
                this.playerWins,
                this.aiWins
            );
        }
        
        // Check if match is over
        if (this.playerWins >= this.roundsToWin) {
            this.endMatch(true);
        } else if (this.aiWins >= this.roundsToWin) {
            this.endMatch(false);
        } else {
            // Start next round
            this.currentRound++;
            setTimeout(() => this.startRound(), 3000);
        }
    }

    endMatch(playerWon) {
        this.isComplete = true;
        
        const result = {
            won: playerWon,
            rounds: this.battleStats.roundsPlayed,
            playerWins: this.playerWins,
            aiWins: this.aiWins,
            totalDamageDealt: this.battleStats.totalDamageDealt,
            totalDamageReceived: this.battleStats.totalDamageReceived,
            powerUpsUsed: this.battleStats.powerUpsUsed,
            aiDifficulty: this.aiDifficulty
        };
        
        // Save battle stats
        this.saveBattleStats(result);
        
        // Show match result
        if (this.game.uiManager) {
            this.game.uiManager.showMatchResult(result);
        }
        
        return result;
    }

    saveBattleStats(stats) {
        const key = 'tetris_battle_stats';
        let allStats = [];
        
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                allStats = JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load battle stats:', e);
            }
        }
        
        allStats.push({
            ...stats,
            timestamp: Date.now()
        });
        
        // Keep only last 50 battles
        if (allStats.length > 50) {
            allStats = allStats.slice(-50);
        }
        
        localStorage.setItem(key, JSON.stringify(allStats));
    }

    setDifficulty(difficulty) {
        this.aiDifficulty = Math.max(1, Math.min(5, difficulty));
        if (this.ai) {
            this.ai.difficulty = this.aiDifficulty;
            this.ai.setupDifficultyParams();
        }
    }

    getObjective() {
        return `Win ${this.roundsToWin} rounds! (${this.playerWins}-${this.aiWins})`;
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: false,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: true,
            showBattleGrid: true, // Special flag for battle mode
            customDisplay: {
                round: `Round ${this.currentRound}`,
                playerWins: this.playerWins,
                aiWins: this.aiWins,
                aiDifficulty: ['Easy', 'Normal', 'Hard', 'Expert', 'Grandmaster'][this.aiDifficulty - 1],
                powerUps: this.getAvailablePowerUps()
            }
        };
    }

    getAvailablePowerUps() {
        const available = [];
        Object.keys(this.powerUps).forEach(key => {
            available.push({
                type: key,
                ready: this.powerUpCooldowns[key] === 0,
                cooldown: Math.ceil(this.powerUpCooldowns[key] / 1000)
            });
        });
        return available;
    }

    handleInput(action) {
        // Handle power-up inputs
        switch (action) {
            case 'powerUp1':
                return this.usePowerUp('freeze');
            case 'powerUp2':
                return this.usePowerUp('bomb');
            case 'powerUp3':
                return this.usePowerUp('shield');
            case 'powerUp4':
                return this.usePowerUp('speed');
        }
        return false;
    }

    getLeaderboardCategory() {
        return `battle_${this.aiDifficulty}`;
    }

    supportsSaving() {
        return false; // Battle mode is match-based
    }

    getIcon() {
        return '⚔️';
    }

    getThemeColor() {
        return '#ff0000';
    }
}
})();

/* scripts/ai/tetrisAI.js */
(function() {
// Tetris AI - Intelligent opponent for Battle Mode

window.TetrisAI = class TetrisAI {
    constructor(difficulty = 3) {
        this.difficulty = difficulty; // 1-5 (Easy to Grandmaster)
        this.grid = this.createEmptyGrid();
        this.currentPiece = null;
        this.nextPieces = [];
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.garbageQueue = [];
        this.combo = 0;
        this.lastClearWasLine = false;
        this.recentMoves = [];
        
        // AI parameters based on difficulty
        this.setupDifficultyParams();
        
        // Decision making
        this.thinkingTime = 0;
        this.currentMove = null;
        this.moveQueue = [];
    }
    
    setupDifficultyParams() {
        switch (this.difficulty) {
            case 1: // Easy
                this.params = {
                    thinkingDelay: 800,
                    mistakeRate: 0.3,
                    lookAhead: 0,
                    evaluationWeights: {
                        height: -0.5,
                        holes: -3,
                        bumpiness: -0.2,
                        lines: 10,
                        wells: 0,
                        tspinSetup: 0,
                        tetrisWell: 0,
                        perfectClear: 0,
                        combo: 2
                    },
                    dropSpeed: 1000,
                    garbageDefenseSkill: 0.3
                };
                break;
                
            case 2: // Normal
                this.params = {
                    thinkingDelay: 500,
                    mistakeRate: 0.15,
                    lookAhead: 1,
                    evaluationWeights: {
                        height: -0.8,
                        holes: -5,
                        bumpiness: -0.5,
                        lines: 15,
                        wells: 0.5,
                        tspinSetup: 2,
                        tetrisWell: 1,
                        perfectClear: 10,
                        combo: 5
                    },
                    dropSpeed: 700,
                    garbageDefenseSkill: 0.5
                };
                break;
                
            case 3: // Hard
                this.params = {
                    thinkingDelay: 300,
                    mistakeRate: 0.08,
                    lookAhead: 1,
                    evaluationWeights: {
                        height: -1,
                        holes: -8,
                        bumpiness: -0.8,
                        lines: 20,
                        wells: 1,
                        tspinSetup: 5,
                        tetrisWell: 2,
                        perfectClear: 25,
                        combo: 8
                    },
                    dropSpeed: 400,
                    garbageDefenseSkill: 0.7
                };
                break;
                
            case 4: // Expert
                this.params = {
                    thinkingDelay: 150,
                    mistakeRate: 0.03,
                    lookAhead: 2,
                    evaluationWeights: {
                        height: -1.2,
                        holes: -10,
                        bumpiness: -1,
                        lines: 25,
                        wells: 2,
                        tspinSetup: 8,
                        tetrisWell: 3,
                        perfectClear: 40,
                        combo: 12
                    },
                    dropSpeed: 200,
                    garbageDefenseSkill: 0.85
                };
                break;
                
            case 5: // Grandmaster
                this.params = {
                    thinkingDelay: 50,
                    mistakeRate: 0.01,
                    lookAhead: 3,
                    evaluationWeights: {
                        height: -1.5,
                        holes: -15,
                        bumpiness: -1.2,
                        lines: 30,
                        wells: 3,
                        tspinSetup: 10,
                        tetrisWell: 5,
                        perfectClear: 50,
                        combo: 15
                    },
                    dropSpeed: 100,
                    garbageDefenseSkill: 0.95
                };
                break;
        }
    }
    
    createEmptyGrid() {
        return Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
    }
    
    update(deltaTime) {
        this.thinkingTime += deltaTime;
        
        // Process garbage lines
        if (this.garbageQueue.length > 0 && Math.random() < this.params.garbageDefenseSkill) {
            this.processGarbage();
        }
        
        // Make decision if enough thinking time has passed
        if (this.thinkingTime >= this.params.thinkingDelay) {
            this.thinkingTime = 0;
            
            if (!this.currentMove && this.currentPiece) {
                this.decideBestMove();
            }
            
            if (this.currentMove) {
                this.executeNextMove();
            }
        }
    }
    
    setPiece(piece) {
        this.currentPiece = piece;
        this.currentMove = null;
        this.moveQueue = [];
    }
    
    decideBestMove() {
        if (!this.currentPiece) return;
        
        const moves = this.getAllPossibleMoves(this.currentPiece);
        let bestMove = null;
        let bestScore = -Infinity;
        
        for (let move of moves) {
            const score = this.evaluateMove(move);
            
            // Add randomness based on difficulty
            const randomFactor = (Math.random() - 0.5) * (5 - this.difficulty) * 10;
            const finalScore = score + randomFactor;
            
            if (finalScore > bestScore) {
                bestScore = finalScore;
                bestMove = move;
            }
        }
        
        // Chance to make a mistake
        if (Math.random() < this.params.mistakeRate) {
            bestMove = moves[Math.floor(Math.random() * moves.length)];
        }
        
        this.currentMove = bestMove;
        if (bestMove) {
            this.generateMoveSequence(bestMove);
        }
    }
    
    getAllPossibleMoves(piece) {
        const moves = [];
        const rotations = 4; // All possible rotations
        
        for (let rotation = 0; rotation < rotations; rotation++) {
            const rotatedPiece = this.rotatePiece(piece, rotation);
            
            for (let x = -2; x < GRID_WIDTH + 2; x++) {
                const move = {
                    x: x,
                    rotation: rotation,
                    piece: rotatedPiece
                };
                
                if (this.isValidPosition(rotatedPiece, x)) {
                    // Find drop position
                    move.y = this.getDropPosition(rotatedPiece, x);
                    moves.push(move);
                }
            }
        }
        
        return moves;
    }
    
    rotatePiece(piece, times) {
        let rotated = { ...piece };
        for (let i = 0; i < times; i++) {
            rotated = this.rotateMatrix(rotated);
        }
        return rotated;
    }
    
    rotateMatrix(piece) {
        // Simple rotation logic
        const matrix = piece.shape;
        const n = matrix.length;
        const rotated = Array(n).fill(null).map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                rotated[j][n - 1 - i] = matrix[i][j];
            }
        }
        
        return { ...piece, shape: rotated };
    }
    
    isValidPosition(piece, x, y = 0) {
        // Check if piece fits at position
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    const gridX = x + col;
                    const gridY = y + row;
                    
                    if (gridX < 0 || gridX >= GRID_WIDTH || 
                        gridY >= GRID_HEIGHT ||
                        (gridY >= 0 && this.grid[gridY][gridX])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    getDropPosition(piece, x) {
        let y = 0;
        while (this.isValidPosition(piece, x, y + 1)) {
            y++;
        }
        return y;
    }
    
    evaluateMove(move) {
        // Add y position if not set
        if (!move.y) {
            move.y = this.getDropPosition(move.piece, move.x);
        }
        
        // Simulate placing the piece
        const testGrid = this.cloneGrid();
        this.placePieceOnGrid(testGrid, move.piece, move.x, move.y);
        
        // Clear lines and track combos
        const linesCleared = this.clearLines(testGrid);
        
        // Calculate evaluation metrics - IMPROVED
        const height = this.calculateHeight(testGrid);
        const holes = this.calculateHoles(testGrid);
        const bumpiness = this.calculateBumpiness(testGrid);
        const wells = this.calculateWells(testGrid);
        
        // NEW: Calculate additional advanced metrics
        const deepHoles = this.calculateDeepHoles(testGrid);  // Holes covered by 3+ blocks
        const columnTransitions = this.calculateColumnTransitions(testGrid);  // Roughness
        const rowTransitions = this.calculateRowTransitions(testGrid);  // Horizontal gaps
        const landingHeight = move.y;  // Penalize high placements
        
        // Calculate base score with improved weights
        let score = 0;
        score += this.params.evaluationWeights.height * height;
        score += this.params.evaluationWeights.holes * holes * 1.5;  // Increased hole penalty
        score += this.params.evaluationWeights.bumpiness * bumpiness;
        score += this.params.evaluationWeights.lines * linesCleared * linesCleared;  // Quadratic bonus for multi-lines
        score += this.params.evaluationWeights.wells * wells;
        
        // Add advanced metrics
        score -= deepHoles * 20;  // Heavy penalty for deep holes
        score -= columnTransitions * 2;  // Penalty for roughness
        score -= rowTransitions * 2;  // Penalty for gaps
        score -= landingHeight * 0.5;  // Slight penalty for high placement
        
        // Combo tracking and bonus
        if (linesCleared > 0) {
            if (this.lastClearWasLine) {
                this.combo++;
                score += this.params.evaluationWeights.combo * this.combo * 10;
            } else {
                this.combo = 1;
            }
        } else {
            this.combo = 0;
        }
        
        // Advanced scoring for higher difficulties
        if (this.difficulty >= 3) {
            // T-Spin detection
            if (this.params.evaluationWeights.tspinSetup && move.piece.type === 'T') {
                const tSpinScore = this.detectTSpinSetup(testGrid, move);
                score += this.params.evaluationWeights.tspinSetup * tSpinScore;
            }
            
            // Tetris setup detection
            if (this.params.evaluationWeights.tetrisWell) {
                const tetrisScore = this.detectTetrisWell(testGrid);
                if (move.piece.type === 'I' && linesCleared === 4) {
                    score += this.params.evaluationWeights.tetrisWell * 100; // Big bonus for Tetris
                } else if (move.piece.type === 'I' && tetrisScore > 0) {
                    score -= 20; // Penalty for wasting I piece
                } else {
                    score += this.params.evaluationWeights.tetrisWell * tetrisScore * 10;
                }
            }
            
            // Perfect clear detection
            if (this.params.evaluationWeights.perfectClear && this.isPerfectClear(testGrid)) {
                score += this.params.evaluationWeights.perfectClear * 100;
            }
        }
        
        if (this.difficulty >= 5 && this.params.evaluationWeights.perfectClear) {
            if (this.isPerfectClear(testGrid)) {
                score += this.params.evaluationWeights.perfectClear;
            }
        }
        
        // Look ahead evaluation
        if (this.params.lookAhead > 0 && this.nextPieces.length > 0) {
            score += this.lookAheadEvaluation(testGrid, 0) * 0.5;
        }
        
        return score;
    }
    
    cloneGrid() {
        return this.grid.map(row => [...row]);
    }
    
    placePieceOnGrid(grid, piece, x, y) {
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    const gridY = y + row;
                    const gridX = x + col;
                    if (gridY >= 0 && gridY < GRID_HEIGHT && 
                        gridX >= 0 && gridX < GRID_WIDTH) {
                        grid[gridY][gridX] = piece.shape[row][col];
                    }
                }
            }
        }
    }
    
    clearLines(grid) {
        let linesCleared = 0;
        for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
            if (grid[row].every(cell => cell !== 0)) {
                grid.splice(row, 1);
                grid.unshift(Array(GRID_WIDTH).fill(0));
                linesCleared++;
                row++; // Check same row again
            }
        }
        return linesCleared;
    }
    
    calculateHeight(grid) {
        for (let row = 0; row < GRID_HEIGHT; row++) {
            if (grid[row].some(cell => cell !== 0)) {
                return GRID_HEIGHT - row;
            }
        }
        return 0;
    }
    
    calculateHoles(grid) {
        let holes = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            let blockFound = false;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        return holes;
    }
    
    calculateBumpiness(grid) {
        const heights = [];
        for (let col = 0; col < GRID_WIDTH; col++) {
            let height = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    height = GRID_HEIGHT - row;
                    break;
                }
            }
            heights.push(height);
        }
        
        let bumpiness = 0;
        for (let i = 0; i < heights.length - 1; i++) {
            bumpiness += Math.abs(heights[i] - heights[i + 1]);
        }
        return bumpiness;
    }
    
    calculateWells(grid) {
        let wells = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] === 0) {
                    const leftFilled = col === 0 || grid[row][col - 1] !== 0;
                    const rightFilled = col === GRID_WIDTH - 1 || grid[row][col + 1] !== 0;
                    if (leftFilled && rightFilled) {
                        wells++;
                    }
                }
            }
        }
        return wells;
    }
    
    // NEW: Calculate deep holes (holes covered by 3+ blocks)
    calculateDeepHoles(grid) {
        let deepHoles = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            let blocksAbove = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    blocksAbove++;
                } else if (blocksAbove > 0) {
                    // Found a hole
                    if (blocksAbove >= 3) {
                        deepHoles++;
                    }
                }
            }
        }
        return deepHoles;
    }
    
    // NEW: Calculate column transitions (changes from filled to empty)
    calculateColumnTransitions(grid) {
        let transitions = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            for (let row = 1; row < GRID_HEIGHT; row++) {
                if ((grid[row][col] === 0) !== (grid[row - 1][col] === 0)) {
                    transitions++;
                }
            }
        }
        return transitions;
    }
    
    // NEW: Calculate row transitions (horizontal roughness)
    calculateRowTransitions(grid) {
        let transitions = 0;
        for (let row = 0; row < GRID_HEIGHT; row++) {
            for (let col = 1; col < GRID_WIDTH; col++) {
                if ((grid[row][col] === 0) !== (grid[row][col - 1] === 0)) {
                    transitions++;
                }
            }
        }
        return transitions;
    }
    
    detectTSpinSetup(grid, move) {
        if (!move.piece || move.piece.type !== 'T') return 0;
        
        const x = move.x;
        const y = move.y;
        
        // Check for T-spin setup patterns
        let tSpinScore = 0;
        
        // Check the four corners around the T piece center
        const corners = [
            { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
            { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
        ];
        
        let filledCorners = 0;
        const centerX = x + 1; // T piece center
        const centerY = y + 1;
        
        for (const corner of corners) {
            const cx = centerX + corner.dx;
            const cy = centerY + corner.dy;
            
            // Check bounds and filled cells
            if (cx < 0 || cx >= GRID_WIDTH || cy >= GRID_HEIGHT) {
                filledCorners++;
            } else if (cy >= 0 && grid[cy] && grid[cy][cx] !== 0) {
                filledCorners++;
            }
        }
        
        // T-spin requires at least 3 corners filled
        if (filledCorners >= 3) {
            tSpinScore = 20;
            
            // Check if this would clear lines (T-spin clear bonus)
            const testGrid = this.copyGrid(grid);
            this.placePieceOnGrid(testGrid, move.piece, move.x, move.y);
            const clearedLines = this.clearLines(testGrid);
            
            if (clearedLines > 0) {
                // T-spin single/double/triple bonus
                tSpinScore += clearedLines * 50;
            }
        }
        
        return tSpinScore;
    }
    
    copyGrid(grid) {
        return grid.map(row => [...row]);
    }
    
    detectTetrisWell(grid) {
        // Check for Tetris well setup (one deep column for I piece)
        let bestWellScore = 0;
        
        for (let col = 0; col < GRID_WIDTH; col++) {
            let emptyDepth = 0;
            
            // Count consecutive empty cells from top
            for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
                if (grid[row][col] === 0) {
                    emptyDepth++;
                } else {
                    break;
                }
            }
            
            // Check if this forms a well (adjacent columns are higher)
            if (emptyDepth >= 4) {
                let isWell = true;
                const checkHeight = GRID_HEIGHT - emptyDepth;
                
                // Check left side
                if (col > 0) {
                    for (let row = checkHeight; row < checkHeight + 3 && row < GRID_HEIGHT; row++) {
                        if (grid[row][col - 1] === 0) {
                            isWell = false;
                            break;
                        }
                    }
                }
                
                // Check right side
                if (col < GRID_WIDTH - 1 && isWell) {
                    for (let row = checkHeight; row < checkHeight + 3 && row < GRID_HEIGHT; row++) {
                        if (grid[row][col + 1] === 0) {
                            isWell = false;
                            break;
                        }
                    }
                }
                
                if (isWell) {
                    // Score based on well depth (deeper = better for Tetris)
                    bestWellScore = Math.max(bestWellScore, Math.floor(emptyDepth / 4));
                }
            }
        }
        
        return bestWellScore;
    }
    
    isPerfectClear(grid) {
        return grid.every(row => row.every(cell => cell === 0));
    }
    
    lookAheadEvaluation(grid, depth) {
        if (depth >= this.params.lookAhead || depth >= this.nextPieces.length) {
            return 0;
        }
        // Simplified lookahead
        return 0;
    }
    
    generateMoveSequence(move) {
        this.moveQueue = [];
        
        // Optimize move sequence for faster execution
        const currentX = Math.floor(GRID_WIDTH / 2) - 1; // Starting position
        const targetX = move.x;
        const rotation = move.rotation;
        
        // For higher difficulties, use optimal pathfinding
        if (this.difficulty >= 4) {
            // Try different move orders to find the most efficient path
            const sequences = [];
            
            // Sequence 1: Rotate first, then move
            const seq1 = [];
            for (let i = 0; i < rotation; i++) seq1.push('rotate');
            const dir1 = targetX > currentX ? 'right' : 'left';
            for (let i = 0; i < Math.abs(targetX - currentX); i++) seq1.push(dir1);
            seq1.push('drop');
            sequences.push(seq1);
            
            // Sequence 2: Move partially, rotate, move rest (for wall kicks)
            if (rotation > 0) {
                const seq2 = [];
                const halfMove = Math.floor(Math.abs(targetX - currentX) / 2);
                const dir2 = targetX > currentX ? 'right' : 'left';
                for (let i = 0; i < halfMove; i++) seq2.push(dir2);
                for (let i = 0; i < rotation; i++) seq2.push('rotate');
                for (let i = halfMove; i < Math.abs(targetX - currentX); i++) seq2.push(dir2);
                seq2.push('drop');
                sequences.push(seq2);
            }
            
            // Choose shortest valid sequence
            this.moveQueue = sequences.reduce((best, seq) => 
                seq.length < best.length ? seq : best
            );
        } else {
            // Simple sequence for lower difficulties
            for (let i = 0; i < rotation; i++) {
                this.moveQueue.push('rotate');
            }
            
            const direction = targetX > currentX ? 'right' : 'left';
            const distance = Math.abs(targetX - currentX);
            
            for (let i = 0; i < distance; i++) {
                this.moveQueue.push(direction);
            }
            
            this.moveQueue.push('drop');
        }
        
        // Add finesse optimization for Grandmaster level
        if (this.difficulty === 5) {
            this.optimizeMoveFinesse();
        }
    }
    
    optimizeMoveFinesse() {
        // Remove redundant moves and optimize sequence
        const optimized = [];
        let consecutiveSame = 0;
        let lastMove = null;
        
        for (const move of this.moveQueue) {
            if (move === lastMove && move !== 'drop') {
                consecutiveSame++;
                if (consecutiveSame < 3) { // Limit consecutive same moves
                    optimized.push(move);
                }
            } else {
                consecutiveSame = 0;
                optimized.push(move);
                lastMove = move;
            }
        }
        
        this.moveQueue = optimized;
    }
    
    executeNextMove() {
        if (this.moveQueue.length === 0) {
            this.currentMove = null;
            return null;
        }
        
        return this.moveQueue.shift();
    }
    
    addGarbageLines(count) {
        this.garbageQueue.push(count);
    }
    
    processGarbage() {
        if (this.garbageQueue.length === 0) return;
        
        const lines = this.garbageQueue.shift();
        
        // Smart garbage handling based on difficulty
        if (this.difficulty >= 3) {
            // Try to clear garbage efficiently
            const garbageRows = [];
            for (let row = GRID_HEIGHT - 1; row >= GRID_HEIGHT - lines && row >= 0; row--) {
                if (this.grid[row].some(cell => cell !== 0)) {
                    garbageRows.push(row);
                }
            }
            
            // If we can clear some garbage with current piece, prioritize it
            if (garbageRows.length > 0 && this.currentPiece) {
                // Re-evaluate move with garbage consideration
                this.currentMove = null;
                this.moveQueue = [];
            }
        }
        
        // Add garbage lines to grid
        for (let i = 0; i < lines; i++) {
            this.grid.shift(); // Remove top row
            const garbageLine = Array(GRID_WIDTH).fill(8); // Gray blocks
            
            // Smart hole placement for counter-attack potential
            let hole;
            if (this.difficulty >= 4) {
                // Place hole strategically for easier clearing
                const columnHeights = this.getColumnHeights();
                const lowestCol = columnHeights.indexOf(Math.min(...columnHeights));
                hole = lowestCol;
            } else {
                hole = Math.floor(Math.random() * GRID_WIDTH);
            }
            
            garbageLine[hole] = 0;
            this.grid.push(garbageLine);
        }
    }
    
    getColumnHeights() {
        const heights = [];
        for (let col = 0; col < GRID_WIDTH; col++) {
            let height = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (this.grid[row][col] !== 0) {
                    height = GRID_HEIGHT - row;
                    break;
                }
            }
            heights.push(height);
        }
        return heights;
    }
    
    getStats() {
        return {
            score: this.score,
            lines: this.lines,
            level: this.level,
            difficulty: this.difficulty
        };
    }
    
    reset() {
        this.grid = this.createEmptyGrid();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.currentPiece = null;
        this.currentMove = null;
        this.moveQueue = [];
        this.garbageQueue = [];
        this.thinkingTime = 0;
        this.combo = 0;
        this.lastClearWasLine = false;
        this.recentMoves = [];
    }
}
})();

/* scripts/modeSelector.js */
(function() {
// Mode Selector - Manages game mode selection and initialization






window.ModeSelector = class ModeSelector {
    constructor() {
        this.availableModes = {
            classic: {
                name: 'Classic',
                class: ClassicMode,
                icon: '🎮',
                color: '#00ffff',
                description: 'The original endless Tetris experience',
                unlocked: true
            },
            sprint: {
                name: 'Sprint',
                class: SprintMode,
                icon: '⏱️',
                color: '#ff00ff',
                description: 'Clear 40 lines as fast as possible',
                unlocked: true
            },
            marathon: {
                name: 'Marathon',
                class: MarathonMode,
                icon: '🏃',
                color: '#ffff00',
                description: 'Survive 150 lines with increasing difficulty',
                unlocked: true
            },
            zen: {
                name: 'Zen',
                class: ZenMode,
                icon: '🧘',
                color: '#00ff00',
                description: 'Relaxing endless mode with no pressure',
                unlocked: true
            },
            puzzle: {
                name: 'Puzzle',
                class: PuzzleMode,
                icon: '🧩',
                color: '#ff8800',
                description: 'Solve 150 unique challenges',
                unlocked: true
            },
            battle: {
                name: 'Battle',
                class: BattleMode,
                icon: '⚔️',
                color: '#ff0000',
                description: 'Face off against intelligent AI opponents',
                unlocked: true
            }
        };
        
        this.currentMode = 'classic';
        this.modeInstance = null;
    }

    // Get all available modes
    getModes() {
        return Object.entries(this.availableModes).map(([key, mode]) => ({
            id: key,
            ...mode
        }));
    }

    // Get unlocked modes only
    getUnlockedModes() {
        return this.getModes().filter(mode => mode.unlocked);
    }

    // Select a game mode
    selectMode(modeId) {
        if (!this.availableModes[modeId]) {
            console.error(`Mode ${modeId} not found`);
            return null;
        }
        
        if (!this.availableModes[modeId].unlocked) {
            console.warn(`Mode ${modeId} is locked`);
            return null;
        }
        
        this.currentMode = modeId;
        return this.availableModes[modeId];
    }

    // Create mode instance
    createModeInstance(modeId, game) {
        const mode = this.selectMode(modeId);
        if (!mode) {
            // Default to classic if mode not found
            modeId = 'classic';
        }
        
        const ModeClass = this.availableModes[modeId].class;
        this.modeInstance = new ModeClass(game);
        return this.modeInstance;
    }

    // Get current mode instance
    getCurrentMode() {
        return this.modeInstance;
    }

    // Get mode info
    getModeInfo(modeId) {
        return this.availableModes[modeId] || null;
    }

    // Check if mode is unlocked
    isModeUnlocked(modeId) {
        return this.availableModes[modeId] && this.availableModes[modeId].unlocked;
    }

    // Unlock a mode
    unlockMode(modeId) {
        if (this.availableModes[modeId]) {
            this.availableModes[modeId].unlocked = true;
            this.saveModeProgress();
        }
    }

    // Save mode progress to localStorage
    saveModeProgress() {
        const progress = {};
        Object.keys(this.availableModes).forEach(key => {
            progress[key] = this.availableModes[key].unlocked;
        });
        localStorage.setItem('tetris_mode_progress', JSON.stringify(progress));
    }

    // Load mode progress from localStorage
    loadModeProgress() {
        const saved = localStorage.getItem('tetris_mode_progress');
        if (saved) {
            try {
                const progress = JSON.parse(saved);
                Object.keys(progress).forEach(key => {
                    if (this.availableModes[key]) {
                        this.availableModes[key].unlocked = progress[key];
                    }
                });
            } catch (e) {
                console.error('Failed to load mode progress:', e);
            }
        }
    }

    // Get mode statistics
    getModeStatistics(modeId) {
        const key = `tetris_stats_${modeId}`;
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load mode statistics:', e);
            }
        }
        return null;
    }

    // Save mode statistics
    saveModeStatistics(modeId, stats) {
        const key = `tetris_stats_${modeId}`;
        localStorage.setItem(key, JSON.stringify(stats));
    }

    // Get best scores for a mode
    getBestScores(modeId, limit = 10) {
        const key = `tetris_scores_${modeId}`;
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                const scores = JSON.parse(saved);
                return scores.slice(0, limit);
            } catch (e) {
                console.error('Failed to load mode scores:', e);
            }
        }
        return [];
    }

    // Add score to mode leaderboard
    addScore(modeId, scoreData) {
        const key = `tetris_scores_${modeId}`;
        let scores = [];
        
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                scores = JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load existing scores:', e);
            }
        }
        
        // Add new score with timestamp
        scores.push({
            ...scoreData,
            timestamp: Date.now()
        });
        
        // Sort by score (or time for sprint mode)
        if (modeId === 'sprint') {
            scores.sort((a, b) => a.time - b.time);
        } else {
            scores.sort((a, b) => b.score - a.score);
        }
        
        // Keep only top 100 scores
        scores = scores.slice(0, 100);
        
        localStorage.setItem(key, JSON.stringify(scores));
        return scores;
    }

    // Reset mode progress
    resetModeProgress(modeId) {
        if (modeId) {
            // Reset specific mode
            localStorage.removeItem(`tetris_stats_${modeId}`);
            localStorage.removeItem(`tetris_scores_${modeId}`);
        } else {
            // Reset all modes
            Object.keys(this.availableModes).forEach(key => {
                localStorage.removeItem(`tetris_stats_${key}`);
                localStorage.removeItem(`tetris_scores_${key}`);
            });
            localStorage.removeItem('tetris_mode_progress');
        }
    }

    // Get mode thumbnail for UI
    getModeThumbnail(modeId) {
        const mode = this.availableModes[modeId];
        if (!mode) return null;
        
        return {
            icon: mode.icon,
            color: mode.color,
            name: mode.name,
            description: mode.description,
            unlocked: mode.unlocked
        };
    }
}
})();

/* scripts/leaderboard.js */
(function() {
// Modern Tetris - Leaderboard Management System

window.LeaderboardManager = class LeaderboardManager {
    constructor() {
        this.apiBaseUrl = 'api/scores.php';
        this.currentTab = 'top-scores';
        this.currentMode = 'classic'; // Default to classic mode
        this.offlineStorage = offlineStorage;
        this.gameModes = [
            { id: 'classic', name: 'Classic', icon: '🎮' },
            { id: 'sprint', name: 'Sprint', icon: '⏱️' },
            { id: 'marathon', name: 'Marathon', icon: '🏃' },
            { id: 'zen', name: 'Zen', icon: '🧘' },
            { id: 'puzzle', name: 'Puzzle', icon: '🧩' },
            { id: 'battle', name: 'Battle', icon: '⚔️' }
        ];
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchTab(e.target.dataset.tab);
            });
        });

        // Close leaderboard
        const closeButton = document.getElementById('close-leaderboard');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                this.hideLeaderboard();
            });
        }

        // Close on overlay click
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    this.hideLeaderboard();
                }
            });
        }
    }

    // Show leaderboard modal with optional mode
    async showLeaderboard(mode = null) {
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            
            // Clear any active game inputs to prevent interference
            if (window.tetrisGame && window.tetrisGame.inputManager) {
                window.tetrisGame.inputManager.reset();
            }
            
            // Set mode if provided
            if (mode) {
                this.currentMode = mode;
            }
            
            this.currentTab = 'top-scores';
            this.createModeSelector();
            this.updateTabButtons();
            await this.loadLeaderboardData();
        }
    }

    // Hide leaderboard modal
    hideLeaderboard() {
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    // Switch between tabs
    async switchTab(tab) {
        if (tab === this.currentTab) return;
        
        this.currentTab = tab;
        this.updateTabButtons();
        await this.loadLeaderboardData();
    }

    // Update tab button states
    updateTabButtons() {
        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === this.currentTab);
        });
    }

    // Load leaderboard data based on current tab
    async loadLeaderboardData() {
        const listContainer = document.getElementById('leaderboard-list');
        if (!listContainer) return;

        listContainer.innerHTML = '<div class="loading">Loading scores...</div>';

        try {
            let data;
            if (this.currentTab === 'top-scores') {
                data = await this.fetchTopScores();
            } else if (this.currentTab === 'recent') {
                data = await this.fetchRecentScores();
            }

            this.renderLeaderboard(data);
        } catch (error) {
            this.showError('Failed to load scores. Please try again later.');
        }
    }

    // Fetch top scores from API with offline fallback
    async fetchTopScores(limit = 50) {
        try {
            const response = await fetch(`${this.apiBaseUrl}?action=leaderboard&mode=${this.currentMode}&limit=${limit}`);
            const result = await response.json();
            
            if (!result.success) {
                // Check if offline response
                if (result.offline) {
                    throw new Error('offline');
                }
                throw new Error(result.error || 'Failed to fetch scores');
            }
            
            // Cache the data for offline use
            await this.offlineStorage.cacheLeaderboardData('top-scores', result.data);
            
            return result.data;
        } catch (error) {
            console.log('Failed to fetch from server, using offline mode:', error.message);
            
            // Try to get cached data
            const cached = await this.offlineStorage.getCachedLeaderboardData('top-scores');
            
            if (cached && cached.data) {
                console.log('Using cached leaderboard data');
                // Add local scores if offline
                if (!navigator.onLine) {
                    const localScores = await this.offlineStorage.getAllLocalScores();
                    return this.mergeScores(cached.data, localScores);
                }
                return cached.data;
            }
            
            // If no cache, return local scores only
            const localScores = await this.offlineStorage.getAllLocalScores();
            return localScores.map((score, index) => ({
                ...score,
                rank: index + 1,
                player_name: score.playerName,
                date_achieved: new Date(score.timestamp).toISOString(),
                special_achievements: score.specialAchievements || {}
            }));
        }
    }

    // Fetch recent scores from API with offline fallback
    async fetchRecentScores(limit = 20) {
        try {
            const response = await fetch(`${this.apiBaseUrl}?action=recent&mode=${this.currentMode}&limit=${limit}`);
            const result = await response.json();
            
            if (!result.success) {
                if (result.offline) {
                    throw new Error('offline');
                }
                throw new Error(result.error || 'Failed to fetch scores');
            }
            
            // Cache the data for offline use
            await this.offlineStorage.cacheLeaderboardData('recent', result.data);
            
            return result.data;
        } catch (error) {
            console.log('Failed to fetch recent scores, using offline mode');
            
            // Try to get cached data
            const cached = await this.offlineStorage.getCachedLeaderboardData('recent');
            
            if (cached && cached.data) {
                return cached.data;
            }
            
            // Return local scores sorted by timestamp
            const localScores = await this.offlineStorage.getAllLocalScores();
            return localScores
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, limit)
                .map(score => ({
                    ...score,
                    player_name: score.playerName,
                    date_achieved: new Date(score.timestamp).toISOString(),
                    special_achievements: score.specialAchievements || {}
                }));
        }
    }
    
    // Merge server scores with local unsynced scores
    mergeScores(serverScores, localScores) {
        const merged = [...serverScores];
        
        // Add unsynced local scores
        localScores.forEach(localScore => {
            if (!localScore.synced) {
                merged.push({
                    ...localScore,
                    rank: 0, // Will be recalculated
                    player_name: localScore.playerName,
                    date_achieved: new Date(localScore.timestamp).toISOString(),
                    special_achievements: localScore.specialAchievements || {},
                    isLocal: true // Mark as local
                });
            }
        });
        
        // Re-sort and re-rank
        merged.sort((a, b) => b.score - a.score);
        merged.forEach((score, index) => {
            score.rank = index + 1;
        });
        
        return merged;
    }

    // Render leaderboard entries based on mode
    renderLeaderboard(scores) {
        const listContainer = document.getElementById('leaderboard-list');
        if (!listContainer || !scores || scores.length === 0) {
            listContainer.innerHTML = '<div class="loading">No scores available yet.</div>';
            return;
        }

        const entriesHTML = scores.map((score, index) => {
            const rank = score.rank || (index + 1);
            const rankClass = this.getRankClass(rank);
            const date = new Date(score.date_achieved);
            const achievements = this.formatAchievements(score.special_achievements);
            
            // Mode-specific display
            let modeSpecificInfo = '';
            if (this.currentMode === 'sprint') {
                const time = score.time || score.game_duration || 0;
                modeSpecificInfo = `<div class="entry-time">Time: ${this.formatTime(time)}</div>`;
            } else if (this.currentMode === 'puzzle') {
                const puzzleId = score.puzzle_id || 1;
                const stars = score.stars || 0;
                modeSpecificInfo = `<div class="entry-puzzle">Puzzle #${puzzleId} ${'⭐'.repeat(stars)}</div>`;
            } else if (this.currentMode === 'marathon') {
                modeSpecificInfo = `<div class="entry-checkpoint">Lines: ${score.lines}/150</div>`;
            } else if (this.currentMode === 'zen') {
                const duration = score.game_duration || 0;
                modeSpecificInfo = `<div class="entry-duration">Duration: ${Math.floor(duration / 60)}m</div>`;
            } else if (this.currentMode === 'battle') {
                const wins = score.wins || 0;
                modeSpecificInfo = `<div class="entry-wins">Wins: ${wins}</div>`;
            }
            
            return `
                <div class="leaderboard-entry">
                    <div class="entry-rank ${rankClass}">${this.formatRank(rank)}</div>
                    <div class="entry-info">
                        <div class="entry-name">${this.escapeHtml(score.player_name)}</div>
                        <div class="entry-date">${date.toLocaleDateString()}</div>
                        ${modeSpecificInfo}
                        ${achievements ? `<div class="entry-achievements">${achievements}</div>` : ''}
                    </div>
                    <div class="entry-score">${score.score.toLocaleString()}</div>
                    <div class="entry-lines">${score.lines || 0}</div>
                    <div class="entry-level">${score.level || 1}</div>
                </div>
            `;
        }).join('');

        listContainer.innerHTML = entriesHTML;
    }

    // Get CSS class for rank styling
    getRankClass(rank) {
        if (rank === 1) return 'gold';
        if (rank === 2) return 'silver';
        if (rank === 3) return 'bronze';
        return '';
    }

    // Format rank number with trophy for top 3
    formatRank(rank) {
        if (rank === 1) return '🥇';
        if (rank === 2) return '🥈';
        if (rank === 3) return '🥉';
        return rank;
    }

    // Format special achievements
    formatAchievements(achievements) {
        if (!achievements || typeof achievements !== 'object') return '';
        
        const parts = [];
        if (achievements.tspins > 0) parts.push(`${achievements.tspins} T-Spins`);
        if (achievements.tetris > 0) parts.push(`${achievements.tetris} Tetris`);
        if (achievements.combos > 0) parts.push(`${achievements.combos} Combos`);
        
        return parts.length > 0 ? parts.join(' • ') : '';
    }

    // Show error message
    showError(message) {
        const listContainer = document.getElementById('leaderboard-list');
        if (listContainer) {
            listContainer.innerHTML = `<div class="error-message">${this.escapeHtml(message)}</div>`;
        }
    }

    // Create mode selector UI
    createModeSelector() {
        let selectorContainer = document.getElementById('mode-selector-container');
        if (!selectorContainer) {
            // Create container if it doesn't exist
            const header = document.querySelector('.leaderboard-header');
            if (header) {
                selectorContainer = document.createElement('div');
                selectorContainer.id = 'mode-selector-container';
                selectorContainer.className = 'mode-selector-container';
                header.appendChild(selectorContainer);
            }
        }
        
        if (selectorContainer) {
            const selectorHTML = `
                <div class="mode-selector">
                    ${this.gameModes.map(mode => `
                        <button class="mode-select-btn ${mode.id === this.currentMode ? 'active' : ''}" 
                                data-mode="${mode.id}">
                            <span class="mode-icon">${mode.icon}</span>
                            <span class="mode-name">${mode.name}</span>
                        </button>
                    `).join('')}
                </div>
            `;
            selectorContainer.innerHTML = selectorHTML;
            
            // Add event listeners
            selectorContainer.querySelectorAll('.mode-select-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    if (mode !== this.currentMode) {
                        this.currentMode = mode;
                        this.createModeSelector(); // Update UI
                        await this.loadLeaderboardData();
                    }
                });
            });
        }
    }
    
    // Format time for Sprint mode
    formatTime(seconds) {
        if (typeof seconds === 'string') {
            // If it's already formatted, return as is
            if (seconds.includes(':')) return seconds;
            seconds = parseInt(seconds);
        }
        
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Escape HTML to prevent XSS
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Score Saving System
window.ScoreSaver = class ScoreSaver {
    constructor() {
        this.apiBaseUrl = 'api/scores.php';
        this.gameStartTime = Date.now();
        this.offlineStorage = offlineStorage;
        this.currentMode = 'classic';
        this.modeSpecificData = {};
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Save score button
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.addEventListener('click', () => {
                this.saveCurrentScore();
            });
        }

        // Skip save button
        const skipButton = document.getElementById('skip-save-button');
        if (skipButton) {
            skipButton.addEventListener('click', () => {
                this.hideNameInput();
            });
        }

        // Enter key in name input
        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.saveCurrentScore();
                }
            });
        }

        // Close on overlay click
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    this.hideNameInput();
                }
            });
        }
    }

    // Show name input dialog with score data
    showNameInput(gameStats, specialAchievements = {}, mode = 'classic', modeData = {}) {
        this.currentGameStats = gameStats;
        this.currentAchievements = specialAchievements;
        this.currentMode = mode;
        this.modeSpecificData = modeData;
        
        // Update score display
        document.getElementById('final-score').textContent = gameStats.score.toLocaleString();
        document.getElementById('final-lines').textContent = gameStats.lines;
        document.getElementById('final-level').textContent = gameStats.level;
        
        // Add mode-specific display
        this.updateModeSpecificDisplay();
        
        // Load saved player name if available
        this.loadSavedPlayerName();
        
        // Show modal
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            
            // Clear any active game inputs to prevent interference
            if (window.tetrisGame && window.tetrisGame.inputManager) {
                window.tetrisGame.inputManager.reset();
            }
            
            // Focus name input and select existing text if any
            setTimeout(() => {
                const nameInput = document.getElementById('player-name-input');
                if (nameInput) {
                    nameInput.focus();
                    if (nameInput.value) {
                        nameInput.select();
                    }
                }
            }, 300);
        }
    }

    // Hide name input dialog
    hideNameInput() {
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
        
        // Clear input
        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.value = '';
        }
    }

    // Save current score to database
    async saveCurrentScore() {
        const nameInput = document.getElementById('player-name-input');
        const playerName = nameInput ? nameInput.value.trim() : '';
        
        if (!playerName) {
            nameInput.focus();
            nameInput.style.borderColor = 'var(--neon-red)';
            setTimeout(() => {
                nameInput.style.borderColor = '';
            }, 2000);
            return;
        }

        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;
        }

        try {
            const gameDuration = Math.floor((Date.now() - this.gameStartTime) / 1000);
            
            const scoreData = {
                playerName: playerName,
                score: this.currentGameStats.score,
                lines: this.currentGameStats.lines,
                level: this.currentGameStats.level,
                gameDuration: gameDuration,
                specialAchievements: this.currentAchievements,
                mode: this.currentMode,
                ...this.modeSpecificData // Include mode-specific data
            };

            let result;
            
            try {
                const response = await fetch(this.apiBaseUrl + '?action=save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(scoreData)
                });

                result = await response.json();
                
                if (!result.success) {
                    // Check if offline
                    if (result.offline) {
                        // Save locally
                        await this.offlineStorage.saveScoreLocally(scoreData);
                        this.showOfflineSave();
                        
                        // Store player name for next time
                        localStorage.setItem('tetris_player_name', playerName);
                        
                        // Hide modal after delay
                        setTimeout(() => {
                            this.hideNameInput();
                        }, 2000);
                        return;
                    }
                    throw new Error(result.error || 'Failed to save score');
                }
            } catch (fetchError) {
                // Network error - save locally
                console.log('Network error, saving locally:', fetchError);
                await this.offlineStorage.saveScoreLocally(scoreData);
                await this.offlineStorage.registerBackgroundSync();
                this.showOfflineSave();
                
                // Store player name for next time
                localStorage.setItem('tetris_player_name', playerName);
                
                // Hide modal after delay
                setTimeout(() => {
                    this.hideNameInput();
                }, 2000);
                return;
            }

            if (result.success) {
                // Show success message
                this.showSaveSuccess(result.data.rank);
                
                // Store player name for next time
                localStorage.setItem('tetris_player_name', playerName);
                
                // Hide modal after delay
                setTimeout(() => {
                    this.hideNameInput();
                }, 2000);
            } else {
                throw new Error(result.error || 'Failed to save score');
            }
        } catch (error) {
            this.showSaveError(error.message);
        } finally {
            if (saveButton) {
                saveButton.textContent = 'Save Score';
                saveButton.disabled = false;
            }
        }
    }

    // Show save success message
    showSaveSuccess(rank) {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = `Saved! Rank #${rank}`;
            saveButton.style.background = 'var(--neon-green)';
        }
    }

    // Show save error message
    showSaveError(message) {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Error - Try Again';
            saveButton.style.background = 'var(--neon-red)';
            setTimeout(() => {
                saveButton.textContent = 'Save Score';
                saveButton.style.background = '';
            }, 3000);
        }
    }
    
    // Show offline save message
    showOfflineSave() {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Saved Locally! 📴';
            saveButton.style.background = 'var(--neon-orange)';
        }
    }

    // Check if score qualifies for high score
    async isHighScore(score) {
        try {
            const scores = await this.fetchTopScores(50);
            return scores.length < 50 || score > scores[scores.length - 1].score;
        } catch (error) {
            // If we can't check, assume it's worth saving
            return true;
        }
    }

    async fetchTopScores(limit) {
        const response = await fetch(`${this.apiBaseUrl}?action=leaderboard&limit=${limit}`);
        const result = await response.json();
        return result.success ? result.data : [];
    }

    // Set game start time
    setGameStartTime(time = Date.now()) {
        this.gameStartTime = time;
    }

    // Load saved player name
    loadSavedPlayerName() {
        const savedName = localStorage.getItem('tetris_player_name');
        const nameInput = document.getElementById('player-name-input');
        if (savedName && nameInput) {
            nameInput.value = savedName;
        }
        return savedName;
    }
    
    // Update mode-specific display in the save dialog
    updateModeSpecificDisplay() {
        const modeDisplay = document.getElementById('mode-specific-display');
        if (!modeDisplay) return;
        
        let displayHTML = '';
        
        switch (this.currentMode) {
            case 'sprint':
                if (this.modeSpecificData.time) {
                    const minutes = Math.floor(this.modeSpecificData.time / 60000);
                    const seconds = Math.floor((this.modeSpecificData.time % 60000) / 1000);
                    const ms = Math.floor((this.modeSpecificData.time % 1000) / 10);
                    displayHTML = `<div class="mode-info">Time: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}</div>`;
                }
                break;
            case 'puzzle':
                if (this.modeSpecificData.puzzleId) {
                    displayHTML = `<div class="mode-info">Puzzle #${this.modeSpecificData.puzzleId} ${'⭐'.repeat(this.modeSpecificData.stars || 0)}</div>`;
                }
                break;
            case 'marathon':
                displayHTML = `<div class="mode-info">Progress: ${this.currentGameStats.lines}/150 lines</div>`;
                break;
            case 'zen':
                const duration = this.modeSpecificData.duration || this.gameDuration;
                displayHTML = `<div class="mode-info">Duration: ${Math.floor(duration / 60)}m ${duration % 60}s</div>`;
                break;
            case 'battle':
                if (this.modeSpecificData.wins !== undefined) {
                    displayHTML = `<div class="mode-info">Wins: ${this.modeSpecificData.wins}</div>`;
                }
                break;
        }
        
        modeDisplay.innerHTML = displayHTML;
    }
}
})();

/* scripts/ui.js */
(function() {
// Modern Tetris - UI Management and Effects


window.UIManager = class UIManager {
    constructor(game) {
        this.game = game;
        this.elements = this.getUIElements();
        this.particleSystem = new ParticleSystem();
        this.animations = new Map();
        
        // Initialize score and leaderboard systems
        this.scoreSaver = new ScoreSaver();
        this.leaderboardManager = new LeaderboardManager();
        
        // Mode-specific UI elements
        this.modeUI = null;
        this.currentModeDisplay = null;
        
        this.initializeUI();
    }

    getUIElements() {
        return {
            score: document.getElementById('score'),
            lines: document.getElementById('lines'),
            level: document.getElementById('level'),
            overlay: document.getElementById('game-overlay'),
            overlayTitle: document.getElementById('overlay-title'),
            overlayMessage: document.getElementById('overlay-message'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            leaderboardButton: document.getElementById('leaderboard-button'),
            holdPiece: document.querySelector('.hold-piece'),
            nextPieces: [
                document.getElementById('next-0'),
                document.getElementById('next-1'),
                document.getElementById('next-2')
            ],
            particlesContainer: document.getElementById('particles'),
            
            // Mobile elements for synchronization
            mobileHold: document.getElementById('mobile-hold-piece'),
            mobileScore: document.querySelectorAll('[data-sync="score"]'),
            mobileLines: document.querySelectorAll('[data-sync="lines"]'),
            mobileLevel: document.querySelectorAll('[data-sync="level"]'),
            mobileNext: [
                document.getElementById('mobile-next-0'),
                document.getElementById('mobile-next-1'),
                document.getElementById('mobile-next-2')
            ]
        };
    }

    initializeUI() {
        // Button event listeners
        if (this.elements.startButton) {
            this.elements.startButton.addEventListener('click', async () => {
                // Trigger audio context on first user interaction
                if (this.game.audioManager) {
                    await this.game.audioManager.resumeAudioContext();
                }
                this.game.start();
            });
        }
        
        if (this.elements.restartButton) {
            this.elements.restartButton.addEventListener('click', () => {
                this.game.restart();
            });
        }
        
        if (this.elements.leaderboardButton) {
            this.elements.leaderboardButton.addEventListener('click', () => {
                this.leaderboardManager.showLeaderboard();
            });
        }
        
        // Initialize particle system
        this.particleSystem.init(this.elements.particlesContainer);
    }

    // Update game stats display
    updateStats(stats) {
        this.updateScore(stats.score);
        this.updateLines(stats.lines);
        this.updateLevel(stats.level);
    }

    updateScore(score) {
        if (this.elements.score) {
            const oldScore = parseInt(this.elements.score.textContent) || 0;
            this.elements.score.textContent = score.toLocaleString();
            
            // Update mobile elements
            this.elements.mobileScore.forEach(el => {
                if (el) el.textContent = score.toLocaleString();
            });
            
            // Animate score increase
            if (score > oldScore) {
                this.elements.score.classList.add('animate-score-pop');
                setTimeout(() => {
                    this.elements.score.classList.remove('animate-score-pop');
                }, 400);
            }
        }
    }

    updateLines(lines) {
        if (this.elements.lines) {
            this.elements.lines.textContent = lines;
        }
        
        // Update mobile elements
        this.elements.mobileLines.forEach(el => {
            if (el) el.textContent = lines;
        });
    }

    updateLevel(level) {
        if (this.elements.level) {
            const oldLevel = parseInt(this.elements.level.textContent) || 1;
            this.elements.level.textContent = level;
            
            // Update mobile elements
            this.elements.mobileLevel.forEach(el => {
                if (el) el.textContent = level;
            });
            
            // Animate level up
            if (level > oldLevel) {
                this.elements.level.classList.add('animate-level-up');
                setTimeout(() => {
                    this.elements.level.classList.remove('animate-level-up');
                }, 1000);
                
                // Create level up particles
                this.particleSystem.createLevelUpEffect();
            }
        }
    }

    // Update hold piece display
    updateHoldPiece(piece) {
        // Update desktop hold piece
        if (this.elements.holdPiece) {
            this.elements.holdPiece.innerHTML = '';
            
            if (piece) {
                const miniGrid = this.createMiniGrid(piece);
                this.elements.holdPiece.appendChild(miniGrid);
                
                // Animate swap
                this.elements.holdPiece.classList.add('animate-swap');
                setTimeout(() => {
                    this.elements.holdPiece.classList.remove('animate-swap');
                }, 600);
            }
        }
        
        // Update mobile hold piece
        if (this.elements.mobileHold) {
            this.elements.mobileHold.innerHTML = '';
            
            if (piece) {
                const mobileGrid = this.createMiniGrid(piece, true); // true for mobile size
                this.elements.mobileHold.appendChild(mobileGrid);
            }
        }
    }

    // Update next pieces display
    updateNextPieces(pieces) {
        // Update desktop next pieces
        pieces.forEach((pieceType, index) => {
            if (this.elements.nextPieces[index]) {
                this.elements.nextPieces[index].innerHTML = '';
                
                if (pieceType) {
                    const { Piece, PIECE_COLORS } = this.game.pieceModule;
                    const piece = new Piece(pieceType);
                    const miniGrid = this.createMiniGrid(piece);
                    this.elements.nextPieces[index].appendChild(miniGrid);
                    
                    // Animate new piece
                    if (index === 0) {
                        this.elements.nextPieces[index].classList.add('slide-in-right');
                        setTimeout(() => {
                            this.elements.nextPieces[index].classList.remove('slide-in-right');
                        }, 400);
                    }
                }
            }
        });
        
        // Update mobile next pieces
        pieces.forEach((pieceType, index) => {
            if (this.elements.mobileNext[index]) {
                this.elements.mobileNext[index].innerHTML = '';
                
                if (pieceType) {
                    const { Piece, PIECE_COLORS } = this.game.pieceModule;
                    const piece = new Piece(pieceType);
                    const mobileGrid = this.createMiniGrid(piece, true); // true for mobile size
                    this.elements.mobileNext[index].appendChild(mobileGrid);
                }
            }
        });
    }

    // Create mini grid for piece preview
    createMiniGrid(piece, isMobile = false) {
        const container = document.createElement('div');
        container.className = 'mini-grid';
        
        const gap = isMobile ? '0.5px' : '1px';
        const borderRadius = isMobile ? '1px' : '2px';
        const glowSize = isMobile ? '6px' : '10px';
        
        container.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: ${gap};
            width: 100%;
            height: 100%;
        `;
        
        const shape = piece.getCurrentShape();
        
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                const cell = document.createElement('div');
                cell.style.cssText = `
                    aspect-ratio: 1;
                    border-radius: ${borderRadius};
                    transition: all 0.2s ease;
                `;
                
                if (shape[y] && shape[y][x]) {
                    cell.style.backgroundColor = piece.color;
                    cell.style.boxShadow = `0 0 ${glowSize} ${piece.color}40`;
                    cell.style.border = `1px solid ${piece.color}`;
                } else {
                    cell.style.backgroundColor = 'transparent';
                }
                
                container.appendChild(cell);
            }
        }
        
        return container;
    }

    // Show game overlay
    showOverlay(title, message, showRestart = false) {
        if (!this.elements.overlay) return;
        
        this.elements.overlay.classList.remove('hidden');
        
        if (this.elements.overlayTitle) {
            this.elements.overlayTitle.textContent = title;
        }
        
        if (this.elements.overlayMessage) {
            this.elements.overlayMessage.textContent = message;
        }
        
        if (this.elements.startButton) {
            this.elements.startButton.style.display = showRestart ? 'none' : 'inline-block';
        }
        
        if (this.elements.restartButton) {
            this.elements.restartButton.style.display = showRestart ? 'inline-block' : 'none';
        }
        
        // Animate overlay appearance
        this.elements.overlay.classList.add('animate-game-over');
        setTimeout(() => {
            this.elements.overlay.classList.remove('animate-game-over');
        }, 800);
    }

    // Hide game overlay
    hideOverlay() {
        if (this.elements.overlay) {
            this.elements.overlay.classList.add('hidden');
        }
    }
    
    // Update mode-specific display
    updateModeDisplay(modeConfig) {
        if (!modeConfig) return;
        
        this.modeUI = modeConfig;
        
        // Show/hide UI elements based on mode
        if (this.elements.score) {
            this.elements.score.parentElement.style.display = modeConfig.showScore ? 'block' : 'none';
        }
        if (this.elements.lines) {
            this.elements.lines.parentElement.style.display = modeConfig.showLines ? 'block' : 'none';
        }
        if (this.elements.level) {
            this.elements.level.parentElement.style.display = modeConfig.showLevel ? 'block' : 'none';
        }
        
        // Add mode-specific elements
        if (modeConfig.customDisplay) {
            this.createModeSpecificUI(modeConfig.customDisplay);
        }
    }
    
    // Create mode-specific UI elements
    createModeSpecificUI(customDisplay) {
        // Remove existing mode UI if any
        if (this.currentModeDisplay) {
            this.currentModeDisplay.remove();
        }
        
        const modeUIContainer = document.createElement('div');
        modeUIContainer.className = 'mode-specific-ui';
        
        // Add timer for Sprint mode
        if (customDisplay.timer) {
            const timerElement = document.createElement('div');
            timerElement.className = 'sprint-timer';
            timerElement.id = 'mode-timer';
            timerElement.textContent = customDisplay.timer;
            modeUIContainer.appendChild(timerElement);
        }
        
        // Add progress bar for Marathon mode
        if (customDisplay.progress) {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'marathon-progress';
            const progressBar = document.createElement('div');
            progressBar.className = 'marathon-progress-bar';
            progressBar.style.width = customDisplay.progress;
            progressContainer.appendChild(progressBar);
            modeUIContainer.appendChild(progressContainer);
        }
        
        // Add objective display for Puzzle mode
        if (customDisplay.objective) {
            const objectiveElement = document.createElement('div');
            objectiveElement.className = 'puzzle-objective';
            objectiveElement.innerHTML = `
                <div class="puzzle-objective-title">Objective</div>
                <div class="puzzle-objective-desc" id="puzzle-objective-text">${customDisplay.objective}</div>
            `;
            modeUIContainer.appendChild(objectiveElement);
        }
        
        // Add pieces counter for Puzzle mode
        if (customDisplay.pieces) {
            const piecesElement = document.createElement('div');
            piecesElement.className = 'puzzle-pieces';
            piecesElement.innerHTML = `
                <div class="puzzle-pieces-title">Pieces Used</div>
                <div class="puzzle-pieces-count" id="puzzle-pieces-count">${customDisplay.pieces}</div>
            `;
            modeUIContainer.appendChild(piecesElement);
        }
        
        // Add puzzle number display
        if (customDisplay.puzzle) {
            const puzzleNumElement = document.createElement('div');
            puzzleNumElement.className = 'puzzle-number';
            puzzleNumElement.innerHTML = `
                <div class="puzzle-number-text">Puzzle ${customDisplay.puzzle}</div>
            `;
            modeUIContainer.appendChild(puzzleNumElement);
        }
        
        // Insert into game area
        const gameBoard = document.querySelector('.game-board');
        if (gameBoard) {
            gameBoard.appendChild(modeUIContainer);
            this.currentModeDisplay = modeUIContainer;
        }
    }
    
    // Update mode-specific UI continuously
    updateModeUI(modeConfig) {
        if (!modeConfig || !modeConfig.customDisplay) return;
        
        // Update timer for Sprint mode
        if (modeConfig.customDisplay.timer) {
            const timerElement = document.getElementById('mode-timer');
            if (timerElement) {
                timerElement.textContent = modeConfig.customDisplay.timer;
            }
        }
        
        // Update progress for Marathon mode
        if (modeConfig.customDisplay.progress) {
            const progressBar = document.querySelector('.marathon-progress-bar');
            if (progressBar) {
                progressBar.style.width = modeConfig.customDisplay.progress;
            }
        }
        
        // Update objective for Puzzle mode
        if (modeConfig.customDisplay.objective) {
            const objectiveElement = document.getElementById('puzzle-objective-text');
            if (objectiveElement) {
                objectiveElement.textContent = modeConfig.customDisplay.objective;
            }
        }
        
        // Update pieces counter for Puzzle mode
        if (modeConfig.customDisplay.pieces) {
            const piecesElement = document.getElementById('puzzle-pieces-count');
            if (piecesElement) {
                piecesElement.textContent = modeConfig.customDisplay.pieces;
            }
        }
    }
    
    // Show mode-specific messages
    showMessage(text, type = 'info', duration = 2000) {
        const messageElement = document.createElement('div');
        messageElement.className = `game-message message-${type}`;
        messageElement.textContent = text;
        messageElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            z-index: 10000;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        `;
        
        document.body.appendChild(messageElement);
        
        setTimeout(() => {
            messageElement.style.opacity = '0';
            messageElement.style.transition = 'opacity 0.5s';
            setTimeout(() => messageElement.remove(), 500);
        }, duration);
    }
    
    // Show puzzle completion
    showPuzzleComplete(puzzle, stars, stats) {
        // Create a more elaborate completion screen
        const overlay = document.createElement('div');
        overlay.className = 'puzzle-complete-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.5s;
        `;
        
        const content = document.createElement('div');
        content.className = 'puzzle-complete-content';
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 136, 0, 0.5);
            max-width: 500px;
        `;
        
        content.innerHTML = `
            <h2 style="color: #ff8800; font-size: 2.5rem; margin-bottom: 20px;">
                🎉 PUZZLE COMPLETE! 🎉
            </h2>
            <h3 style="color: #fff; font-size: 1.5rem; margin-bottom: 15px;">
                Puzzle #${puzzle.id}: ${puzzle.name}
            </h3>
            <div style="font-size: 3rem; margin: 20px 0;">
                ${'⭐'.repeat(stars)}${'☆'.repeat(Math.max(0, 3 - stars))}
            </div>
            <div style="color: #ccc; margin: 20px 0;">
                <p>Lines Cleared: ${stats.linesCleared}</p>
                <p>Pieces Used: ${stats.piecesUsed}</p>
                <p>Time: ${stats.timeElapsed}s</p>
            </div>
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                <button id="next-puzzle-btn" style="
                    background: #ff8800;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    font-weight: bold;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Next Puzzle →</button>
                <button id="retry-puzzle-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Retry</button>
            </div>
        `;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Add event listeners
        const nextBtn = document.getElementById('next-puzzle-btn');
        const retryBtn = document.getElementById('retry-puzzle-btn');
        
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                overlay.remove();
                // Load next puzzle
                if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                    const nextPuzzleId = puzzle.id + 1;
                    console.log(`Loading next puzzle: ${nextPuzzleId}`);
                    
                    // Reset game state first
                    this.game.state = 'playing';
                    this.game.gameMode.isComplete = false;
                    this.game.gameMode.pendingCompletion = false;
                    
                    // Load the next puzzle
                    this.game.gameMode.loadPuzzle(nextPuzzleId);
                    
                    // Clear the grid and reset the game
                    this.game.grid.reset();
                    this.game.gameMode.loadPuzzle(nextPuzzleId); // Load again to apply grid
                    
                    // Continue playing without full restart
                    this.game.currentPiece = null;
                }
            });
        }
        
        if (retryBtn) {
            retryBtn.addEventListener('click', () => {
                overlay.remove();
                // Retry current puzzle
                if (this.game && this.game.gameMode) {
                    // Reset game state
                    this.game.state = 'playing';
                    this.game.gameMode.isComplete = false;
                    this.game.gameMode.pendingCompletion = false;
                    
                    // Reload current puzzle
                    const currentPuzzleId = puzzle.id;
                    this.game.grid.reset();
                    this.game.gameMode.loadPuzzle(currentPuzzleId);
                    this.game.currentPiece = null;
                }
            });
        }
        
        // Auto-remove after 10 seconds if no action
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.remove();
            }
        }, 10000);
    }
    
    // Show puzzle failed
    showPuzzleFailed(puzzle, reason, stats) {
        const message = `Puzzle #${puzzle.id} Failed\n${reason}`;
        this.showMessage(message, 'error', 3000);
    }
    
    // Show AI difficulty selection for Battle mode
    showAIDifficultySelection(callback) {
        const overlay = document.createElement('div');
        overlay.className = 'ai-difficulty-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff0000;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.5);
        `;
        
        const difficulties = [
            { level: 1, name: 'Easy', emoji: '🟢', color: '#4CAF50', desc: 'AI makes frequent mistakes' },
            { level: 2, name: 'Normal', emoji: '🟡', color: '#FFC107', desc: 'Balanced challenge' },
            { level: 3, name: 'Hard', emoji: '🟠', color: '#FF9800', desc: 'Skilled opponent', default: true },
            { level: 4, name: 'Expert', emoji: '🔴', color: '#F44336', desc: 'Very challenging' },
            { level: 5, name: 'Grandmaster', emoji: '🟣', color: '#9C27B0', desc: 'Nearly unbeatable' }
        ];
        
        let selectedLevel = parseInt(localStorage.getItem('battle_ai_difficulty')) || 3;
        
        content.innerHTML = `
            <h2 style="color: #ff0000; text-align: center; margin-bottom: 30px; font-size: 2rem;">
                ⚔️ Choose AI Difficulty
            </h2>
            <div id="difficulty-options" style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;">
                ${difficulties.map(diff => `
                    <button class="difficulty-option" data-level="${diff.level}" style="
                        background: ${diff.level === selectedLevel ? diff.color : 'rgba(255, 255, 255, 0.1)'};
                        color: ${diff.level === selectedLevel ? '#000' : '#fff'};
                        border: 2px solid ${diff.color};
                        padding: 15px 20px;
                        border-radius: 10px;
                        cursor: pointer;
                        transition: all 0.3s;
                        text-align: left;
                        font-size: 1.1rem;
                    ">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <span style="font-size: 1.5rem; margin-right: 10px;">${diff.emoji}</span>
                                <strong>${diff.name}</strong>
                                ${diff.default ? '<span style="opacity: 0.7; font-size: 0.9rem;">(Default)</span>' : ''}
                            </div>
                            <div style="font-size: 0.9rem; opacity: 0.8;">${diff.desc}</div>
                        </div>
                    </button>
                `).join('')}
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="start-battle-btn" style="
                    background: #ff0000;
                    color: white;
                    border: none;
                    padding: 15px 40px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    font-weight: bold;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Start Battle →</button>
                <button id="cancel-battle-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Cancel</button>
            </div>
        `;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Add event listeners
        setTimeout(() => {
            const options = overlay.querySelectorAll('.difficulty-option');
            options.forEach(option => {
                option.addEventListener('click', () => {
                    selectedLevel = parseInt(option.dataset.level);
                    // Update visual selection
                    options.forEach(opt => {
                        const level = parseInt(opt.dataset.level);
                        const diff = difficulties.find(d => d.level === level);
                        if (level === selectedLevel) {
                            opt.style.background = diff.color;
                            opt.style.color = '#000';
                        } else {
                            opt.style.background = 'rgba(255, 255, 255, 0.1)';
                            opt.style.color = '#fff';
                        }
                    });
                });
                
                // Hover effect
                option.addEventListener('mouseenter', () => {
                    if (parseInt(option.dataset.level) !== selectedLevel) {
                        option.style.background = 'rgba(255, 255, 255, 0.2)';
                    }
                });
                option.addEventListener('mouseleave', () => {
                    if (parseInt(option.dataset.level) !== selectedLevel) {
                        option.style.background = 'rgba(255, 255, 255, 0.1)';
                    }
                });
            });
            
            document.getElementById('start-battle-btn').addEventListener('click', () => {
                localStorage.setItem('battle_ai_difficulty', selectedLevel);
                overlay.remove();
                if (callback) callback(selectedLevel);
            });
            
            document.getElementById('cancel-battle-btn').addEventListener('click', () => {
                overlay.remove();
            });
        }, 0);
    }
    
    // Show puzzle selection menu
    async showPuzzleSelection() {
        // Use storage adapter for better compatibility
        const storage = window.TetrisStorage || { 
            load: (key) => Promise.resolve(JSON.parse(localStorage.getItem('tetris_' + key) || 'null'))
        };
        
        const progress = await storage.load('puzzle_progress') || {};
        const completedPuzzles = await storage.load('puzzle_completed') || [];
        const highestUnlocked = progress.highestUnlocked || 1;
        
        const overlay = document.createElement('div');
        overlay.className = 'puzzle-selection-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            overflow-y: auto;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        `;
        
        let html = `
            <h2 style="color: #ff8800; font-size: 2rem; margin-bottom: 20px; text-align: center;">
                🧩 Select Puzzle
            </h2>
            <div style="text-align: center; margin-bottom: 20px; color: #ccc;">
                Progress: ${completedPuzzles.length}/150 puzzles completed
            </div>
        `;
        
        // Create category tabs
        const categories = ['tutorial', 'beginner', 'intermediate', 'advanced', 'expert', 'master', 'grandmaster'];
        html += '<div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">';
        categories.forEach(cat => {
            html += `
                <button class="category-tab" data-category="${cat}" style="
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    text-transform: capitalize;
                ">${cat}</button>
            `;
        });
        html += '</div>';
        
        // Puzzle grid container
        html += '<div id="puzzle-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 20px;"></div>';
        
        // Buttons
        html += `
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                ${progress.currentPuzzleId ? `
                    <button id="resume-puzzle-btn" style="
                        background: #00ff00;
                        color: #000;
                        border: none;
                        padding: 15px 30px;
                        font-size: 1.2rem;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: bold;
                    ">Resume Puzzle #${progress.currentPuzzleId}</button>
                ` : ''}
                <button id="close-selection-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                ">Close</button>
            </div>
        `;
        
        content.innerHTML = html;
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Function to show puzzles for a category
        const showCategory = (category) => {
            const gridElement = document.getElementById('puzzle-grid');
            gridElement.innerHTML = '';
            
            // Get puzzles from puzzleData
            let puzzles = [];
            if (window.PUZZLES) {
                puzzles = window.PUZZLES.filter(p => p.category === category);
            }
            
            // Create puzzle buttons
            puzzles.forEach(puzzle => {
                const isCompleted = completedPuzzles.some(p => p.puzzleId === puzzle.id);
                const isUnlocked = puzzle.id <= highestUnlocked;
                
                const puzzleBtn = document.createElement('button');
                puzzleBtn.style.cssText = `
                    background: ${isCompleted ? '#00ff00' : (isUnlocked ? '#ff8800' : '#444')};
                    color: ${isCompleted ? '#000' : '#fff'};
                    border: 2px solid ${isCompleted ? '#00ff00' : (isUnlocked ? '#ff8800' : '#666')};
                    padding: 15px;
                    border-radius: 10px;
                    cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
                    font-size: 1rem;
                    font-weight: bold;
                    opacity: ${isUnlocked ? 1 : 0.5};
                    position: relative;
                `;
                
                puzzleBtn.innerHTML = `
                    #${puzzle.id}
                    ${isCompleted ? '<span style="position: absolute; top: 2px; right: 2px; font-size: 0.8rem;">✓</span>' : ''}
                `;
                
                puzzleBtn.disabled = !isUnlocked;
                
                if (isUnlocked) {
                    puzzleBtn.addEventListener('click', () => {
                        overlay.remove();
                        // Load selected puzzle
                        if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                            this.game.state = 'playing';
                            this.game.gameMode.isComplete = false;
                            this.game.gameMode.pendingCompletion = false;
                            this.game.gameMode.puzzleId = puzzle.id;
                            this.game.gameMode.loadPuzzle(puzzle.id);
                            this.game.gameMode.saveCurrentProgress();
                        }
                    });
                }
                
                gridElement.appendChild(puzzleBtn);
            });
        };
        
        // Add category tab listeners
        setTimeout(() => {
            const tabs = overlay.querySelectorAll('.category-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Update active tab styling
                    tabs.forEach(t => t.style.background = '#333');
                    tab.style.background = '#ff8800';
                    showCategory(tab.dataset.category);
                });
            });
            
            // Show first category by default
            if (tabs.length > 0) {
                tabs[0].click();
            }
            
            // Resume button
            const resumeBtn = document.getElementById('resume-puzzle-btn');
            if (resumeBtn) {
                resumeBtn.addEventListener('click', () => {
                    overlay.remove();
                    if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                        this.game.state = 'playing';
                        this.game.gameMode.isComplete = false;
                        this.game.gameMode.pendingCompletion = false;
                        this.game.gameMode.loadPuzzle(progress.currentPuzzleId);
                    }
                });
            }
            
            // Close button
            const closeBtn = document.getElementById('close-selection-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    overlay.remove();
                });
            }
        }, 0);
    }
    
    // Show continue prompt for Marathon mode
    showContinuePrompt(state, callback) {
        const promptDiv = document.createElement('div');
        promptDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            z-index: 10000;
            text-align: center;
            color: white;
        `;
        promptDiv.innerHTML = `
            <h3>Continue Previous Game?</h3>
            <p>Lines: ${state.lines} | Level: ${state.level}</p>
            <button id="continue-yes" style="margin: 10px; padding: 10px 20px;">Continue</button>
            <button id="continue-no" style="margin: 10px; padding: 10px 20px;">New Game</button>
        `;
        
        document.body.appendChild(promptDiv);
        
        document.getElementById('continue-yes').onclick = () => {
            promptDiv.remove();
            callback(true);
        };
        document.getElementById('continue-no').onclick = () => {
            promptDiv.remove();
            callback(false);
        };
    }
    
    // Show load game prompt for Zen mode
    showLoadGamePrompt(saves, callback) {
        // Similar to continue prompt
        this.showMessage('Saved games available', 'info', 2000);
    }
    
    // Show power-up effect for Battle mode
    showPowerUp(type, target) {
        this.showMessage(`${type.toUpperCase()} activated!`, 'powerup', 1500);
    }
    
    // Show damage for Battle mode
    showDamage(target, lines) {
        const side = target === 'player' ? 'You' : 'AI';
        this.showMessage(`${side}: ${lines} damage!`, 'damage', 1000);
    }
    
    // Show round result for Battle mode
    showRoundResult(playerWon, round, playerWins, aiWins) {
        const message = playerWon ? 'Round Won!' : 'Round Lost!';
        this.showMessage(`${message}\nScore: ${playerWins}-${aiWins}`, playerWon ? 'success' : 'error', 2000);
    }
    
    // Show match result for Battle mode
    showMatchResult(result) {
        const message = result.won ? 'Victory!' : 'Defeat!';
        this.showMessage(message, result.won ? 'success' : 'error', 3000);
    }
    
    // Update AI grid for Battle mode
    updateAIGrid(grid) {
        // This would update a visual representation of the AI's grid
        // For now, just a placeholder
    }

    // Show pause overlay
    showPauseOverlay() {
        // Check if device supports touch for appropriate message
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const message = isTouchDevice ? 
            'Press P or tap screen to resume' : 
            'Press P to resume';
        this.showOverlay('Game Paused', message);
    }

    // Show game over overlay
    async showGameOverOverlay(stats, specialAchievements = {}, mode = null, modeData = {}) {
        // Get current game mode if not provided
        if (!mode && this.game && this.game.gameMode) {
            mode = this.game.gameMode.name.toLowerCase();
        }
        
        // Create mode-specific message
        let message = `Final Score: ${stats.score.toLocaleString()}\nLines: ${stats.lines}\nLevel: ${stats.level}`;
        
        // Add mode-specific info
        if (mode === 'sprint' && modeData.time) {
            const minutes = Math.floor(modeData.time / 60000);
            const seconds = Math.floor((modeData.time % 60000) / 1000);
            const ms = Math.floor((modeData.time % 1000) / 10);
            message += `\nTime: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
            if (modeData.isNewRecord) {
                message += '\n🏆 NEW RECORD!';
            }
        } else if (mode === 'puzzle' && modeData.puzzleId) {
            message = `Puzzle #${modeData.puzzleId} ${modeData.isVictory ? 'Complete!' : 'Failed'}\n`;
            message += `${'\u2b50'.repeat(modeData.stars || 0)}\n`;
            message += `Score: ${stats.score.toLocaleString()}`;
        } else if (mode === 'marathon') {
            message += `\nProgress: ${stats.lines}/150 lines`;
            if (stats.lines >= 150) {
                message += '\n🎆 MARATHON COMPLETE!';
            }
        } else if (mode === 'zen') {
            const duration = modeData.duration || 0;
            message += `\nDuration: ${Math.floor(duration / 60)}m ${duration % 60}s`;
            message += `\nEfficiency: ${modeData.efficiency || '0'}%`;
        } else if (mode === 'battle') {
            message = modeData.victory ? 'VICTORY!' : 'DEFEAT';
            message += `\nScore: ${stats.score.toLocaleString()}`;
            if (modeData.wins !== undefined) {
                message += `\nWins: ${modeData.wins}`;
            }
        }
        
        const title = mode === 'puzzle' && modeData.isVictory ? 'Victory!' : 'Game Over';
        this.showOverlay(title, message, true);
        
        // Create game over particles
        this.particleSystem.createGameOverEffect();
        
        // Shake animation
        document.querySelector('.game-board').classList.add('animate-shake');
        setTimeout(() => {
            document.querySelector('.game-board').classList.remove('animate-shake');
        }, 500);
        
        // Check if this is a high score and show name input
        try {
            const isHighScore = await this.scoreSaver.isHighScore(stats.score);
            if (isHighScore || mode === 'sprint' || mode === 'puzzle') {
                setTimeout(() => {
                    this.scoreSaver.showNameInput(stats, specialAchievements, mode, modeData);
                }, 1500); // Delay to let game over animation play
            }
        } catch (error) {
            console.warn('Could not check high score status:', error);
            // Show name input anyway if we can't check
            setTimeout(() => {
                this.scoreSaver.showNameInput(stats, specialAchievements, mode, modeData);
            }, 1500);
        }
        
        // Show leaderboard button
        if (this.elements.leaderboardButton) {
            this.elements.leaderboardButton.style.display = 'inline-block';
        }
    }

    // Line clear effects
    showLineClearEffect(clearedLines, isSpecial = false) {
        clearedLines.forEach((lineY, index) => {
            setTimeout(() => {
                this.particleSystem.createLineClearEffect(lineY, isSpecial);
            }, index * 50);
        });
        
        // Special effects for Tetris
        if (clearedLines.length === 4) {
            this.particleSystem.createTetrisEffect();
        }
    }

    // T-Spin effect
    showTSpinEffect(position, isMini = false) {
        this.particleSystem.createTSpinEffect(position, isMini);
        
        // Flash effect
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            canvas.classList.add('animate-tspin');
            setTimeout(() => {
                canvas.classList.remove('animate-tspin');
            }, 300);
        }
    }

    // Combo effect
    showComboEffect(comboCount) {
        if (comboCount > 1) {
            this.particleSystem.createComboEffect(comboCount);
            
            // Update score with combo animation
            if (this.elements.score) {
                this.elements.score.classList.add('animate-combo');
                setTimeout(() => {
                    this.elements.score.classList.remove('animate-combo');
                }, 600);
            }
        }
    }

    // Perfect clear effect
    showPerfectClearEffect() {
        this.particleSystem.createPerfectClearEffect();
    }

    // Update UI theme
    updateTheme(theme) {
        document.documentElement.className = `theme-${theme}`;
    }

    // Cleanup
    destroy() {
        this.particleSystem.destroy();
        this.animations.clear();
    }
}

// Particle System for Visual Effects
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.container = null;
        this.animationId = null;
    }

    init(container) {
        this.container = container;
        this.startAnimation();
    }

    createParticle(x, y, options = {}) {
        const particle = document.createElement('div');
        particle.className = `particle ${options.color || ''}`;
        
        const size = options.size || 4;
        particle.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${size}px;
            height: ${size}px;
            background: ${options.background || 'var(--neon-blue)'};
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        `;
        
        if (this.container) {
            this.container.appendChild(particle);
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, options.duration || 2000);
        }
        
        return particle;
    }

    createLineClearEffect(lineY, isSpecial) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const y = rect.top + (lineY * (rect.height / 20));
        
        for (let i = 0; i < 20; i++) {
            const x = rect.left + (i * (rect.width / 20));
            const particle = this.createParticle(x, y, {
                color: isSpecial ? 'yellow' : 'blue',
                size: Math.random() * 6 + 2,
                duration: 1000 + Math.random() * 1000
            });
            
            // Animate particle
            particle.style.animation = `particle-float ${1 + Math.random()}s ease-out forwards`;
        }
    }

    createTetrisEffect() {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const radius = Math.random() * 100 + 50;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            this.createParticle(x, y, {
                color: ['pink', 'yellow', 'green', 'purple'][Math.floor(Math.random() * 4)],
                size: Math.random() * 8 + 4,
                duration: 2000
            });
        }
    }

    createTSpinEffect(position, isMini) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = rect.left + (position.x * (rect.width / 10));
        const y = rect.top + (position.y * (rect.height / 20));
        
        const particleCount = isMini ? 15 : 30;
        const colors = isMini ? ['purple'] : ['purple', 'pink'];
        
        for (let i = 0; i < particleCount; i++) {
            this.createParticle(
                x + Math.random() * 40 - 20,
                y + Math.random() * 40 - 20,
                {
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 6 + 3,
                    duration: 1500
                }
            );
        }
    }

    createComboEffect(comboCount) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        for (let i = 0; i < comboCount * 10; i++) {
            const x = centerX + (Math.random() - 0.5) * 200;
            const y = centerY + (Math.random() - 0.5) * 200;
            
            this.createParticle(x, y, {
                color: 'yellow',
                size: Math.random() * 8 + 4,
                duration: 1000 + comboCount * 200
            });
        }
    }

    createLevelUpEffect() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        for (let i = 0; i < 100; i++) {
            const angle = (i / 100) * Math.PI * 2;
            const radius = Math.random() * 200 + 100;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            this.createParticle(x, y, {
                color: 'green',
                size: Math.random() * 6 + 2,
                duration: 3000
            });
        }
    }

    createGameOverEffect() {
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            
            this.createParticle(x, y, {
                color: 'red',
                size: Math.random() * 8 + 2,
                duration: 5000
            });
        }
    }

    createPerfectClearEffect() {
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            
            this.createParticle(x, y, {
                color: ['pink', 'yellow', 'green', 'blue', 'purple'][Math.floor(Math.random() * 5)],
                size: Math.random() * 10 + 4,
                duration: 4000
            });
        }
    }

    startAnimation() {
        // Animation loop for particle updates if needed
        const animate = () => {
            this.animationId = requestAnimationFrame(animate);
        };
        animate();
    }

    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        this.particles = [];
    }
}
})();

/* scripts/modals.js */
(function() {
// Modern Tetris - Modal Management System

window.ModalManager = class ModalManager {
    constructor(audioManager) {
        this.audioManager = audioManager;
        this.currentModal = null;
        this.leaderboardManager = new LeaderboardManager();
        this.game = null; // Will be set by game instance
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Mode selector button
        const modeSelectorButton = document.getElementById('mode-selector-button');
        if (modeSelectorButton) {
            modeSelectorButton.addEventListener('click', () => {
                this.showModeSelector();
            });
        }
        
        // Mode cards
        document.querySelectorAll('.mode-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const mode = e.currentTarget.dataset.mode;
                this.selectMode(mode);
            });
        });
        
        // Close mode selector
        const closeModeSelector = document.getElementById('close-mode-selector');
        if (closeModeSelector) {
            closeModeSelector.addEventListener('click', () => {
                this.hideModeSelector();
            });
        }
        
        // Header leaderboard button
        const headerLeaderboardButton = document.getElementById('header-leaderboard-button');
        if (headerLeaderboardButton) {
            headerLeaderboardButton.addEventListener('click', () => {
                this.leaderboardManager.showLeaderboard();
            });
        }

        // Settings button
        const settingsButton = document.getElementById('settings-button');
        if (settingsButton) {
            settingsButton.addEventListener('click', () => {
                this.showSettings();
            });
        }

        // Help button
        const helpButton = document.getElementById('help-button');
        if (helpButton) {
            helpButton.addEventListener('click', () => {
                this.showHelp();
            });
        }

        // Mute button
        const muteButton = document.getElementById('mute-button');
        if (muteButton) {
            muteButton.addEventListener('click', () => {
                this.toggleMute();
            });
        }

        // Close buttons
        document.getElementById('close-settings')?.addEventListener('click', () => {
            this.hideSettings();
        });

        document.getElementById('close-help')?.addEventListener('click', () => {
            this.hideHelp();
        });

        // Settings tabs
        document.querySelectorAll('.settings-tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchSettingsTab(e.target.dataset.tab);
            });
        });

        // Audio controls
        this.initializeAudioControls();

        // Close modals on overlay click
        this.initializeOverlayClicks();

        // Keyboard shortcuts for modals
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                this.closeCurrentModal();
            }
        });
    }

    initializeAudioControls() {
        // Volume sliders
        const masterVolume = document.getElementById('master-volume');
        const musicVolume = document.getElementById('music-volume');
        const sfxVolume = document.getElementById('sfx-volume');

        // Volume value displays
        const masterVolumeValue = document.getElementById('master-volume-value');
        const musicVolumeValue = document.getElementById('music-volume-value');
        const sfxVolumeValue = document.getElementById('sfx-volume-value');

        // Toggle checkboxes
        const musicEnabled = document.getElementById('music-enabled');
        const sfxEnabled = document.getElementById('sfx-enabled');

        if (masterVolume && this.audioManager) {
            const settings = this.audioManager.getSettings();
            
            // Set initial values
            masterVolume.value = settings.masterVolume * 100;
            musicVolume.value = settings.musicVolume * 100;
            sfxVolume.value = settings.sfxVolume * 100;
            musicEnabled.checked = settings.musicEnabled;
            sfxEnabled.checked = settings.sfxEnabled;
            
            // Update display values
            masterVolumeValue.textContent = `${Math.round(settings.masterVolume * 100)}%`;
            musicVolumeValue.textContent = `${Math.round(settings.musicVolume * 100)}%`;
            sfxVolumeValue.textContent = `${Math.round(settings.sfxVolume * 100)}%`;

            // Master volume control
            masterVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setMasterVolume(volume);
                masterVolumeValue.textContent = `${e.target.value}%`;
            });

            // Music volume control
            musicVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setMusicVolume(volume);
                musicVolumeValue.textContent = `${e.target.value}%`;
            });

            // SFX volume control
            sfxVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setSFXVolume(volume);
                sfxVolumeValue.textContent = `${e.target.value}%`;
            });

            // Music toggle
            musicEnabled.addEventListener('change', (e) => {
                if (e.target.checked !== settings.musicEnabled) {
                    this.audioManager.toggleMusic();
                }
            });

            // SFX toggle
            sfxEnabled.addEventListener('change', (e) => {
                if (e.target.checked !== settings.sfxEnabled) {
                    this.audioManager.toggleSFX();
                }
            });
        }
    }

    initializeOverlayClicks() {
        // Settings overlay
        const settingsOverlay = document.getElementById('settings-overlay');
        if (settingsOverlay) {
            settingsOverlay.addEventListener('click', (e) => {
                if (e.target === settingsOverlay) {
                    this.hideSettings();
                }
            });
        }

        // Help overlay
        const helpOverlay = document.getElementById('help-overlay');
        if (helpOverlay) {
            helpOverlay.addEventListener('click', (e) => {
                if (e.target === helpOverlay) {
                    this.hideHelp();
                }
            });
        }
    }

    showSettings() {
        const overlay = document.getElementById('settings-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            this.currentModal = 'settings';
            
            // Clear game inputs
            if (window.tetrisGame?.inputManager) {
                window.tetrisGame.inputManager.reset();
            }

            // Update audio settings display
            this.updateAudioSettingsDisplay();
        }
    }

    hideSettings() {
        const overlay = document.getElementById('settings-overlay');
        if (overlay) {
            overlay.style.display = 'none';
            this.currentModal = null;
        }
    }

    showHelp() {
        const overlay = document.getElementById('help-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            this.currentModal = 'help';
            
            // Clear game inputs
            if (window.tetrisGame?.inputManager) {
                window.tetrisGame.inputManager.reset();
            }

            // Populate quick controls based on device
            this.populateQuickControls();
        }
    }

    hideHelp() {
        const overlay = document.getElementById('help-overlay');
        if (overlay) {
            overlay.style.display = 'none';
            this.currentModal = null;
        }
    }

    closeCurrentModal() {
        if (this.currentModal === 'settings') {
            this.hideSettings();
        } else if (this.currentModal === 'help') {
            this.hideHelp();
        } else if (this.currentModal === 'mode-selector') {
            this.hideModeSelector();
        }
    }
    
    // Mode selector methods
    showModeSelector() {
        const modal = document.getElementById('mode-selector');
        if (modal) {
            modal.style.display = 'flex';
            this.currentModal = 'mode-selector';
        }
    }
    
    hideModeSelector() {
        const modal = document.getElementById('mode-selector');
        if (modal) {
            modal.style.display = 'none';
            this.currentModal = null;
        }
    }
    
    selectMode(modeName) {
        // Set the game mode
        if (this.game) {
            this.game.selectMode(modeName);
            this.hideModeSelector();
            
            // Show puzzle selection menu for puzzle mode
            if (modeName === 'puzzle' && this.game.uiManager) {
                setTimeout(() => {
                    this.game.uiManager.showPuzzleSelection();
                }, 100);
            } 
            // Show AI difficulty selection for battle mode
            else if (modeName === 'battle' && this.game.uiManager) {
                setTimeout(() => {
                    this.game.uiManager.showAIDifficultySelection((difficulty) => {
                        // Restart game with selected difficulty
                        this.game.restart();
                    });
                }, 100);
            } else {
                // Restart game with new mode
                this.game.restart();
            }
        } else {
            // Store for when game is ready
            localStorage.setItem('selected_mode', modeName);
            this.hideModeSelector();
        }
    }
    
    setGame(game) {
        this.game = game;
    }

    switchSettingsTab(tab) {
        // Update tab buttons
        document.querySelectorAll('.settings-tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === tab);
        });

        // Show/hide panels
        const audioPanel = document.getElementById('audio-panel');
        const controlsPanel = document.getElementById('controls-panel');

        if (audioPanel && controlsPanel) {
            audioPanel.style.display = tab === 'audio' ? 'block' : 'none';
            controlsPanel.style.display = tab === 'controls' ? 'block' : 'none';
        }
    }

    toggleMute() {
        if (!this.audioManager) return;

        const settings = this.audioManager.getSettings();
        const muteButton = document.getElementById('mute-button');
        
        if (settings.masterVolume > 0) {
            // Mute
            this.audioManager.setMasterVolume(0);
            muteButton.textContent = '🔇';
            muteButton.classList.add('muted');
            muteButton.title = 'Unmute';
        } else {
            // Unmute
            this.audioManager.setMasterVolume(0.7);
            muteButton.textContent = '🔊';
            muteButton.classList.remove('muted');
            muteButton.title = 'Mute';
        }

        // Update settings display if visible
        this.updateAudioSettingsDisplay();
    }

    updateAudioSettingsDisplay() {
        if (!this.audioManager || this.currentModal !== 'settings') return;

        const settings = this.audioManager.getSettings();
        
        // Update sliders
        const masterVolume = document.getElementById('master-volume');
        const musicVolume = document.getElementById('music-volume');
        const sfxVolume = document.getElementById('sfx-volume');
        
        if (masterVolume) masterVolume.value = settings.masterVolume * 100;
        if (musicVolume) musicVolume.value = settings.musicVolume * 100;
        if (sfxVolume) sfxVolume.value = settings.sfxVolume * 100;

        // Update value displays
        const masterVolumeValue = document.getElementById('master-volume-value');
        const musicVolumeValue = document.getElementById('music-volume-value');
        const sfxVolumeValue = document.getElementById('sfx-volume-value');
        
        if (masterVolumeValue) masterVolumeValue.textContent = `${Math.round(settings.masterVolume * 100)}%`;
        if (musicVolumeValue) musicVolumeValue.textContent = `${Math.round(settings.musicVolume * 100)}%`;
        if (sfxVolumeValue) sfxVolumeValue.textContent = `${Math.round(settings.sfxVolume * 100)}%`;

        // Update toggles
        const musicEnabled = document.getElementById('music-enabled');
        const sfxEnabled = document.getElementById('sfx-enabled');
        
        if (musicEnabled) musicEnabled.checked = settings.musicEnabled;
        if (sfxEnabled) sfxEnabled.checked = settings.sfxEnabled;
    }

    populateQuickControls() {
        const quickControls = document.getElementById('quick-controls');
        if (!quickControls) return;

        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        let controlsHTML = '';

        if (isMobile || isTouchDevice) {
            // Show touch controls for mobile
            controlsHTML = `
                <div class="quick-control-item">
                    <span class="quick-control-key">👆 Tap</span>
                    <span class="quick-control-action">Rotate</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">👈👉 Swipe</span>
                    <span class="quick-control-action">Move</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">👇 Swipe Down</span>
                    <span class="quick-control-action">Drop</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">🤏 Long Press</span>
                    <span class="quick-control-action">Hold</span>
                </div>
            `;
        } else {
            // Show keyboard controls for desktop
            controlsHTML = `
                <div class="quick-control-item">
                    <span class="quick-control-key">←→</span>
                    <span class="quick-control-action">Move</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">↑</span>
                    <span class="quick-control-action">Rotate</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">Space</span>
                    <span class="quick-control-action">Drop</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">C</span>
                    <span class="quick-control-action">Hold</span>
                </div>
            `;
        }

        quickControls.innerHTML = controlsHTML;
    }

    // Check if any modal is active
    isAnyModalActive() {
        return this.currentModal !== null;
    }

    // Update mute button state
    updateMuteButton() {
        if (!this.audioManager) return;

        const settings = this.audioManager.getSettings();
        const muteButton = document.getElementById('mute-button');
        
        if (muteButton) {
            if (settings.masterVolume === 0) {
                muteButton.textContent = '🔇';
                muteButton.classList.add('muted');
                muteButton.title = 'Unmute';
            } else {
                muteButton.textContent = '🔊';
                muteButton.classList.remove('muted');
                muteButton.title = 'Mute';
            }
        }
    }
}

// Add styles for quick controls
const quickControlStyles = `
.quick-control-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.quick-control-key {
    background: var(--neon-green);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: var(--font-primary);
    font-weight: 700;
    font-size: 0.8rem;
    min-width: 40px;
    text-align: center;
    box-shadow: 0 0 6px rgba(57, 255, 20, 0.3);
}

.quick-control-action {
    color: var(--text-primary);
    font-weight: 500;
    font-size: 0.9rem;
}
`;

// Inject styles
if (!document.getElementById('quick-control-styles')) {
    const style = document.createElement('style');
    style.id = 'quick-control-styles';
    style.textContent = quickControlStyles;
    document.head.appendChild(style);
}
})();

/* scripts/game.js */
(function() {
// Modern Tetris - Main Game Engine









window.TetrisGame = class TetrisGame {
    constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state
        this.state = 'menu'; // menu, playing, paused, gameover
        this.grid = new Grid();
        this.pieceBag = new PieceBag();
        
        // Current game pieces
        this.currentPiece = null;
        this.ghostPiece = null;
        this.heldPiece = null;
        this.heldPieceUsed = false;
        this.nextPieces = [];
        
        // Timing
        this.lastTime = 0;
        this.dropTimer = 0;
        this.dropInterval = 1000; // 1 second initially
        
        // Scoring
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.combo = 0;
        
        // Special achievements tracking
        this.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        // Game mechanics
        this.lockDelay = 0;
        this.maxLockDelay = 500;
        this.lastPiecePosition = null;
        
        // Systems
        this.audioManager = new AudioManager();
        this.inputManager = new InputManager(this);
        this.uiManager = new UIManager(this);
        this.modalManager = new ModalManager(this.audioManager);
        this.modalManager.setGame(this); // Connect modal manager to game
        
        // Mode system
        this.modeSelector = new ModeSelector();
        this.gameMode = null;
        this.currentModeName = 'classic';
        
        // Store piece module reference for UI
        this.pieceModule = { Piece, PIECE_TYPES };
        
        // Track game start time for duration calculation
        this.gameStartTime = Date.now();
        
        this.initializeGame();
        this.startGameLoop();
    }

    initializeGame() {
        // Setup canvas
        this.setupCanvas();
        
        // Generate initial next pieces
        for (let i = 0; i < 3; i++) {
            this.nextPieces.push(this.pieceBag.getNextPiece().type);
        }
        
        // Update UI
        this.updateUI();
    }

    setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        // Setup rendering context
        this.ctx.imageSmoothingEnabled = false;
        this.cellSize = rect.width / GRID_WIDTH;
    }

    // Game loop
    startGameLoop() {
        let lastRenderTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;
        
        const gameLoop = (currentTime) => {
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            // Always update game logic
            this.update(deltaTime);
            
            // Limit rendering to 60 FPS for better performance
            if (currentTime - lastRenderTime >= frameTime) {
                this.render();
                lastRenderTime = currentTime;
            }
            
            requestAnimationFrame(gameLoop);
        };
        
        requestAnimationFrame(gameLoop);
    }

    update(deltaTime) {
        if (this.state !== 'playing') {
            this.inputManager.update(deltaTime);
            return;
        }
        
        this.inputManager.update(deltaTime);
        this.updateGameLogic(deltaTime);
    }

    updateGameLogic(deltaTime) {
        // Update game mode first
        if (this.gameMode) {
            const continueGame = this.gameMode.update(deltaTime);
            if (!continueGame) {
                // Mode has ended
                return;
            }
        }
        
        if (!this.currentPiece) {
            this.spawnNextPiece();
            return;
        }
        
        // Update drop timer
        this.dropTimer += deltaTime;
        
        // Natural drop
        if (this.dropTimer >= this.dropInterval) {
            this.dropTimer = 0;
            this.dropPiece();
        }
        
        // Update ghost piece
        this.updateGhostPiece();
        
        // Handle lock delay
        if (this.currentPiece.shouldLock(this.grid)) {
            if (this.currentPiece.updateLockDelay(deltaTime)) {
                this.lockPiece();
            }
        } else {
            this.currentPiece.resetLockDelay();
        }
        
        // Update UI
        this.updateUI();
    }

    // Piece spawning
    spawnNextPiece() {
        if (this.nextPieces.length === 0) return;
        
        // Get next piece type and create piece
        const pieceType = this.nextPieces.shift();
        this.currentPiece = new Piece(pieceType, 3, 0);
        
        // Add new piece to next queue
        this.nextPieces.push(this.pieceBag.getNextPiece().type);
        
        // Reset hold piece usage
        this.heldPieceUsed = false;
        
        // Check game over
        if (this.grid.checkCollision(this.currentPiece)) {
            this.gameOver();
            return;
        }
        
        // Update UI
        this.uiManager.updateNextPieces(this.nextPieces);
    }

    // Piece movement
    movePiece(dx, dy) {
        if (!this.currentPiece || this.state !== 'playing') return false;
        
        const newPiece = this.currentPiece.copy();
        newPiece.move(dx, dy);
        
        if (!this.grid.checkCollision(newPiece)) {
            this.lastPiecePosition = this.currentPiece.copy();
            this.currentPiece = newPiece;
            
            // Play move sound
            this.audioManager.playSFX('move');
            
            // Reset lock delay on successful movement
            if (this.currentPiece.shouldLock(this.grid)) {
                this.currentPiece.resetLockDelay();
            }
            
            return true;
        }
        
        return false;
    }

    // Piece rotation
    rotatePiece(direction = 1) {
        if (!this.currentPiece || this.state !== 'playing') return false;
        
        const rotatedPiece = this.grid.testPieceRotation(this.currentPiece, direction);
        
        if (rotatedPiece) {
            this.lastPiecePosition = this.currentPiece.copy();
            this.currentPiece = rotatedPiece;
            
            // Play rotate sound
            this.audioManager.playSFX('rotate');
            
            return true;
        }
        
        return false;
    }

    // Soft drop
    softDrop() {
        if (this.movePiece(0, 1)) {
            this.score += 1;
            this.dropTimer = 0;
            // Move sound is already played in movePiece
        }
    }

    // Hard drop
    hardDrop() {
        if (!this.currentPiece || this.state !== 'playing') return;
        
        const originalY = this.currentPiece.y;
        let dropDistance = 0;
        
        // Temporarily disable move sound for hard drop
        const originalPlaySFX = this.audioManager.playSFX;
        this.audioManager.playSFX = () => {};
        
        while (this.movePiece(0, 1)) {
            dropDistance++;
        }
        
        // Restore sound and play drop sound
        this.audioManager.playSFX = originalPlaySFX;
        this.audioManager.playSFX('drop');
        
        this.score += dropDistance * 2;
        this.lockPiece();
    }

    // Natural drop
    dropPiece() {
        if (!this.movePiece(0, 1)) {
            // Can't move down, start lock delay
            this.currentPiece.lockDelay = this.currentPiece.lockDelay || 0;
        }
    }

    // Hold piece
    holdPiece() {
        if (!this.currentPiece || this.heldPieceUsed || this.state !== 'playing') return;
        
        if (this.heldPiece) {
            // Swap current and held pieces
            const temp = this.heldPiece;
            this.heldPiece = this.currentPiece.type;
            this.currentPiece = new Piece(temp, 3, 0);
        } else {
            // Hold current piece and spawn next
            this.heldPiece = this.currentPiece.type;
            this.spawnNextPiece();
        }
        
        this.heldPieceUsed = true;
        this.audioManager.playSFX('hold');
        this.uiManager.updateHoldPiece(this.heldPiece ? new Piece(this.heldPiece) : null);
    }

    // Lock piece in place
    lockPiece() {
        if (!this.currentPiece) return;
        
        // Check for T-Spin
        const tspinResult = TSpinDetector.isTSpin(this.currentPiece, this.grid, this.lastPiecePosition);
        
        // Place piece on grid
        this.grid.placePiece(this.currentPiece);
        
        // Notify game mode that a piece was placed
        if (this.gameMode && this.gameMode.handlePiecePlaced) {
            this.gameMode.handlePiecePlaced();
        }
        
        // Play lock sound
        this.audioManager.playSFX('lock');
        
        // Process line clearing immediately and completely
        this.processLineClear(tspinResult);
        
        // Check if the game mode is complete or will be complete
        const isModeComplete = this.gameMode && 
            (this.gameMode.isComplete || this.gameMode.pendingCompletion);
        
        // For puzzle mode, don't check game over if objective is met or pending
        if (isModeComplete) {
            this.currentPiece = null;
            return; // Exit early if mode is complete
        }
        
        // Check game over only if mode is not complete
        if (this.grid.isGameOver()) {
            // For puzzle mode, give it one last chance to check objective
            if (this.gameMode && this.gameMode.name === 'Puzzle') {
                // Final check for objective completion
                if (this.gameMode.checkObjectiveComplete && this.gameMode.checkObjectiveComplete()) {
                    this.gameMode.isComplete = true;
                    this.gameMode.pendingCompletion = true;
                    this.currentPiece = null;
                    return;
                }
            }
            this.gameOver();
        } else {
            this.currentPiece = null;
        }
    }

    // Process line clearing with proper sequencing
    processLineClear(tspinResult) {
        // Get lines to clear BEFORE clearing them for animation
        const linesToClear = this.grid.getCompletedLines();
        
        if (linesToClear.length === 0) {
            return; // No lines to clear
        }
        
        // Clear the lines from the grid immediately using the detected lines
        const actualCleared = this.grid.clearLines(linesToClear);
        
        // Track special achievements
        this.updateSpecialAchievements(tspinResult, actualCleared);
        
        // Show effects and play sounds using original line positions
        this.playLineClearEffects(actualCleared, linesToClear, tspinResult);
        
        // Calculate and update score
        this.calculateScore(actualCleared, tspinResult);
        
        // Check for perfect clear bonus
        if (this.grid.isPerfectClear() && actualCleared > 0) {
            this.specialAchievements.perfectClears++;
            this.uiManager.showPerfectClearEffect();
            this.score += 10000 * this.level; // Bonus for perfect clear
        }
        
        // Update level after processing everything
        this.updateLevel();
    }

    // Update special achievements tracking
    updateSpecialAchievements(tspinResult, clearedLines) {
        // Track T-Spins
        if (tspinResult.type === 'tspin') {
            if (tspinResult.mini) {
                this.specialAchievements.tspinMinis++;
            } else {
                this.specialAchievements.tspins++;
            }
        }
        
        if (clearedLines === 4) {
            this.specialAchievements.tetris++;
        }
    }

    // Play line clear effects and sounds
    playLineClearEffects(clearedLines, originalLinePositions, tspinResult) {
        if (clearedLines > 0) {
            // Show visual effects using original line positions
            this.uiManager.showLineClearEffect(originalLinePositions, clearedLines === 4);
            
            // Play appropriate sound
            if (clearedLines === 4) {
                this.audioManager.playSFX('tetris');
            } else {
                this.audioManager.playSFX('lineClear');
            }
        }
        
        if (tspinResult.type === 'tspin') {
            this.audioManager.playSFX('tspin');
            this.uiManager.showTSpinEffect(this.currentPiece, tspinResult.mini);
        }
    }

    // Calculate score based on lines cleared and special moves
    calculateScore(linesCleared, tspinResult) {
        // Delegate to game mode if available
        if (this.gameMode) {
            const specialClear = {
                type: tspinResult.type,
                mini: tspinResult.mini,
                perfectClear: this.grid.isPerfectClear()
            };
            this.gameMode.handleLineClears(linesCleared, specialClear);
            return;
        }
        
        // Fallback to default scoring (for backward compatibility)
        if (linesCleared === 0) {
            this.combo = 0;
            return;
        }
        
        let baseScore = 0;
        let multiplier = this.level;
        
        // Base scoring
        switch (linesCleared) {
            case 1:
                baseScore = tspinResult.type === 'tspin' ? 
                    (tspinResult.mini ? 200 : 800) : 100;
                break;
            case 2:
                baseScore = tspinResult.type === 'tspin' ? 1200 : 300;
                break;
            case 3:
                baseScore = tspinResult.type === 'tspin' ? 1600 : 500;
                break;
            case 4:
                baseScore = 800; // Tetris
                break;
        }
        
        // Combo bonus
        this.combo++;
        if (this.combo > 1) {
            baseScore += 50 * this.combo * multiplier;
            this.uiManager.showComboEffect(this.combo);
            this.specialAchievements.combos++;
        }
        
        // Perfect clear bonus
        if (this.grid.isPerfectClear()) {
            baseScore *= 10;
        }
        
        this.score += baseScore * multiplier;
        this.lines += linesCleared;
    }

    // Update game level
    updateLevel() {
        const newLevel = Math.floor(this.lines / 10) + 1;
        if (newLevel > this.level) {
            this.level = newLevel;
            this.audioManager.playSFX('levelUp');
            // Update music tempo based on new level
            this.audioManager.setGameLevel(this.level);
            this.updateDropSpeed();
        }
    }

    // Update drop speed based on level
    updateDropSpeed() {
        // Standard Tetris drop speed formula
        if (this.level <= 8) {
            this.dropInterval = (48 - 5 * this.level) * 16.67; // ~60 FPS
        } else if (this.level <= 10) {
            this.dropInterval = (8 - this.level) * 16.67;
        } else if (this.level <= 12) {
            this.dropInterval = 16.67; // 1 frame
        } else if (this.level <= 15) {
            this.dropInterval = 13.33; // ~3/4 frame
        } else if (this.level <= 18) {
            this.dropInterval = 8.33; // 1/2 frame
        } else if (this.level <= 28) {
            this.dropInterval = 6.67; // 1/3 frame
        } else {
            this.dropInterval = 3.33; // 1/5 frame
        }
    }

    // Update ghost piece
    updateGhostPiece() {
        if (this.currentPiece) {
            this.ghostPiece = this.grid.getGhostPosition(this.currentPiece);
        } else {
            this.ghostPiece = null;
        }
    }

    // Update UI elements
    updateUI() {
        this.uiManager.updateStats({
            score: this.score,
            lines: this.lines,
            level: this.level
        });
    }

    // Select and initialize game mode
    selectMode(modeName) {
        this.currentModeName = modeName || 'classic';
        this.gameMode = this.modeSelector.createModeInstance(this.currentModeName, this);
        
        if (this.gameMode) {
            this.gameMode.initialize();
            this.uiManager.updateModeDisplay(this.gameMode.getModeUI());
            return true;
        }
        return false;
    }
    
    // Game state management
    async start() {
        // Initialize game mode if not already done
        if (!this.gameMode) {
            this.selectMode('classic');
        }
        
        this.state = 'playing';
        this.gameStartTime = Date.now(); // Reset game start time
        this.uiManager.hideOverlay();
        
        // Start the game mode
        if (this.gameMode) {
            this.gameMode.start();
        }
        
        // Ensure audio context is ready
        await this.audioManager.resumeAudioContext();
        
        // Set initial game level for music tempo
        this.audioManager.setGameLevel(this.level);
        
        // Start background music
        this.audioManager.startBackgroundMusic();
        
        this.spawnNextPiece();
    }

    pause() {
        if (this.state === 'playing') {
            this.state = 'paused';
            this.uiManager.showPauseOverlay();
        }
    }

    resume() {
        if (this.state === 'paused') {
            this.state = 'playing';
            this.uiManager.hideOverlay();
        }
    }

    togglePause() {
        if (this.state === 'playing') {
            this.pause();
        } else if (this.state === 'paused') {
            this.resume();
        }
    }

    restart() {
        // Reset game state
        this.grid.reset();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        // Reset music tempo to level 1
        this.audioManager.setGameLevel(1);
        this.combo = 0;
        this.dropTimer = 0;
        
        // Reset special achievements
        this.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        this.updateDropSpeed();
        
        this.currentPiece = null;
        this.ghostPiece = null;
        this.heldPiece = null;
        this.heldPieceUsed = false;
        
        // Reset piece bag
        this.pieceBag = new PieceBag();
        this.nextPieces = [];
        for (let i = 0; i < 3; i++) {
            this.nextPieces.push(this.pieceBag.getNextPiece().type);
        }
        
        // Update UI
        this.uiManager.updateNextPieces(this.nextPieces);
        this.uiManager.updateHoldPiece(null);
        
        this.start();
    }

    gameOver() {
        this.state = 'gameover';
        
        // Stop background music and play game over sound
        this.audioManager.stopBackgroundMusic();
        this.audioManager.playSFX('gameOver');
        
        // Prepare final stats
        const finalStats = {
            score: this.score,
            lines: this.lines,
            level: this.level
        };
        
        // Prepare special achievements for database
        const dbAchievements = {
            tspins: this.specialAchievements.tspins + this.specialAchievements.tspinMinis,
            combos: this.specialAchievements.combos,
            tetris: this.specialAchievements.tetris,
            perfectClears: this.specialAchievements.perfectClears
        };
        
        // Set game start time for score saver
        this.uiManager.scoreSaver.setGameStartTime(this.gameStartTime);
        
        this.uiManager.showGameOverOverlay(finalStats, dbAchievements);
    }

    handleConfirm() {
        if (this.state === 'menu' || this.state === 'gameover') {
            this.start();
        }
    }

    // Rendering
    render() {
        this.clearCanvas();
        
        if (this.state === 'playing' || this.state === 'paused') {
            this.renderGrid();
            this.renderGhostPiece();
            this.renderCurrentPiece();
            this.renderGridLines();
            
            // Update mode-specific UI
            if (this.gameMode && this.uiManager) {
                this.uiManager.updateModeUI(this.gameMode.getModeUI());
            }
        }
    }

    clearCanvas() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    renderGrid() {
        const gridData = this.grid.getRenderData();
        
        gridData.forEach(cell => {
            this.renderCell(cell.x, cell.y, cell.color, false);
        });
    }

    renderCurrentPiece() {
        if (!this.currentPiece) return;
        
        const blocks = this.currentPiece.getBlocks();
        blocks.forEach(block => {
            if (block.y >= 4) { // Only render visible blocks
                this.renderCell(block.x, block.y - 4, block.color, false);
            }
        });
    }

    renderGhostPiece() {
        if (!this.ghostPiece) return;
        
        const blocks = this.ghostPiece.getBlocks();
        blocks.forEach(block => {
            if (block.y >= 4) { // Only render visible blocks
                this.renderCell(block.x, block.y - 4, block.color, true);
            }
        });
    }

    renderCell(x, y, color, isGhost = false) {
        const cellX = x * this.cellSize;
        const cellY = y * this.cellSize;
        
        this.ctx.save();
        
        if (isGhost) {
            this.ctx.globalAlpha = 0.3;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(cellX + 1, cellY + 1, this.cellSize - 2, this.cellSize - 2);
        } else {
            // Filled block with glow effect
            this.ctx.fillStyle = color;
            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
            
            // Inner highlight
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.fillRect(cellX + 1, cellY + 1, this.cellSize - 2, 2);
            this.ctx.fillRect(cellX + 1, cellY + 1, 2, this.cellSize - 2);
            
            // Border
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(cellX, cellY, this.cellSize, this.cellSize);
        }
        
        this.ctx.restore();
    }

    renderGridLines() {
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.lineWidth = 0.5;
        
        // Vertical lines
        for (let x = 0; x <= GRID_WIDTH; x++) {
            const lineX = x * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(lineX, 0);
            this.ctx.lineTo(lineX, GRID_HEIGHT * this.cellSize);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y <= GRID_HEIGHT; y++) {
            const lineY = y * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(0, lineY);
            this.ctx.lineTo(GRID_WIDTH * this.cellSize, lineY);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
}

// Initialize game when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.tetrisGame = new TetrisGame();
});
})();

// Initialize the game when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('🎮 Initializing standalone Tetris...');
    
    // Set file mode context
    window.TetrisContext = {
        isFileProtocol: true,
        isLocalhost: false,
        hasServiceWorker: false,
        mode: 'standalone'
    };
    
    // Initialize game
    if (window.TetrisExports.Game) {
        window.game = new window.TetrisExports.Game();
    } else if (window.Game) {
        window.game = new window.Game();
    }
    
    console.log('✅ Standalone Tetris ready!');
});

</script>
</body>
</html>