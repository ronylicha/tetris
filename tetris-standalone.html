<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Modern Tetris</title>
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDwhLS0gTmVvbiBnbG93IGVmZmVjdCBmb3IgZmF2aWNvbiAtLT4KICAgIDxmaWx0ZXIgaWQ9ImZhdmljb25HbG93IiB4PSItMjAlIiB5PSItMjAlIiB3aWR0aD0iMTQwJSIgaGVpZ2h0PSIxNDAlIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiByZXN1bHQ9ImNvbG9yZWRCbHVyIi8+CiAgICAgIDxmZU1lcmdlPiAKICAgICAgICA8ZmVNZXJnZU5vZGUgaW49ImNvbG9yZWRCbHVyIi8+CiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJTb3VyY2VHcmFwaGljIi8+CiAgICAgIDwvZmVNZXJnZT4KICAgIDwvZmlsdGVyPgogICAgCiAgICA8IS0tIEJhY2tncm91bmQgZ3JhZGllbnQgLS0+CiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9ImJnR3JhZGllbnQiIGN4PSI1MCUiIGN5PSI1MCUiIHI9IjUwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMxYTFhMmU7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzBmMGYyMztzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgPC9kZWZzPgogIAogIDwhLS0gQmFja2dyb3VuZCAtLT4KICA8cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9InVybCgjYmdHcmFkaWVudCkiIHJ4PSI4IiByeT0iOCIvPgogIAogIDwhLS0gQ2xhc3NpYyBULXBpZWNlIGluIHRoZSBjZW50ZXIgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAsIDE2KSI+CiAgICA8IS0tIFRvcCBob3Jpem9udGFsIGJhciAtLT4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMTYiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8IS0tIFZlcnRpY2FsIHN0ZW0gLS0+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMzOUZGMTQiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIyNCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI2Zhdmljb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBTbWFsbCBhY2NlbnQgYmxvY2tzIGZvciBkZXRhaWwgLS0+CiAgPGcgb3BhY2l0eT0iMC43Ij4KICAgIDwhLS0gVG9wIGxlZnQgLS0+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDBGRkZGIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgICA8IS0tIFRvcCByaWdodCAtLT4KICAgIDxyZWN0IHg9IjUyIiB5PSI4IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgICA8IS0tIEJvdHRvbSBsZWZ0IC0tPgogICAgPHJlY3QgeD0iOCIgeT0iNTIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNmYXZpY29uR2xvdykiIHJ4PSIwLjUiLz4KICAgIDwhLS0gQm90dG9tIHJpZ2h0IC0tPgogICAgPHJlY3QgeD0iNTIiIHk9IjUyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIiByeD0iMC41Ii8+CiAgPC9nPgogIAogIDwhLS0gQm9yZGVyIGdsb3cgLS0+CiAgPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSJub25lIiBzdHJva2U9InJnYmEoNTcsIDI1NSwgMjAsIDAuNCkiIHN0cm9rZS13aWR0aD0iMSIgcng9IjgiIHJ5PSI4IiBmaWx0ZXI9InVybCgjZmF2aWNvbkdsb3cpIi8+Cjwvc3ZnPg==">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
    
    <!-- PWA Manifest -->
    
    <meta name="theme-color" content="#0f0f23">
    <meta name="description" content="Modern Tetris game with neon graphics and 90s-style music">
    
    
    
    
    
    
<style>

/* styles/main.css */
/* Modern Tetris - Main Styles */

:root {
    --primary-bg: #0a0a0a;
    --secondary-bg: #1a1a2e;
    --accent-bg: #16213e;
    --glass-bg: rgba(255, 255, 255, 0.1);
    
    --neon-blue: #00d4ff;
    --neon-purple: #9d4edd;
    --neon-pink: #ff006e;
    --neon-green: #39ff14;
    --neon-yellow: #ffff00;
    --neon-orange: #ff8500;
    --neon-red: #ff0040;
    
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-accent: var(--neon-blue);
    
    --shadow-glow: 0 0 20px rgba(0, 212, 255, 0.3);
    --shadow-strong: 0 0 30px rgba(0, 212, 255, 0.5);
    --border-radius: 12px;
    
    --font-primary: 'Orbitron', monospace;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-primary);
    background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 50%, var(--accent-bg) 100%);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
    pointer-events: none;
    z-index: -1;
}

.app {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}

/* Home Screen Styles */
.home-screen {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.home-container {
    width: 100%;
    max-width: 1200px;
    text-align: center;
}

.home-header {
    margin-bottom: 50px;
}

.home-logo {
    width: 200px;
    height: auto;
    filter: drop-shadow(0 0 20px rgba(57, 255, 20, 0.6));
    animation: pulse-glow 2s ease-in-out infinite;
    margin-bottom: 20px;
}

.home-title {
    font-size: clamp(3rem, 8vw, 5rem);
    font-weight: 900;
    letter-spacing: 0.3em;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-pink));
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradient-shift 3s ease-in-out infinite;
    margin: 20px 0;
}

.home-subtitle {
    font-size: 1.2rem;
    color: var(--text-secondary);
    letter-spacing: 0.1em;
    text-transform: uppercase;
}

.home-modes {
    margin-bottom: 40px;
}

.home-mode-card {
    cursor: pointer;
    transition: all 0.3s ease;
}

.home-mode-card:hover {
    transform: translateY(-5px) scale(1.05);
    border-color: var(--neon-blue);
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
}

.home-actions {
    display: flex;
    gap: 20px;
    justify-content: center;
    flex-wrap: wrap;
}

/* Game Screen Header - Minimal */
.game-header {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    z-index: 100;
}

.btn-game-icon {
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 38px;
    height: 38px;
    color: var(--text-primary);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-game-icon:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-glow);
    transform: scale(1.1);
}

/* Legacy Header Styles - for reference */
.header {
    margin-bottom: 30px;
    z-index: 10;
}

.header-top {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.header-controls {
    display: flex;
    gap: 10px;
}

.btn-icon {
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: var(--text-primary);
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-icon:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-glow);
    transform: translateY(-2px);
}

.btn-icon.muted {
    color: var(--neon-red);
    border-color: var(--neon-red);
}

/* Button Styles */
.btn-primary, .btn-secondary {
    padding: 12px 30px;
    border: 2px solid var(--neon-blue);
    border-radius: 25px;
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    color: var(--text-primary);
    font-family: var(--font-primary);
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.btn-primary {
    background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 30px rgba(0, 212, 255, 0.5);
}

.btn-secondary {
    background: var(--glass-bg);
}

.btn-secondary:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
}

/* Game Screen Styles */
.game-screen {
    width: 100%;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height */
    max-height: 100vh;
    max-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 10px;
    padding-top: 50px; /* Reduced space for header buttons */
    padding-bottom: env(safe-area-inset-bottom); /* Safe area for iOS */
    overflow: hidden;
    box-sizing: border-box;
}

/* Logo Styles */
.logo-container {
    display: flex;
    align-items: center;
    gap: 15px;
}

.logo {
    height: 60px;
    width: auto;
    filter: drop-shadow(0 0 10px rgba(57, 255, 20, 0.5));
    transition: all 0.3s ease;
}

.logo:hover {
    filter: drop-shadow(0 0 15px rgba(57, 255, 20, 0.8));
    transform: scale(1.05);
}

.title {
    font-size: clamp(2rem, 6vw, 4rem);
    font-weight: 900;
    letter-spacing: 0.2em;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-pink));
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: var(--shadow-glow);
    animation: gradient-shift 3s ease-in-out infinite;
    margin: 0;
}

/* Screen reader only class */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.controls-hint {
    display: flex;
    gap: 20px;
    justify-content: center;
    flex-wrap: wrap;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.controls-hint span {
    padding: 8px 16px;
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    transition: all 0.3s ease;
}

.controls-hint span:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-glow);
}

/* Game Container */
.game-container {
    display: grid;
    grid-template-columns: minmax(10em, 1fr) minmax(18em, 22em) minmax(10em, 1fr);
    gap: 1.2em;
    align-items: start;
    max-width: 70em;
    width: 100%;
    max-height: calc(100vh - 70px);
    margin: 0 auto;
    padding: 0 0.8em;
}

/* Sidebars */
.game-sidebar {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-height: calc(100vh - 80px);
}

.hold-area, .next-area, .stats,
.hold-stats-card, .next-pieces-card, .info-panel, .next-panel {
    background: var(--glass-bg);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: var(--border-radius);
    padding: 15px;
    box-shadow: var(--shadow-glow);
    position: relative;
    overflow: hidden;
}


/* Show desktop sidebars by default */
.game-sidebar {
    display: block;
}

/* Hide mobile panels by default */
.info-panel, .next-panel {
    display: none;
}

.hold-area::before, .next-area::before, .stats::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    border-radius: var(--border-radius);
    z-index: -1;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.hold-area:hover::before, .next-area:hover::before, .stats:hover::before {
    opacity: 0.3;
}

.hold-area h3, .next-area h3 {
    color: var(--text-accent);
    font-size: 0.95rem;
    font-weight: 700;
    text-align: center;
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.hold-piece, .next-piece {
    width: 70px;
    height: 70px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: all 0.3s ease;
}

.next-pieces {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.next-piece:first-child {
    transform: scale(1.1);
    border-color: var(--neon-blue);
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

/* Stats */
.stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.stat:last-child {
    border-bottom: none;
}

.stat-label {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.stat-value {
    color: var(--neon-blue);
    font-weight: 700;
    font-size: 1.2rem;
    text-shadow: 0 0 10px currentColor;
}

/* Game Board */
.game-board {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    min-width: 20em;
    min-height: 40em;
    max-height: calc(100vh - 10em);
}

#game-canvas {
    background: linear-gradient(180deg, 
        rgba(10, 10, 10, 0.95) 0%, 
        rgba(26, 26, 46, 0.95) 50%, 
        rgba(22, 33, 62, 0.95) 100%);
    backdrop-filter: blur(15px);
    border: 2px solid rgba(0, 212, 255, 0.3);
    border-radius: var(--border-radius);
    box-shadow: 
        var(--shadow-strong),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    width: 18em;
    height: 36em;
    max-width: 100%;
    max-height: calc(100vh - 80px);
    display: block;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
}

/* Game Overlay */
.game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--border-radius);
    z-index: 100;
}

.overlay-content {
    text-align: center;
    padding: 40px;
}

#overlay-title {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--text-accent);
    margin-bottom: 20px;
    text-shadow: var(--shadow-glow);
}

#overlay-message {
    font-size: 1.2rem;
    color: var(--text-secondary);
    margin-bottom: 30px;
}

/* Buttons */
.btn-primary, .btn-secondary {
    padding: 15px 30px;
    font-family: var(--font-primary);
    font-size: 1rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 0 10px;
    position: relative;
    overflow: hidden;
}

.btn-primary {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    color: white;
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.6);
}

.btn-secondary {
    background: transparent;
    color: var(--text-secondary);
    border: 2px solid var(--text-secondary);
}

.btn-secondary:hover {
    color: var(--text-primary);
    border-color: var(--text-primary);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
}

/* Particles Container */
.particles-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
}

/* Hidden by default */
.game-overlay.hidden {
    display: none;
}

/* Player Name Input Modal */
.name-input-overlay, .leaderboard-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    animation: fade-in 0.3s ease-out;
}

.name-input-content, .leaderboard-content {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--border-radius);
    padding: 30px;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: var(--shadow-strong);
    position: relative;
}

.name-input-content h2, .leaderboard-content h2 {
    color: var(--neon-blue);
    font-size: 2rem;
    margin-bottom: 15px;
    text-shadow: var(--shadow-glow);
}

.name-input-content p {
    color: var(--text-secondary);
    font-size: 1.1rem;
    margin-bottom: 25px;
}

.input-group {
    margin-bottom: 25px;
}

#player-name-input {
    width: 100%;
    padding: 15px 20px;
    font-family: var(--font-primary);
    font-size: 1.1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    color: var(--text-primary);
    text-align: center;
    margin-bottom: 20px;
    transition: all 0.3s ease;
}

#player-name-input:focus {
    outline: none;
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    background: rgba(255, 255, 255, 0.15);
}

#player-name-input::placeholder {
    color: var(--text-secondary);
    opacity: 0.7;
}

.input-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.score-summary {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 25px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--border-radius);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.score-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.score-item span:first-child {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.score-item span:last-child {
    color: var(--neon-blue);
    font-size: 1.4rem;
    font-weight: 700;
    text-shadow: 0 0 10px currentColor;
}

/* Leaderboard Mode Selector */
.mode-selector-container {
    margin: 0 25px 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    box-shadow: 
        inset 0 0 30px rgba(0, 0, 0, 0.3),
        0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
}

.mode-selector-container::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-blue));
    border-radius: 12px;
    opacity: 0.15;
    z-index: -1;
    animation: gradient-shift 3s ease infinite;
}

.mode-selector {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
}

.mode-select-btn {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.08));
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.12);
    border-radius: 10px;
    padding: 8px 14px;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    position: relative;
    overflow: hidden;
}

.mode-select-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: radial-gradient(circle, rgba(0, 212, 255, 0.3), transparent);
    transform: translate(-50%, -50%);
    transition: width 0.4s, height 0.4s;
}

.mode-select-btn:hover {
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(157, 78, 221, 0.1));
    transform: translateY(-3px) scale(1.05);
    box-shadow: 
        0 8px 20px rgba(0, 212, 255, 0.25),
        inset 0 0 15px rgba(255, 255, 255, 0.05);
    border-color: rgba(0, 212, 255, 0.4);
}

.mode-select-btn:hover::before {
    width: 200%;
    height: 200%;
}

.mode-select-btn.active {
    background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
    color: white;
    border-color: transparent;
    box-shadow: 
        0 0 25px rgba(0, 212, 255, 0.6),
        inset 0 0 10px rgba(255, 255, 255, 0.2);
    font-weight: 600;
    transform: scale(1.05);
    animation: active-pulse 2s ease infinite;
}

@keyframes active-pulse {
    0%, 100% {
        box-shadow: 
            0 0 25px rgba(0, 212, 255, 0.6),
            inset 0 0 10px rgba(255, 255, 255, 0.2);
    }
    50% {
        box-shadow: 
            0 0 35px rgba(0, 212, 255, 0.8),
            inset 0 0 15px rgba(255, 255, 255, 0.3);
    }
}

@keyframes gradient-shift {
    0%, 100% {
        transform: rotate(0deg);
    }
    50% {
        transform: rotate(180deg);
    }
}

.mode-icon {
    font-size: 1.1rem;
}

/* Mode-specific leaderboard entries */
.entry-time,
.entry-puzzle,
.entry-checkpoint,
.entry-duration,
.entry-wins {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 3px;
}

.entry-puzzle {
    color: #ff8800;
}

.entry-time {
    color: #ff00ff;
    font-weight: bold;
}

/* Leaderboard Styles */
.leaderboard-content {
    max-width: 700px;
    max-height: 80vh;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(18, 18, 24, 0.98), rgba(29, 29, 41, 0.98));
    border-radius: 15px;
    box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.leaderboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 20px 25px 15px;
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(157, 78, 221, 0.1) 100%);
    border-bottom: 3px solid;
    border-image: linear-gradient(90deg, var(--neon-blue), var(--neon-purple)) 1;
    border-radius: 15px 15px 0 0;
    position: relative;
}

.leaderboard-header h2 {
    font-size: 1.8rem;
    color: var(--neon-gold);
    text-shadow: 
        0 0 10px rgba(255, 215, 0, 0.5),
        0 0 20px rgba(255, 215, 0, 0.3);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
}

.btn-close {
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: var(--text-secondary);
    font-size: 1.8rem;
    font-weight: bold;
    cursor: pointer;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.btn-close:hover {
    color: var(--neon-red);
    background: rgba(255, 89, 94, 0.1);
    border-color: var(--neon-red);
    transform: rotate(90deg);
    box-shadow: 0 0 15px rgba(255, 89, 94, 0.3);
}

.leaderboard-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 25px;
    padding: 5px;
}

.tab-button {
    flex: 1;
    padding: 10px 20px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-primary);
    font-weight: 600;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.tab-button.active {
    background: var(--neon-blue);
    color: white;
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

.tab-button:not(.active):hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
}

.leaderboard-list {
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
    scrollbar-width: thin;
    scrollbar-color: var(--neon-blue) rgba(255, 255, 255, 0.1);
}

.leaderboard-list::-webkit-scrollbar {
    width: 8px;
}

.leaderboard-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
}

.leaderboard-list::-webkit-scrollbar-thumb {
    background: var(--neon-blue);
    border-radius: 4px;
    opacity: 0.5;
}

.leaderboard-list::-webkit-scrollbar-thumb:hover {
    background: var(--neon-purple);
    opacity: 0.8;
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 50px 1fr 100px 60px 60px;
    gap: 15px;
    align-items: center;
    padding: 15px 20px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: var(--border-radius);
    margin-bottom: 10px;
    transition: all 0.3s ease;
}

.leaderboard-entry:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: var(--neon-blue);
    transform: translateX(5px);
}

/* Special styling for top 3 */
.leaderboard-entry:nth-child(1) .entry-rank {
    color: #ffd700;
    text-shadow: 0 0 15px #ffd700;
}

.leaderboard-entry:nth-child(2) .entry-rank {
    color: #c0c0c0;
    text-shadow: 0 0 15px #c0c0c0;
}

.leaderboard-entry:nth-child(3) .entry-rank {
    color: #cd7f32;
    text-shadow: 0 0 15px #cd7f32;
}

.leaderboard-entry:nth-child(1) {
    border-color: rgba(255, 215, 0, 0.3);
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
}

.leaderboard-entry:nth-child(2) {
    border-color: rgba(192, 192, 192, 0.3);
    background: linear-gradient(135deg, rgba(192, 192, 192, 0.05) 0%, transparent 100%);
}

.leaderboard-entry:nth-child(3) {
    border-color: rgba(205, 127, 50, 0.3);
    background: linear-gradient(135deg, rgba(205, 127, 50, 0.05) 0%, transparent 100%);
}

.entry-rank {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--neon-blue);
    text-align: center;
}

.entry-rank.gold { color: var(--neon-yellow); }
.entry-rank.silver { color: #c0c0c0; }
.entry-rank.bronze { color: #cd7f32; }

.entry-name {
    font-weight: 600;
    color: var(--text-primary);
}

.entry-score {
    font-weight: 700;
    color: var(--neon-green);
    text-align: right;
}

.entry-lines, .entry-level {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-align: center;
}

.loading {
    text-align: center;
    color: var(--text-secondary);
    padding: 40px;
    font-size: 1.1rem;
}

.error-message {
    text-align: center;
    color: var(--neon-red);
    padding: 20px;
    background: rgba(255, 0, 64, 0.1);
    border: 1px solid rgba(255, 0, 64, 0.3);
    border-radius: var(--border-radius);
    margin: 10px 0;
}

/* Settings Modal Styles */
.settings-overlay, .help-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    animation: fade-in 0.3s ease-out;
}

.settings-content, .help-content {
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--border-radius);
    padding: 30px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: var(--shadow-strong);
    position: relative;
}

.settings-header, .help-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
}

.settings-header h2, .help-header h2 {
    color: var(--neon-blue);
    font-size: 1.8rem;
    margin: 0;
    text-shadow: var(--shadow-glow);
}

.settings-tabs, .help-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 25px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 25px;
    padding: 5px;
}

.settings-tab-button, .help-tab {
    flex: 1;
    padding: 12px 20px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-primary);
    font-weight: 600;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.settings-tab-button.active, .help-tab.active {
    background: var(--neon-blue);
    color: white;
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

.settings-tab-button:not(.active):hover, .help-tab:not(.active):hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
}

/* Help Modal Specific Styles */
.help-tab-content {
    animation: fade-in 0.3s ease-out;
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.control-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.control-item kbd {
    background: var(--secondary-bg);
    color: var(--neon-blue);
    padding: 5px 10px;
    border-radius: 4px;
    font-weight: bold;
    border: 1px solid rgba(0, 212, 255, 0.3);
    min-width: 40px;
    text-align: center;
}

.touch-controls-list {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-top: 20px;
}

.touch-control {
    display: flex;
    align-items: center;
    gap: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.gesture-icon {
    font-size: 2rem;
    min-width: 50px;
    text-align: center;
}

.gesture-info strong {
    display: block;
    color: var(--neon-blue);
    margin-bottom: 5px;
}

.scoring-table {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
}

.score-row {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.score-row:last-child {
    border-bottom: none;
}

.score-value {
    color: var(--neon-green);
    font-weight: bold;
}

.special-moves-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 15px;
}

.special-move {
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.special-move strong {
    color: var(--neon-purple);
    margin-bottom: 5px;
    display: block;
}

.special-move p {
    color: var(--text-secondary);
    margin: 0;
}

.settings-panel {
    animation: fade-in 0.3s ease-out;
}

.setting-group {
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--border-radius);
    border: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.setting-group > label {
    color: var(--text-primary);
    font-weight: 600;
    font-size: 1.1rem;
    margin: 0;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 15px;
}

.volume-control input[type="range"] {
    flex: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
}

.volume-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--neon-blue);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

.volume-control input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--neon-blue);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

.volume-control span {
    color: var(--neon-blue);
    font-weight: 700;
    min-width: 40px;
    text-align: center;
}

.setting-toggle {
    display: flex;
    align-items: center;
    justify-content: flex-start;
}

.toggle-switch {
    display: flex;
    align-items: center;
    gap: 15px;
    cursor: pointer;
}

.toggle-switch input[type="checkbox"] {
    display: none;
}

.toggle-slider {
    position: relative;
    width: 50px;
    height: 26px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 13px;
    transition: all 0.3s ease;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 22px;
    height: 22px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle-switch input[type="checkbox"]:checked + .toggle-slider {
    background: var(--neon-blue);
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
}

.toggle-switch input[type="checkbox"]:checked + .toggle-slider::before {
    transform: translateX(24px);
}

.toggle-label {
    color: var(--text-primary);
    font-weight: 600;
}

/* Controls Display */
.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 25px;
}

.control-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.control-key {
    background: var(--neon-blue);
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    font-family: var(--font-primary);
    font-weight: 700;
    font-size: 0.9rem;
    min-width: 50px;
    text-align: center;
    box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
}

.control-action {
    color: var(--text-primary);
    font-weight: 500;
}

.controls-info h3 {
    color: var(--neon-blue);
    margin-bottom: 15px;
    margin-top: 25px;
    font-size: 1.2rem;
    text-shadow: 0 0 8px currentColor;
}

.controls-info h3:first-child {
    margin-top: 0;
}

/* Touch Controls */
.touch-controls-info {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.touch-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.touch-gesture {
    font-size: 1rem;
    min-width: 100px;
    background: var(--neon-purple);
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    font-weight: 600;
    text-align: center;
    box-shadow: 0 0 8px rgba(157, 78, 221, 0.3);
}

/* Help Modal Specific Styles */
.help-sections {
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.help-section h3 {
    color: var(--neon-blue);
    font-size: 1.3rem;
    margin-bottom: 15px;
    text-shadow: 0 0 8px currentColor;
}

.help-section p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 15px;
}

.special-moves, .scoring-info {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.special-item, .score-item {
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.special-item {
    color: var(--text-secondary);
    line-height: 1.5;
}

.special-item strong {
    color: var(--text-accent);
}

.score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.score-item span:first-child {
    color: var(--text-secondary);
}

.score-item span:last-child {
    color: var(--neon-green);
    font-weight: 700;
}

.quick-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
}

/* Offline Mode Indicators */
.offline-indicator {
    position: fixed;
    top: 70px;
    right: 20px;
    background: var(--bg-dark);
    border: 2px solid var(--neon-orange);
    border-radius: 10px;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9rem;
    z-index: 1000;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(255, 159, 64, 0.3);
}

.offline-indicator.visible {
    opacity: 1;
    transform: translateY(0);
}

.offline-indicator.offline {
    border-color: var(--neon-red);
    box-shadow: 0 0 20px rgba(255, 89, 94, 0.3);
}

.offline-indicator.syncing {
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
}

.offline-indicator .offline-icon,
.offline-indicator .sync-icon {
    font-size: 1.2rem;
    animation: pulse 2s infinite;
}

.offline-indicator .pending-count {
    background: var(--neon-orange);
    color: var(--bg-dark);
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: bold;
    font-size: 0.8rem;
}

/* Offline Notifications */
.offline-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--bg-dark);
    border: 2px solid var(--neon-blue);
    border-radius: 10px;
    padding: 15px 20px;
    max-width: 300px;
    z-index: 10000;
    opacity: 0;
    transform: translateX(400px);
    transition: all 0.3s ease;
}

.offline-notification.visible {
    opacity: 1;
    transform: translateX(0);
}

.offline-notification.success {
    border-color: var(--neon-green);
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.offline-notification.warning {
    border-color: var(--neon-orange);
    box-shadow: 0 0 20px rgba(255, 159, 64, 0.3);
}

.offline-notification.error {
    border-color: var(--neon-red);
    box-shadow: 0 0 20px rgba(255, 89, 94, 0.3);
}

.offline-notification.info {
    border-color: var(--neon-blue);
    box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
}

/* Update Notification */
.update-notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-dark);
    border: 2px solid var(--neon-green);
    border-radius: 10px;
    padding: 15px 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 10001;
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
    animation: slideDown 0.5s ease;
}

.update-notification button {
    background: var(--neon-green);
    color: var(--bg-dark);
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.update-notification button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
}

/* PWA Install Button */
.pwa-install {
    background: linear-gradient(135deg, var(--neon-purple), var(--neon-blue));
    border: 2px solid transparent;
    animation: gradient-border 3s ease infinite;
}

.pwa-install:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(187, 134, 252, 0.5);
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-100px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes gradient-border {
    0%, 100% {
        border-color: var(--neon-purple);
    }
    50% {
        border-color: var(--neon-blue);
    }
}

/* Hint System Styles */
.hint-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background: linear-gradient(135deg, var(--neon-yellow), var(--neon-orange));
    border: 2px solid rgba(255, 255, 0, 0.5);
    border-radius: 10px;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 50;
    font-weight: bold;
}

.hint-button:hover:not(:disabled) {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
}

.hint-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.hint-icon {
    font-size: 1.5rem;
}

.hint-count {
    font-size: 0.9rem;
    color: var(--text-primary);
}

.hint-column-highlight {
    pointer-events: none;
    animation: pulse 1s infinite;
}

.hint-rotation-indicator {
    animation: rotateHint 2s ease-out;
}

.hint-movement-arrow {
    animation: slideHint 1s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 0.3; }
}

@keyframes rotateHint {
    from { transform: translate(-50%, -50%) rotate(0deg) scale(0); }
    to { transform: translate(-50%, -50%) rotate(360deg) scale(1); }
}

@keyframes slideHint {
    0%, 100% { transform: translateX(-50%) translateX(0); }
    50% { transform: translateX(-50%) translateX(10px); }
}

/* Power-Up Mode Styles */
.powerup-slots {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 50;
}

.powerup-slot {
    width: 100px;
    height: 80px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.powerup-slot.filled {
    animation: pulse 2s infinite;
}

.powerup-slot:hover {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
}

.powerup-key {
    position: absolute;
    top: 5px;
    left: 5px;
    background: var(--neon-blue);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: bold;
}

.powerup-icon {
    font-size: 2rem;
    margin-bottom: 5px;
}

.powerup-name {
    font-size: 0.8rem;
    color: var(--text-primary);
    text-align: center;
}

.powerup-empty {
    font-size: 0.8rem;
    color: var(--text-secondary);
    opacity: 0.5;
}

/* Active Power-Ups Display */
.active-powerups {
    position: absolute;
    top: 100px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 50;
}

.active-powerup {
    width: 60px;
    height: 60px;
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid;
    border-radius: 50%;
    padding: 5px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
}

.active-powerup-icon {
    font-size: 1.5rem;
}

.active-powerup-timer {
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
}

.timer-fill {
    height: 100%;
    transition: width 0.1s linear;
    border-radius: 2px;
}

/* Power-Up Notification */
.powerup-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid;
    border-radius: 15px;
    padding: 20px 30px;
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 10000;
    animation: slideIn 0.5s ease;
}

.powerup-notification.fade-out {
    animation: fadeOut 0.5s ease;
}

.notification-icon {
    font-size: 2rem;
}

.notification-text {
    font-size: 1.2rem;
    font-weight: bold;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
}

/* styles/animations.css */
/* Modern Tetris - Animations */

/* Gradient Animation */
@keyframes gradient-shift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Piece Drop Animation */
@keyframes piece-drop {
    0% { transform: translateY(-20px) scale(1.1); opacity: 0.8; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

/* Line Clear Animation */
@keyframes line-clear {
    0% { 
        background: rgba(255, 255, 255, 0.9);
        transform: scaleX(1);
        opacity: 1;
    }
    50% { 
        background: var(--neon-blue);
        transform: scaleX(1.1);
        opacity: 0.8;
    }
    100% { 
        background: transparent;
        transform: scaleX(0);
        opacity: 0;
    }
}

/* Glow Pulse Animation */
@keyframes glow-pulse {
    0%, 100% { 
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        filter: brightness(1);
    }
    50% { 
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.6);
        filter: brightness(1.2);
    }
}

/* Pulse Glow for Logo */
@keyframes pulse-glow {
    0%, 100% {
        filter: drop-shadow(0 0 20px rgba(57, 255, 20, 0.6));
        transform: scale(1);
    }
    50% {
        filter: drop-shadow(0 0 30px rgba(57, 255, 20, 0.9));
        transform: scale(1.02);
    }
}

/* Particle Animation */
@keyframes particle-float {
    0% {
        transform: translateY(0) rotate(0deg) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-100px) rotate(360deg) scale(0);
        opacity: 0;
    }
}

/* Shake Animation for Game Over */
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Bounce Animation for Piece Landing */
@keyframes bounce-land {
    0% { transform: translateY(0); }
    20% { transform: translateY(-5px); }
    40% { transform: translateY(0); }
    60% { transform: translateY(-2px); }
    80% { transform: translateY(0); }
    100% { transform: translateY(0); }
}

/* Score Pop Animation */
@keyframes score-pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); color: var(--neon-green); }
    100% { transform: scale(1); }
}

/* Hold Piece Swap Animation */
@keyframes hold-swap {
    0% { transform: scale(1) rotate(0deg); opacity: 1; }
    50% { transform: scale(0.8) rotate(180deg); opacity: 0.5; }
    100% { transform: scale(1) rotate(360deg); opacity: 1; }
}

/* Next Piece Slide Animation */
@keyframes next-slide {
    0% { transform: translateX(100px); opacity: 0; }
    100% { transform: translateX(0); opacity: 1; }
}

/* Button Hover Effect */
@keyframes button-glow {
    0% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }
    100% { box-shadow: 0 0 30px rgba(0, 212, 255, 0.8); }
}

/* Level Up Animation */
@keyframes level-up {
    0% { 
        transform: scale(1);
        color: var(--text-accent);
    }
    25% { 
        transform: scale(1.2);
        color: var(--neon-green);
        text-shadow: 0 0 20px var(--neon-green);
    }
    50% { 
        transform: scale(1.1);
        color: var(--neon-yellow);
        text-shadow: 0 0 15px var(--neon-yellow);
    }
    75% { 
        transform: scale(1.15);
        color: var(--neon-pink);
        text-shadow: 0 0 25px var(--neon-pink);
    }
    100% { 
        transform: scale(1);
        color: var(--text-accent);
        text-shadow: var(--shadow-glow);
    }
}

/* Ghost Piece Fade */
@keyframes ghost-fade {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
}

/* T-Spin Flash */
@keyframes tspin-flash {
    0% { background: transparent; }
    25% { background: var(--neon-purple); }
    50% { background: var(--neon-pink); }
    75% { background: var(--neon-blue); }
    100% { background: transparent; }
}

/* Combo Multiplier */
@keyframes combo-multiplier {
    0% { 
        transform: scale(1) rotate(0deg);
        color: var(--text-primary);
    }
    50% { 
        transform: scale(1.5) rotate(5deg);
        color: var(--neon-orange);
        text-shadow: 0 0 30px var(--neon-orange);
    }
    100% { 
        transform: scale(1) rotate(0deg);
        color: var(--text-primary);
    }
}

/* Background Pattern Animation */
@keyframes bg-pattern {
    0% { transform: translateX(0) translateY(0); }
    100% { transform: translateX(-50px) translateY(-50px); }
}

/* Piece Rotation Effect */
@keyframes piece-rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(90deg); }
}

/* Game Over Screen Animation */
@keyframes game-over {
    0% { 
        transform: scale(0.8);
        opacity: 0;
    }
    50% { 
        transform: scale(1.1);
        opacity: 0.8;
    }
    100% { 
        transform: scale(1);
        opacity: 1;
    }
}

/* Utility Classes for Animations */
.animate-drop { animation: piece-drop 0.3s ease-out; }
.animate-clear { animation: line-clear 0.5s ease-in-out; }
.animate-glow { animation: glow-pulse 2s ease-in-out infinite; }
.animate-bounce { animation: bounce-land 0.4s ease-out; }
.animate-score-pop { animation: score-pop 0.4s ease-out; }
.animate-shake { animation: shake 0.5s ease-in-out; }
.animate-level-up { animation: level-up 1s ease-in-out; }
.animate-ghost { animation: ghost-fade 1.5s ease-in-out infinite; }
.animate-tspin { animation: tspin-flash 0.3s ease-in-out; }
.animate-combo { animation: combo-multiplier 0.6s ease-out; }
.animate-game-over { animation: game-over 0.8s ease-out; }

/* Particle Effects */
.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: var(--neon-blue);
    border-radius: 50%;
    pointer-events: none;
    animation: particle-float 2s ease-out forwards;
}

.particle.pink { background: var(--neon-pink); }
.particle.green { background: var(--neon-green); }
.particle.yellow { background: var(--neon-yellow); }
.particle.purple { background: var(--neon-purple); }

/* Transition Effects */
.smooth-transition {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.fade-in {
    animation: fade-in 0.5s ease-out;
}

@keyframes fade-in {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-in-right {
    animation: slide-in-right 0.4s ease-out;
}

@keyframes slide-in-right {
    from { transform: translateX(100px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

/* styles/responsive.css */
/* Modern Tetris - Responsive Styles */

/* Mobile First Approach */

/* Small Mobile Devices (320px - 480px) */
@media (max-width: 480px) {
    .app {
        padding: 5px;
        padding-bottom: env(safe-area-inset-bottom);
    }
    
    .game-screen {
        padding-top: 42px;
        padding: 5px;
        padding-top: 42px;
        padding-bottom: env(safe-area-inset-bottom);
        height: 100vh;
        height: 100dvh; /* Dynamic viewport height for mobile browsers */
    }
    
    
    .logo {
        height: 40px;
    }
    
    .logo-container {
        gap: 10px;
    }
    
    .title {
        font-size: 2rem;
        margin-bottom: 10px;
    }
    
    /* Better mobile controls hint */
    .controls-hint {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.75rem;
        padding: 12px;
        background: rgba(0, 255, 255, 0.1);
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.3);
        margin-bottom: 15px;
    }
    
    .controls-hint span {
        padding: 6px 10px;
        font-size: 0.7rem;
        background: rgba(0, 255, 255, 0.2);
        border-radius: 4px;
        text-align: center;
        flex: 1;
        min-width: 120px;
    }
    
    /* Header controls with better spacing */
    .header-controls {
        gap: 12px;
    }
    
    .btn-icon {
        padding: 10px;
        font-size: 1.1rem;
    }
    
    /* Hide desktop layout, show compact mobile layout */
    .game-sidebar {
        display: none !important;
    }
    
    .info-panel, .next-panel {
        display: block !important;
    }
    
    /* Compact two-column layout */
    .game-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: min-content 1fr;
        gap: 0.3em;
        max-width: 100%;
        padding: 0 0.3em;
        padding-bottom: calc(0.3em + env(safe-area-inset-bottom));
        height: calc(100vh - 48px - env(safe-area-inset-bottom));
        height: calc(100dvh - 48px - env(safe-area-inset-bottom));
        max-height: calc(100vh - 48px - env(safe-area-inset-bottom));
        max-height: calc(100dvh - 48px - env(safe-area-inset-bottom));
    }
    
    /* Info panel (hold + stats combined) */
    .info-panel {
        grid-column: 1;
        grid-row: 1;
    }
    
    .hold-stats-card {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        padding: 0.4em;
        display: flex;
        flex-direction: column;
        gap: 0.3em;
        max-height: 5.5em;
    }
    
    .hold-section {
        text-align: center;
    }
    
    .hold-section h4 {
        margin: 0 0 0.2em 0;
        font-size: 0.65em;
        color: var(--neon-blue);
        font-weight: 600;
        line-height: 1;
    }
    
    .hold-piece {
        width: 2.2em;
        height: 2.2em;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 3px;
    }
    
    .stats-section {
        display: flex;
        flex-direction: column;
        gap: 0.15em;
    }
    
    .stat-compact {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.05em 0;
        line-height: 1.2;
    }
    
    .stat-label-small {
        font-size: 0.6em;
        color: var(--text-secondary);
        font-weight: 500;
    }
    
    .stat-value-small {
        font-size: 0.7em;
        color: var(--neon-blue);
        font-weight: 600;
        font-family: 'Orbitron', monospace;
    }
    
    /* Next pieces panel */
    .next-panel {
        grid-column: 2;
        grid-row: 1;
    }
    
    .next-pieces-card {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        padding: 0.4em;
        text-align: center;
        max-height: 5.5em;
    }
    
    .next-pieces-card h4 {
        margin: 0 0 0.2em 0;
        font-size: 0.65em;
        color: var(--neon-blue);
        font-weight: 600;
        line-height: 1;
    }
    
    .next-pieces-compact {
        display: flex;
        flex-direction: row;
        gap: 0.3em;
        align-items: center;
        justify-content: center;
    }
    
    .next-piece-small {
        width: 1.6em;
        height: 1.6em;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 2px;
    }
    
    /* Game board spans both columns */
    .game-board {
        grid-column: 1 / -1;
        grid-row: 2;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        height: 100%;
        max-height: calc(100vh - 85px - env(safe-area-inset-bottom));
        max-height: calc(100dvh - 85px - env(safe-area-inset-bottom));
        padding-bottom: calc(2px + env(safe-area-inset-bottom));
    }
    
    #game-canvas {
        width: 100%;
        max-width: min(280px, calc(100vw - 16px));
        height: calc(100vh - 85px - env(safe-area-inset-bottom));
        height: calc(100dvh - 85px - env(safe-area-inset-bottom));
        max-height: min(560px, calc(100vh - 85px - env(safe-area-inset-bottom)));
        max-height: min(560px, calc(100dvh - 85px - env(safe-area-inset-bottom)));
    }
    
    #overlay-title {
        font-size: 1.8rem;
    }
    
    #overlay-message {
        font-size: 1rem;
    }
    
    .btn-primary, .btn-secondary {
        padding: 15px 24px;
        font-size: 1rem;
        margin: 8px;
        min-height: 50px;
        border-radius: 8px;
    }
}

/* Large Mobile / Small Tablet (481px - 768px) */
@media (min-width: 481px) and (max-width: 768px) {
    /* Hide desktop layout, show compact layout */
    .game-sidebar {
        display: none !important;
    }
    
    .info-panel, .next-panel {
        display: block !important;
    }
    
    .game-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 20px;
        max-width: 500px;
        margin: 0 auto;
    }
    
    .info-panel {
        grid-column: 1;
        grid-row: 1;
    }
    
    .hold-stats-card {
        padding: 15px;
    }
    
    .hold-piece {
        width: 55px;
        height: 55px;
    }
    
    .stat-label-small {
        font-size: 0.8rem;
    }
    
    .stat-value-small {
        font-size: 0.9rem;
    }
    
    .next-panel {
        grid-column: 2;
        grid-row: 1;
    }
    
    .next-pieces-card {
        padding: 15px;
    }
    
    .next-piece-small {
        width: 40px;
        height: 40px;
    }
    
    .game-board {
        grid-column: 1 / -1;
        grid-row: 2;
        display: flex;
        justify-content: center;
    }
    
    #game-canvas {
        width: 100%;
        max-width: 350px;
        height: 700px;
    }
    
    .title {
        font-size: 3rem;
    }
    
    .controls-hint {
        font-size: 0.8rem;
    }
}

/* Tablets (769px - 1024px) */
@media (min-width: 769px) and (max-width: 1024px) {
    /* Use traditional 3-column layout for tablets */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 180px 1fr 180px;
        gap: 25px;
        max-width: 800px;
    }
    
    #game-canvas {
        width: 350px;
        height: 700px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 18px;
    }
    
    .hold-piece, .next-piece {
        width: 70px;
        height: 70px;
    }
    
    .title {
        font-size: 3.5rem;
    }
}

/* Desktop (1025px and up) */
@media (min-width: 1025px) {
    /* Use traditional 3-column layout for desktop */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 220px 1fr 220px;
        gap: 35px;
    }
    
    #game-canvas {
        width: 400px;
        height: 800px;
    }
    
    .title {
        font-size: 4rem;
    }
}

/* Large Desktop (1441px and up) */
@media (min-width: 1441px) {
    /* Use traditional 3-column layout for large desktop */
    .info-panel, .next-panel {
        display: none;
    }
    
    .game-sidebar {
        display: block !important;
    }
    
    .game-container {
        grid-template-columns: 250px 1fr 250px;
        gap: 40px;
    }
    
    #game-canvas {
        width: 450px;
        height: 900px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 25px;
    }
    
    .hold-piece, .next-piece {
        width: 90px;
        height: 90px;
    }
}

/* Landscape Orientation for Mobile */
@media (max-height: 600px) and (orientation: landscape) {
    .app {
        padding: 10px;
    }
    
    .header {
        margin-bottom: 15px;
    }
    
    .title {
        font-size: 2rem;
        margin-bottom: 5px;
    }
    
    .controls-hint {
        display: none;
    }
    
    .game-container {
        grid-template-columns: 150px 1fr 150px;
        gap: 15px;
        max-width: 100%;
    }
    
    #game-canvas {
        width: 300px;
        height: 450px;
    }
    
    .hold-area, .next-area, .stats {
        padding: 10px;
        font-size: 0.85rem;
    }
    
    .hold-area h3, .next-area h3 {
        font-size: 0.9rem;
        margin-bottom: 10px;
    }
    
    .hold-piece, .next-piece {
        width: 50px;
        height: 50px;
    }
    
    .stat {
        padding: 6px 0;
    }
    
    .stat-value {
        font-size: 0.9rem;
    }
}

/* High DPI / Retina Displays */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    #game-canvas {
        image-rendering: -webkit-crisp-edges;
        image-rendering: crisp-edges;
    }
}

/* Reduced Motion Preference */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .title {
        animation: none;
        background: var(--neon-blue);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .animate-glow {
        animation: none;
        box-shadow: var(--shadow-glow);
    }
    
    .animate-ghost {
        animation: none;
        opacity: 0.4;
    }
}

/* Dark Mode (System Preference) */
@media (prefers-color-scheme: dark) {
    :root {
        --primary-bg: #000000;
        --secondary-bg: #111111;
        --accent-bg: #1a1a1a;
    }
}

/* Light Mode Override */
@media (prefers-color-scheme: light) {
    :root {
        --primary-bg: #1a1a2e;
        --secondary-bg: #16213e;
        --accent-bg: #0f0f1a;
    }
}

/* Focus States for Keyboard Navigation */
@media (any-hover: none) {
    .btn-primary:focus,
    .btn-secondary:focus {
        outline: 2px solid var(--neon-blue);
        outline-offset: 2px;
    }
    
    .hold-piece:focus,
    .next-piece:focus {
        outline: 1px solid var(--neon-blue);
    }
}

/* Touch Device Optimizations */
@media (hover: none) and (pointer: coarse) {
    /* Improve button touch targets and feedback */
    .btn-primary, .btn-secondary, .btn-icon, .btn-close {
        min-height: 44px; /* Apple's recommended minimum touch target */
        min-width: 44px;
        touch-action: manipulation; /* Prevents double-tap zoom */
        user-select: none; /* Prevents text selection on long press */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* Remove tap highlight */
    }
    
    /* Active state for better touch feedback */
    .btn-primary.touch-active,
    .btn-secondary.touch-active,
    .btn-icon.touch-active,
    .btn-close.touch-active {
        transform: scale(0.95);
        opacity: 0.8;
        transition: all 0.1s ease;
    }
    
    /* Remove hover effects that don't work on touch */
    .controls-hint span:hover {
        background: var(--glass-bg);
        box-shadow: none;
    }
    
    .btn-primary:hover,
    .btn-secondary:hover {
        transform: none;
    }
    
    .hold-area:hover::before,
    .next-area:hover::before,
    .stats:hover::before {
        opacity: 0;
    }
    
    /* Better touch targets for modal interactions */
    .name-input-content, .leaderboard-content, .settings-content, .help-content {
        touch-action: manipulation;
    }
    
    /* Improve input field touch experience */
    input, select, textarea {
        touch-action: manipulation;
        min-height: 44px;
        font-size: 16px; /* Prevents zoom on iOS */
    }
    
    /* Game canvas touch optimization */
    #game-canvas {
        touch-action: none; /* Allow custom touch handling */
        user-select: none;
    }
    
    /* Tab buttons in modals */
    .tab-button, .settings-tab-button {
        min-height: 44px;
        touch-action: manipulation;
    }
    
    /* Leaderboard entries should be easier to see on touch */
    .leaderboard-entry {
        min-height: 50px;
    }
}

/* Modal Responsive Styles */
@media (max-width: 480px) {
    .name-input-content, .leaderboard-content {
        padding: 15px;
        margin: 10px;
        max-width: calc(100% - 20px);
        width: 100%;
    }
    
    .leaderboard-content {
        max-height: 90vh;
        display: flex;
        flex-direction: column;
    }
    
    .leaderboard-header {
        flex-shrink: 0;
        padding-bottom: 10px;
        margin-bottom: 10px;
    }
    
    .leaderboard-header h2 {
        font-size: 1.3rem;
    }
    
    .name-input-content h2 {
        font-size: 1.5rem;
    }
    
    .score-summary {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .input-buttons {
        flex-direction: column;
        gap: 10px;
    }
    
    .btn-primary, .btn-secondary {
        width: 100%;
        margin: 5px 0;
        min-height: 50px;
    }
    
    /* Leaderboard mobile card layout */
    .leaderboard-list {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 5px;
        max-height: calc(90vh - 200px);
    }
    
    .leaderboard-entry {
        display: block;
        position: relative;
        padding: 15px;
        font-size: 0.9rem;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
        border: 1px solid rgba(0, 212, 255, 0.2);
        margin-bottom: 12px;
    }
    
    .leaderboard-entry .entry-rank {
        position: absolute;
        top: 15px;
        left: 15px;
        font-size: 1.8rem;
        font-weight: bold;
        width: 40px;
        text-align: center;
    }
    
    .leaderboard-entry .entry-name {
        margin-left: 60px;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 8px;
        word-break: break-word;
    }
    
    .leaderboard-entry .entry-score {
        margin-left: 60px;
        font-size: 1.3rem;
        font-weight: bold;
        color: var(--neon-green);
        text-shadow: 0 0 5px currentColor;
        margin-bottom: 10px;
    }
    
    /* Mobile stats row */
    .leaderboard-entry .entry-lines,
    .leaderboard-entry .entry-level {
        display: inline-block;
        margin-left: 60px;
        margin-right: 15px;
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    
    .leaderboard-entry .entry-lines::before {
        content: 'Lines: ';
        opacity: 0.7;
    }
    
    .leaderboard-entry .entry-level::before {
        content: 'Lvl: ';
        opacity: 0.7;
    }
    
    .leaderboard-tabs {
        flex-direction: row;
        gap: 5px;
        padding: 3px;
        flex-shrink: 0;
    }
    
    .tab-button {
        padding: 10px;
        font-size: 0.85rem;
    }
    
    /* Mode selector for mobile */
    .mode-selector-container {
        margin: 10px 0;
        padding: 5px;
    }
    
    .mode-selector {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
    }
    
    .mode-button {
        padding: 10px 8px;
        font-size: 0.8rem;
    }
    
    .mode-button .mode-icon {
        font-size: 1.2rem;
        margin-bottom: 3px;
    }
}

@media (min-width: 481px) and (max-width: 768px) {
    .name-input-content, .leaderboard-content {
        padding: 25px;
        max-width: 90%;
    }
    
    .score-summary {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .leaderboard-list {
        max-height: 60vh;
        overflow-y: auto;
    }
    
    .leaderboard-entry {
        display: grid;
        grid-template-columns: 50px 2fr 1fr 60px 60px;
        gap: 10px;
        align-items: center;
        padding: 12px;
        font-size: 0.95rem;
    }
    
    .leaderboard-entry .entry-rank {
        position: static;
        font-size: 1.3rem;
    }
    
    .leaderboard-entry .entry-name {
        margin: 0;
        font-size: 1rem;
    }
    
    .leaderboard-entry .entry-score {
        margin: 0;
        font-size: 1.1rem;
        text-align: right;
    }
    
    .leaderboard-entry .entry-lines,
    .leaderboard-entry .entry-level {
        display: block;
        margin: 0;
        text-align: center;
        font-size: 0.9rem;
    }
    
    .leaderboard-entry .entry-lines::before,
    .leaderboard-entry .entry-level::before {
        content: '';
    }
    
    .leaderboard-tabs {
        flex-direction: row;
    }
    
    .mode-selector {
        grid-template-columns: repeat(3, 1fr);
    }
}

/* Print Styles */
@media print {
    .app {
        background: white;
        color: black;
    }
    
    .game-container {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .game-sidebar {
        display: none;
    }
    
    #game-canvas {
        border: 2px solid black;
        background: white;
    }
    
    .particles-container {
        display: none;
    }
    
    .name-input-overlay, .leaderboard-overlay {
        display: none !important;
    }
}

/* styles/modes.css */
/* Game Modes Styles */

/* Mode Selector Modal */
.mode-selector-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease;
}

.mode-selector-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
    border: 2px solid var(--neon-blue);
    border-radius: 20px;
    padding: 40px;
    max-width: 900px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
}

.mode-selector-content h2 {
    text-align: center;
    color: var(--neon-blue);
    margin-bottom: 30px;
    font-size: 2rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

/* Mode Grid */
.mode-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.mode-card {
    background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
    border: 2px solid transparent;
    border-radius: 15px;
    padding: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.mode-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.05), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.mode-card:hover::before {
    transform: translateX(100%);
}

.mode-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

/* Mode specific colors */
.mode-card[data-mode="classic"] {
    border-color: #00ffff;
}
.mode-card[data-mode="classic"]:hover {
    border-color: #00ffff;
    box-shadow: 0 10px 30px rgba(0, 255, 255, 0.3);
}

.mode-card[data-mode="sprint"] {
    border-color: #ff00ff;
}
.mode-card[data-mode="sprint"]:hover {
    border-color: #ff00ff;
    box-shadow: 0 10px 30px rgba(255, 0, 255, 0.3);
}

.mode-card[data-mode="marathon"] {
    border-color: #ffff00;
}
.mode-card[data-mode="marathon"]:hover {
    border-color: #ffff00;
    box-shadow: 0 10px 30px rgba(255, 255, 0, 0.3);
}

.mode-card[data-mode="zen"] {
    border-color: #00ff00;
}
.mode-card[data-mode="zen"]:hover {
    border-color: #00ff00;
    box-shadow: 0 10px 30px rgba(0, 255, 0, 0.3);
}

.mode-card[data-mode="puzzle"] {
    border-color: #ff8800;
}
.mode-card[data-mode="puzzle"]:hover {
    border-color: #ff8800;
    box-shadow: 0 10px 30px rgba(255, 136, 0, 0.3);
}

.mode-card[data-mode="battle"] {
    border-color: #ff0000;
}
.mode-card[data-mode="battle"]:hover {
    border-color: #ff0000;
    box-shadow: 0 10px 30px rgba(255, 0, 0, 0.3);
}

.mode-icon {
    font-size: 3rem;
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

.mode-card h3 {
    color: #fff;
    margin-bottom: 10px;
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.mode-card p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    line-height: 1.4;
}

/* Close button */
.close-mode-selector {
    position: absolute;
    top: 20px;
    right: 20px;
    background: transparent;
    border: 2px solid var(--neon-blue);
    color: var(--neon-blue);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-mode-selector:hover {
    background: var(--neon-blue);
    color: #0f0f23;
    transform: rotate(90deg);
}

/* Mode UI Elements */
.mode-indicator {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
    border: 2px solid var(--neon-blue);
    border-radius: 20px;
    padding: 5px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 100;
}

.mode-indicator-icon {
    font-size: 1.2rem;
}

.mode-indicator-name {
    color: var(--neon-blue);
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Mode Specific UI Container */
.mode-specific-ui {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    pointer-events: none;
}

/* Sprint Mode Timer */
#mode-timer,
.sprint-timer {
    font-size: 1.8rem;
    color: #ff00ff;
    text-align: center;
    font-family: 'Courier New', 'Orbitron', monospace;
    font-variant-numeric: tabular-nums;
    text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    min-width: 240px;
    width: 240px;
    display: block;
    background: rgba(0, 0, 0, 0.8);
    padding: 12px 15px;
    border-radius: 10px;
    border: 2px solid #ff00ff;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    letter-spacing: 2px;
}

.sprint-best-time {
    font-size: 1rem;
    color: rgba(255, 0, 255, 0.7);
    text-align: center;
    margin-top: 5px;
}

/* Marathon Mode Progress */
.marathon-progress {
    width: 100%;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #ffff00;
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
}

.marathon-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #ffff00, #ff8800);
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
}

.marathon-checkpoint {
    color: #ffff00;
    text-align: center;
    font-weight: bold;
    margin-top: 5px;
}

/* Zen Mode Stats */
.zen-stats {
    background: rgba(0, 255, 0, 0.1);
    border: 1px solid #00ff00;
    border-radius: 10px;
    padding: 10px;
    margin: 10px 0;
}

.zen-stat-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    color: rgba(0, 255, 0, 0.9);
}

.zen-export-btn {
    background: #00ff00;
    color: #0f0f23;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.3s ease;
}

.zen-export-btn:hover {
    background: #00cc00;
    transform: scale(1.05);
}

/* Puzzle Mode UI */
.puzzle-number {
    background: rgba(255, 136, 0, 0.2);
    border: 1px solid #ff8800;
    border-radius: 8px;
    padding: 8px 15px;
    margin: 5px 0;
    text-align: center;
    min-width: 150px;
}

.puzzle-number-text {
    color: #ff8800;
    font-size: 1.1rem;
    font-weight: bold;
    text-transform: uppercase;
}

.puzzle-objective {
    background: linear-gradient(135deg, rgba(255, 136, 0, 0.2), rgba(255, 136, 0, 0.1));
    border: 2px solid #ff8800;
    border-radius: 10px;
    padding: 15px 20px;
    margin: 10px 0;
    text-align: center;
    box-shadow: 0 0 15px rgba(255, 136, 0, 0.3);
    min-width: 280px;
}

.puzzle-objective-title {
    color: #ff8800;
    font-size: 1.3rem;
    font-weight: bold;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(255, 136, 0, 0.5);
}

#puzzle-objective-text {
    color: #ffffff;
    font-size: 1.1rem;
    font-weight: 600;
    background: rgba(0, 0, 0, 0.3);
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.puzzle-pieces {
    background: rgba(100, 100, 255, 0.1);
    border: 2px solid #6666ff;
    border-radius: 10px;
    padding: 12px 20px;
    margin: 10px 0;
    text-align: center;
    min-width: 200px;
}

.puzzle-pieces-title {
    color: #6666ff;
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 5px;
    text-transform: uppercase;
}

#puzzle-pieces-count {
    color: #ffffff;
    font-size: 1.2rem;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    font-variant-numeric: tabular-nums;
    letter-spacing: 1px;
}

.puzzle-pieces-remaining {
    display: flex;
    justify-content: center;
    gap: 5px;
    margin: 10px 0;
}

.puzzle-piece-icon {
    width: 30px;
    height: 30px;
    background: rgba(255, 136, 0, 0.2);
    border: 1px solid #ff8800;
    border-radius: 5px;
}

.puzzle-piece-icon.used {
    opacity: 0.3;
}

/* Battle Mode UI */
.battle-grid-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
}

.battle-player-side,
.battle-ai-side {
    border: 2px solid #ff0000;
    border-radius: 10px;
    padding: 10px;
    position: relative;
}

.battle-player-side {
    border-color: #00ffff;
}

.battle-ai-side {
    border-color: #ff0000;
}

.battle-side-label {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: #0f0f23;
    padding: 0 10px;
    font-weight: bold;
    text-transform: uppercase;
}

.battle-garbage-indicator {
    position: absolute;
    right: -30px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.garbage-line {
    width: 20px;
    height: 10px;
    background: #ff0000;
    border: 1px solid #fff;
    animation: blink 0.5s infinite;
}

.battle-powerups {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 10px 0;
}

.powerup-btn {
    width: 50px;
    height: 50px;
    border: 2px solid #666;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.5);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.powerup-btn.ready {
    border-color: #00ff00;
    animation: glow 1s infinite;
}

.powerup-btn:hover.ready {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
}

.powerup-cooldown {
    position: absolute;
    bottom: -15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.8rem;
    color: #ff0000;
}

/* Animations */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

@keyframes glow {
    0%, 100% {
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
    }
    50% {
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }
}

@keyframes blink {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    .mode-selector-content {
        padding: 20px;
    }
    
    .mode-grid {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .mode-card {
        padding: 20px;
    }
    
    .mode-icon {
        font-size: 2rem;
    }
    
    .mode-card h3 {
        font-size: 1.2rem;
    }
    
    .battle-grid-container {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 480px) {
    .mode-selector-content h2 {
        font-size: 1.5rem;
    }
    
    .mode-card {
        padding: 15px;
    }
    
    .mode-icon {
        font-size: 1.5rem;
    }
    
    .mode-card h3 {
        font-size: 1rem;
    }
    
    .mode-card p {
        font-size: 0.8rem;
    }
}

</style>
</head>
<body data-standalone="true">
    <div class="app">
        <!-- Home Screen -->
        <div class="home-screen" id="home-screen">
            <div class="home-container">
                <div class="home-header">
                    <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMjAwIDgwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzPgogICAgPCEtLSBOZW9uIGdsb3cgZWZmZWN0cyAtLT4KICAgIDxmaWx0ZXIgaWQ9Im5lb25HbG93IiB4PSItMjAlIiB5PSItMjAlIiB3aWR0aD0iMTQwJSIgaGVpZ2h0PSIxNDAlIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIgcmVzdWx0PSJjb2xvcmVkQmx1ciIvPgogICAgICA8ZmVNZXJnZT4gCiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJjb2xvcmVkQmx1ciIvPgogICAgICAgIDxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPgogICAgICA8L2ZlTWVyZ2U+CiAgICA8L2ZpbHRlcj4KICAgIAogICAgPGZpbHRlciBpZD0ic3Ryb25nR2xvdyIgeD0iLTMwJSIgeT0iLTMwJSIgd2lkdGg9IjE2MCUiIGhlaWdodD0iMTYwJSI+CiAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjMiIHJlc3VsdD0iY29sb3JlZEJsdXIiLz4KICAgICAgPGZlTWVyZ2U+IAogICAgICAgIDxmZU1lcmdlTm9kZSBpbj0iY29sb3JlZEJsdXIiLz4KICAgICAgICA8ZmVNZXJnZU5vZGUgaW49IlNvdXJjZUdyYXBoaWMiLz4KICAgICAgPC9mZU1lcmdlPgogICAgPC9maWx0ZXI+CiAgICAKICAgIDwhLS0gR3JhZGllbnRzIC0tPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJ0ZXRyaXNHcmFkaWVudCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMzlGRjE0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjI1JSIgc3R5bGU9InN0b3AtY29sb3I6IzAwRkZGRjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRjE0OTM7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iNzUlIiBzdHlsZT0ic3RvcC1jb2xvcjojRkZENzAwO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM5RDAwRkY7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgCiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImJsb2NrR3JhZGllbnQiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMDBGRkZGO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDgwRkY7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICAKICA8IS0tIEJhY2tncm91bmQgLS0+CiAgPHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI4MCIgZmlsbD0icmdiYSgwLDAsMCwwLjgpIiByeD0iMTAiIHJ5PSIxMCIvPgogIAogIDwhLS0gVGV0cmlzIGJsb2NrcyBhcnJhbmdlbWVudCAoZm9ybWluZyBULUUtVC1SLUktUyBwYXR0ZXJuKSAtLT4KICA8IS0tIFQgc2hhcGUgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMzlGRjE0IiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBFIHNoYXBlIC0tPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1LCAxNSkiPgogICAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjgiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjgiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMDBGRkZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiMwMEZGRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSI4IiB5PSIxNiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBUIHNoYXBlIChzZWNvbmQgVCkgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjUsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGMTQ5MyIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjE2IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkYxNDkzIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGMTQ5MyIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBSIHNoYXBlIC0tPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkwLCAxNSkiPgogICAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjgiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iMCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjgiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIxNiIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGRDcwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjE2IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkZENzAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iMTYiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRkQ3MDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgPC9nPgogIAogIDwhLS0gSSBzaGFwZSAtLT4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAsIDE1KSI+CiAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iIzlEMDBGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICAgIDxyZWN0IHg9IjAiIHk9IjE2IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjOUQwMEZGIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMCIgeT0iMjQiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiM5RDAwRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgPC9nPgogIAogIDwhLS0gUyBzaGFwZSAtLT4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzUsIDE1KSI+CiAgICA8cmVjdCB4PSI4IiB5PSIwIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkY2QjAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iMTYiIHk9IjAiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIGZpbGw9IiNGRjZCMDAiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIi8+CiAgICA8cmVjdCB4PSIwIiB5PSI4IiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjRkY2QjAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIvPgogICAgPHJlY3QgeD0iOCIgeT0iOCIgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0iI0ZGNkIwMCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiLz4KICA8L2c+CiAgCiAgPCEtLSBBZGRpdGlvbmFsIGRlY29yYXRpdmUgZWxlbWVudHMgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY1LCAxNSkiPgogICAgPCEtLSBTbWFsbCBhY2NlbnQgYmxvY2tzIC0tPgogICAgPHJlY3QgeD0iMCIgeT0iNCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzM5RkYxNCIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiIG9wYWNpdHk9IjAuOCIvPgogICAgPHJlY3QgeD0iNiIgeT0iMCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzAwRkZGRiIgZmlsdGVyPSJ1cmwoI25lb25HbG93KSIgcng9IjEiIG9wYWNpdHk9IjAuOCIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjgiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNGRjE0OTMiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIiBvcGFjaXR5PSIwLjgiLz4KICAgIDxyZWN0IHg9IjYiIHk9IjE2IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjRkZENzAwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIiByeD0iMSIgb3BhY2l0eT0iMC44Ii8+CiAgICA8cmVjdCB4PSIxOCIgeT0iMTIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiM5RDAwRkYiIGZpbHRlcj0idXJsKCNuZW9uR2xvdykiIHJ4PSIxIiBvcGFjaXR5PSIwLjgiLz4KICA8L2c+CiAgCiAgPCEtLSBTdWJ0aXRsZSAtLT4KICA8dGV4dCB4PSIxMDAiIHk9IjY1IiBmb250LWZhbWlseT0iJ09yYml0cm9uJywgbW9ub3NwYWNlIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNzAwIiAKICAgICAgICBmaWxsPSJ1cmwoI3RldHJpc0dyYWRpZW50KSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsdGVyPSJ1cmwoI3N0cm9uZ0dsb3cpIj4KICAgIE1PREVSTiBFRElUSU9OCiAgPC90ZXh0PgogIAogIDwhLS0gQWRkaXRpb25hbCBnbG93IGVmZmVjdHMgLS0+CiAgPHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI4MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2JhKDU3LCAyNTUsIDIwLCAwLjMpIiBzdHJva2Utd2lkdGg9IjIiIHJ4PSIxMCIgcnk9IjEwIiBmaWx0ZXI9InVybCgjbmVvbkdsb3cpIi8+Cjwvc3ZnPg==" alt="Modern Tetris" class="home-logo">
                    <h1 class="home-title">TETRIS</h1>
                    <p class="home-subtitle">Choose Your Game Mode</p>
                </div>
                
                <div class="home-modes">
                    <div class="mode-grid">
                        <div class="mode-card home-mode-card" data-mode="classic">
                            <div class="mode-icon"></div>
                            <h3>Classic</h3>
                            <p>The original endless Tetris experience</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="powerup">
                            <div class="mode-icon"></div>
                            <h3>Power-Up</h3>
                            <p>Classic with exciting power-ups!</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="sprint">
                            <div class="mode-icon"></div>
                            <h3>Sprint</h3>
                            <p>Clear 40 lines as fast as possible</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="marathon">
                            <div class="mode-icon"></div>
                            <h3>Marathon</h3>
                            <p>Survive 150 lines with increasing difficulty</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="zen">
                            <div class="mode-icon"></div>
                            <h3>Zen</h3>
                            <p>Relaxing endless mode with no pressure</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="puzzle">
                            <div class="mode-icon"></div>
                            <h3>Puzzle</h3>
                            <p>Solve 150 unique challenges</p>
                        </div>
                        <div class="mode-card home-mode-card" data-mode="battle">
                            <div class="mode-icon"></div>
                            <h3>Battle</h3>
                            <p>Face off against intelligent AI opponents</p>
                        </div>
                    </div>
                </div>
                
                <div class="home-actions">
                    <button id="home-settings-button" class="btn-secondary"> Settings</button>
                    <button id="home-leaderboard-button" class="btn-secondary"> Leaderboard</button>
                    <button id="home-help-button" class="btn-secondary"> Help</button>
                    <button id="install-button" class="btn-secondary pwa-install" style="display: none;"> Install App</button>
                </div>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div class="game-screen" id="game-screen" style="display: none;">
        <!-- Minimal game header with only back and help buttons -->
        <header class="game-header">
            <button id="back-to-menu" class="btn-game-icon" title="Back to Menu"></button>
            <button id="game-help-button" class="btn-game-icon" title="Show Controls"></button>
            <button id="mute-button" class="btn-game-icon" title="Toggle Sound"></button>
        </header>

        <main class="game-container">
            <!-- Desktop layout - traditional 3-column -->
            <div class="game-sidebar left">
                <div class="hold-area">
                    <h3>Hold</h3>
                    <div class="hold-piece"></div>
                </div>
                
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Lines</span>
                        <span class="stat-value" id="lines">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Level</span>
                        <span class="stat-value" id="level">1</span>
                    </div>
                </div>
            </div>

            <!-- Game board -->
            <div class="game-board">
                <canvas id="game-canvas"></canvas>
                <div class="game-overlay" id="game-overlay" style="display: none;">
                    <div class="overlay-content">
                        <h2 id="overlay-title">Game Paused</h2>
                        <p id="overlay-message">Press P to resume</p>
                        <button id="restart-button" class="btn-secondary" style="display: none;">Restart</button>
                        <button id="leaderboard-button" class="btn-secondary" style="display: none;">View Leaderboard</button>
                    </div>
                </div>
            </div>

            <div class="game-sidebar right">
                <div class="next-area">
                    <h3>Next</h3>
                    <div class="next-pieces">
                        <div class="next-piece" id="next-0"></div>
                        <div class="next-piece" id="next-1"></div>
                        <div class="next-piece" id="next-2"></div>
                    </div>
                </div>
            </div>

            <!-- Mobile compact panels - hidden by default, shown on small screens -->
            <div class="info-panel">
                <div class="hold-stats-card">
                    <div class="hold-section">
                        <h4>Hold</h4>
                        <div class="hold-piece" id="mobile-hold-piece"></div>
                    </div>
                    <div class="stats-section">
                        <div class="stat-compact">
                            <span class="stat-label-small">Score</span>
                            <span class="stat-value-small" data-sync="score">0</span>
                        </div>
                        <div class="stat-compact">
                            <span class="stat-label-small">Lines</span>
                            <span class="stat-value-small" data-sync="lines">0</span>
                        </div>
                        <div class="stat-compact">
                            <span class="stat-label-small">Level</span>
                            <span class="stat-value-small" data-sync="level">1</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="next-panel">
                <div class="next-pieces-card">
                    <h4>Next</h4>
                    <div class="next-pieces-compact">
                        <div class="next-piece-small" id="mobile-next-0"></div>
                        <div class="next-piece-small" id="mobile-next-1"></div>
                        <div class="next-piece-small" id="mobile-next-2"></div>
                    </div>
                </div>
            </div>
        </main>
        </div> <!-- End of game-screen -->

        <div class="particles-container" id="particles"></div>
        
        
        <!-- Player Name Input Modal -->
        <div class="name-input-overlay" id="name-input-overlay" style="display: none;">
            <div class="name-input-content">
                <h2>New High Score!</h2>
                <p>Enter your name for the leaderboard:</p>
                <div class="input-group">
                    <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="50" autocomplete="name">
                    <div class="input-buttons">
                        <button id="save-score-button" class="btn-primary">Save Score</button>
                        <button id="skip-save-button" class="btn-secondary">Skip</button>
                    </div>
                </div>
                <div class="score-summary" id="score-summary">
                    <div class="score-item">
                        <span>Score:</span>
                        <span id="final-score">0</span>
                    </div>
                    <div class="score-item">
                        <span>Lines:</span>
                        <span id="final-lines">0</span>
                    </div>
                    <div class="score-item">
                        <span>Level:</span>
                        <span id="final-level">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Leaderboard Modal -->
        <div class="leaderboard-overlay" id="leaderboard-overlay" style="display: none;">
            <div class="leaderboard-content">
                <div class="leaderboard-header">
                    <h2> Leaderboard</h2>
                    <button id="close-leaderboard" class="btn-close"></button>
                </div>
                <div id="mode-selector-container" class="mode-selector-container">
                    <!-- Mode selector will be inserted here by JavaScript -->
                </div>
                <div class="leaderboard-tabs">
                    <button class="tab-button active" data-tab="top-scores">Top Scores</button>
                    <button class="tab-button" data-tab="recent">Recent Games</button>
                </div>
                <div class="leaderboard-list" id="leaderboard-list">
                    <div class="loading">Loading scores...</div>
                </div>
            </div>
        </div>
        
        <!-- Settings Modal -->
        <div class="settings-overlay" id="settings-overlay" style="display: none;">
            <div class="settings-content">
                <div class="settings-header">
                    <h2> Settings</h2>
                    <button id="close-settings" class="btn-close"></button>
                </div>
                
                <div class="settings-tabs">
                    <button class="settings-tab-button active" data-tab="audio"> Audio</button>
                    <button class="settings-tab-button" data-tab="controls"> Controls</button>
                </div>
                
                <div class="settings-panel" id="audio-panel">
                    <div class="setting-group">
                        <label>Master Volume</label>
                        <div class="volume-control">
                            <input type="range" id="master-volume" min="0" max="100" value="80">
                            <span id="master-volume-value">80%</span>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>Music Volume</label>
                        <div class="volume-control">
                            <input type="range" id="music-volume" min="0" max="100" value="80">
                            <span id="music-volume-value">80%</span>
                        </div>
                        <div class="setting-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="music-enabled" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">Background Music</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>Sound Effects Volume</label>
                        <div class="volume-control">
                            <input type="range" id="sfx-volume" min="0" max="100" value="70">
                            <span id="sfx-volume-value">70%</span>
                        </div>
                        <div class="setting-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="sfx-enabled" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">Sound Effects</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-panel" id="controls-panel" style="display: none;">
                    <div class="controls-info">
                        <h3>Keyboard Controls</h3>
                        <div class="controls-grid">
                            <div class="control-item">
                                <span class="control-key"></span>
                                <span class="control-action">Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key"></span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key"></span>
                                <span class="control-action">Rotate Clockwise</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">Space</span>
                                <span class="control-action">Hard Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">C</span>
                                <span class="control-action">Hold Piece</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">P</span>
                                <span class="control-action">Pause</span>
                            </div>
                        </div>
                        
                        <h3>Alternative Keys (WASD)</h3>
                        <div class="controls-grid">
                            <div class="control-item">
                                <span class="control-key">A/D</span>
                                <span class="control-action">Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">S</span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">W/E</span>
                                <span class="control-action">Rotate</span>
                            </div>
                            <div class="control-item">
                                <span class="control-key">Q</span>
                                <span class="control-action">Rotate Counter-clockwise</span>
                            </div>
                        </div>
                        
                        <h3>Mobile/Touch Controls</h3>
                        <div class="touch-controls-info">
                            <div class="touch-item">
                                <span class="touch-gesture"> Tap</span>
                                <span class="control-action">Rotate</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture"> Swipe Left/Right</span>
                                <span class="control-action">Move</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture"> Swipe Down</span>
                                <span class="control-action">Soft Drop</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture"> Swipe Up</span>
                                <span class="control-action">Hard Drop</span>
                            </div>
                            <div class="touch-item">
                                <span class="touch-gesture"> Long Press</span>
                                <span class="control-action">Hold Piece</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Help Modal -->
        <div class="help-overlay" id="help-overlay" style="display: none;">
            <div class="help-content">
                <div class="help-header">
                    <h2> How to Play</h2>
                    <button id="close-help" class="btn-close"></button>
                </div>
                
                <div class="help-tabs">
                    <button class="help-tab active" data-tab="keyboard"> Keyboard</button>
                    <button class="help-tab" data-tab="touch"> Touch</button>
                    <button class="help-tab" data-tab="scoring"> Scoring</button>
                </div>
                
                <div class="help-sections">
                    <!-- Keyboard Controls -->
                    <div class="help-section help-tab-content" id="keyboard-controls">
                        <h3> Keyboard Controls</h3>
                        <div class="controls-grid">
                            <div class="control-item">
                                <kbd></kbd><kbd></kbd>
                                <span>Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <kbd></kbd>
                                <span>Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <kbd></kbd>
                                <span>Rotate Clockwise</span>
                            </div>
                            <div class="control-item">
                                <kbd>Space</kbd>
                                <span>Hard Drop</span>
                            </div>
                            <div class="control-item">
                                <kbd>C</kbd>
                                <span>Hold Piece</span>
                            </div>
                            <div class="control-item">
                                <kbd>P</kbd>
                                <span>Pause Game</span>
                            </div>
                            <div class="control-item">
                                <kbd>Z</kbd>
                                <span>Rotate Counter-clockwise</span>
                            </div>
                            <div class="control-item">
                                <kbd>Esc</kbd>
                                <span>Back to Menu</span>
                            </div>
                        </div>
                        
                        <h4>Alternative Keys (WASD)</h4>
                        <div class="controls-grid">
                            <div class="control-item">
                                <kbd>A</kbd><kbd>D</kbd>
                                <span>Move Left/Right</span>
                            </div>
                            <div class="control-item">
                                <kbd>S</kbd>
                                <span>Soft Drop</span>
                            </div>
                            <div class="control-item">
                                <kbd>W</kbd>
                                <span>Rotate</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Touch Controls -->
                    <div class="help-section help-tab-content" id="touch-controls" style="display: none;">
                        <h3> Touch Controls</h3>
                        <div class="touch-controls-list">
                            <div class="touch-control">
                                <div class="gesture-icon"></div>
                                <div class="gesture-info">
                                    <strong>Tap</strong>
                                    <span>Rotate piece clockwise</span>
                                </div>
                            </div>
                            <div class="touch-control">
                                <div class="gesture-icon"></div>
                                <div class="gesture-info">
                                    <strong>Swipe Left/Right</strong>
                                    <span>Move piece horizontally</span>
                                </div>
                            </div>
                            <div class="touch-control">
                                <div class="gesture-icon"></div>
                                <div class="gesture-info">
                                    <strong>Swipe Down</strong>
                                    <span>Soft drop (faster fall)</span>
                                </div>
                            </div>
                            <div class="touch-control">
                                <div class="gesture-icon"></div>
                                <div class="gesture-info">
                                    <strong>Swipe Up</strong>
                                    <span>Hard drop (instant placement)</span>
                                </div>
                            </div>
                            <div class="touch-control">
                                <div class="gesture-icon"></div>
                                <div class="gesture-info">
                                    <strong>Long Press (0.8s)</strong>
                                    <span>Hold current piece</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Scoring System -->
                    <div class="help-section help-tab-content" id="scoring-system" style="display: none;">
                        <h3> Scoring System</h3>
                        
                        <h4>Basic Points</h4>
                        <div class="scoring-table">
                            <div class="score-row">
                                <span>Single Line</span>
                                <span class="score-value">100  Level</span>
                            </div>
                            <div class="score-row">
                                <span>Double Lines</span>
                                <span class="score-value">300  Level</span>
                            </div>
                            <div class="score-row">
                                <span>Triple Lines</span>
                                <span class="score-value">500  Level</span>
                            </div>
                            <div class="score-row">
                                <span>Tetris (4 lines)</span>
                                <span class="score-value">800  Level</span>
                            </div>
                        </div>
                        
                        <h4>Special Moves</h4>
                        <div class="special-moves-list">
                            <div class="special-move">
                                <strong>T-Spin:</strong>
                                <p>Rotate T-piece into tight spot for 2 points</p>
                            </div>
                            <div class="special-move">
                                <strong>Combo:</strong>
                                <p>Clear lines consecutively for increasing multipliers</p>
                            </div>
                            <div class="special-move">
                                <strong>Perfect Clear:</strong>
                                <p>Clear entire board for 1000 bonus points</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    
    <!-- Context Detection and Service Worker Registration -->
    
<script>

// Simple module system for standalone version
window.TetrisModules = {};
window.TetrisExports = {};

function defineModule(name, factory) {
    const module = { exports: {} };
    const exports = module.exports;
    factory(exports, module);
    window.TetrisModules[name] = module.exports;
    // Make exports available globally
    if (typeof module.exports === 'object') {
        Object.assign(window.TetrisExports, module.exports);
    }
}

// Override import/export for standalone

/* scripts/pieces.js */
(function() {
// Modern Tetris - Piece Definitions and Logic

window.PIECE_TYPES = const PIECE_TYPES = {
    I: 'I', O: 'O', T: 'T', S: 'S', Z: 'Z', J: 'J', L: 'L'
};

window.PIECE_COLORS = const PIECE_COLORS = {
    I: '#00d4ff',  // Neon Blue
    O: '#ffff00',  // Neon Yellow
    T: '#9d4edd',  // Neon Purple
    S: '#39ff14',  // Neon Green
    Z: '#ff0040',  // Neon Red
    J: '#0066ff',  // Blue
    L: '#ff8500'   // Neon Orange
};

// SRS (Super Rotation System) piece definitions
// Each piece has 4 rotation states (0, 1, 2, 3)
window.PIECE_SHAPES = const PIECE_SHAPES = {
    I: [
        [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // 0
        [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]], // 90
        [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]], // 180
        [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]  // 270
    ],
    O: [
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]], // All rotations same
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]]
    ],
    T: [
        [[0,1,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0
        [[0,1,0,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]], // 90
        [[0,0,0,0], [1,1,1,0], [0,1,0,0], [0,0,0,0]], // 180
        [[0,1,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270
    ],
    S: [
        [[0,1,1,0], [1,1,0,0], [0,0,0,0], [0,0,0,0]], // 0
        [[0,1,0,0], [0,1,1,0], [0,0,1,0], [0,0,0,0]], // 90
        [[0,0,0,0], [0,1,1,0], [1,1,0,0], [0,0,0,0]], // 180
        [[1,0,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270
    ],
    Z: [
        [[1,1,0,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]], // 0
        [[0,0,1,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]], // 90
        [[0,0,0,0], [1,1,0,0], [0,1,1,0], [0,0,0,0]], // 180
        [[0,1,0,0], [1,1,0,0], [1,0,0,0], [0,0,0,0]]  // 270
    ],
    J: [
        [[1,0,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0
        [[0,1,1,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]], // 90
        [[0,0,0,0], [1,1,1,0], [0,0,1,0], [0,0,0,0]], // 180
        [[0,1,0,0], [0,1,0,0], [1,1,0,0], [0,0,0,0]]  // 270
    ],
    L: [
        [[0,0,1,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]], // 0
        [[0,1,0,0], [0,1,0,0], [0,1,1,0], [0,0,0,0]], // 90
        [[0,0,0,0], [1,1,1,0], [1,0,0,0], [0,0,0,0]], // 180
        [[1,1,0,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]]  // 270
    ]
};

// SRS Wall Kick Data
window.WALL_KICKS = const WALL_KICKS = {
    // Standard pieces (J, L, S, T, Z)
    JLSTZ: {
        '0->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
        '1->0': [[1, 0], [1, -1], [0, 2], [1, 2]],
        '1->2': [[1, 0], [1, -1], [0, 2], [1, 2]],
        '2->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
        '2->3': [[1, 0], [1, 1], [0, -2], [1, -2]],
        '3->2': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
        '3->0': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
        '0->3': [[1, 0], [1, 1], [0, -2], [1, -2]]
    },
    // I piece has different wall kicks
    I: {
        '0->1': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
        '1->0': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
        '1->2': [[-1, 0], [2, 0], [-1, 2], [2, -1]],
        '2->1': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
        '2->3': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
        '3->2': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
        '3->0': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
        '0->3': [[-1, 0], [2, 0], [-1, 2], [2, -1]]
    }
};

window.Piece = class Piece {
    constructor(type, x = 3, y = 0) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.rotation = 0;
        this.color = PIECE_COLORS[type];
        this.shape = PIECE_SHAPES[type];
        this.lockDelay = 0;
        this.maxLockDelay = 500; // 500ms lock delay
        this.moved = false;
    }

    // Get current shape based on rotation
    getCurrentShape() {
        return this.shape[this.rotation];
    }

    // Get piece blocks with absolute positions
    getBlocks() {
        const blocks = [];
        const shape = this.getCurrentShape();
        
        for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                    blocks.push({
                        x: this.x + x,
                        y: this.y + y,
                        color: this.color
                    });
                }
            }
        }
        
        return blocks;
    }

    // Create a copy of the piece
    copy() {
        const newPiece = new Piece(this.type, this.x, this.y);
        newPiece.rotation = this.rotation;
        newPiece.lockDelay = this.lockDelay;
        newPiece.moved = this.moved;
        return newPiece;
    }

    // Move piece
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.moved = true;
        this.resetLockDelay();
    }

    // Rotate piece (returns new rotation state)
    getRotatedState(direction = 1) {
        const newRotation = (this.rotation + direction + 4) % 4;
        return newRotation;
    }

    // Apply rotation
    rotate(direction = 1) {
        this.rotation = this.getRotatedState(direction);
        this.moved = true;
        this.resetLockDelay();
    }

    // Reset lock delay when piece moves or rotates
    resetLockDelay() {
        this.lockDelay = 0;
    }

    // Update lock delay
    updateLockDelay(deltaTime) {
        this.lockDelay += deltaTime;
        return this.lockDelay >= this.maxLockDelay;
    }

    // Check if piece should lock
    shouldLock(grid) {
        // Check if piece can move down
        const testPiece = this.copy();
        testPiece.y += 1;
        return grid.checkCollision(testPiece);
    }
    
    // Save piece state
    saveState() {
        return {
            type: this.type,
            x: this.x,
            y: this.y,
            rotation: this.rotation,
            color: this.color
        };
    }
    
    // Load piece state
    loadState(state) {
        if (state) {
            this.type = state.type;
            this.x = state.x;
            this.y = state.y;
            this.rotation = state.rotation;
            this.color = state.color;
        }
    }
}

// 7-Bag Random Generator for fair piece distribution
window.PieceBag = class PieceBag {
    constructor() {
        this.bag = [];
        this.refillBag();
    }

    refillBag() {
        const pieces = Object.values(PIECE_TYPES);
        // Shuffle using Fisher-Yates algorithm
        for (let i = pieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        this.bag = pieces;
    }

    getNextPiece() {
        if (this.bag.length === 0) {
            this.refillBag();
        }
        const pieceType = this.bag.pop();
        return new Piece(pieceType);
    }

    // Preview next N pieces without removing them
    previewPieces(count = 3) {
        const preview = [];
        let tempBag = [...this.bag];
        let tempPieces = Object.values(PIECE_TYPES);
        
        for (let i = 0; i < count; i++) {
            if (tempBag.length === 0) {
                // Shuffle new bag
                for (let j = tempPieces.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [tempPieces[j], tempPieces[k]] = [tempPieces[k], tempPieces[j]];
                }
                tempBag = [...tempPieces];
            }
            preview.push(tempBag.pop());
        }
        
        return preview;
    }
}

// T-Spin Detection
window.TSpinDetector = class TSpinDetector {
    static isTSpin(piece, grid, previousPosition) {
        if (piece.type !== 'T') return { type: 'none', mini: false };
        
        const corners = this.getCorners(piece);
        let filledCorners = 0;
        let frontCorners = 0;
        
        // Check which corners are filled
        corners.forEach((corner, index) => {
            if (grid.isOccupied(corner.x, corner.y)) {
                filledCorners++;
                if (index < 2) frontCorners++; // Front corners (relative to rotation)
            }
        });
        
        // T-Spin requires at least 3 filled corners
        if (filledCorners < 3) return { type: 'none', mini: false };
        
        // Check if the piece was rotated into position
        const wasRotated = previousPosition && 
            (previousPosition.rotation !== piece.rotation);
        
        if (!wasRotated) return { type: 'none', mini: false };
        
        // T-Spin Mini: Only 3 corners filled, or back corners filled
        const isMini = filledCorners === 3 || frontCorners < 2;
        
        return {
            type: 'tspin',
            mini: isMini
        };
    }
    
    static getCorners(piece) {
        const rotation = piece.rotation;
        const baseCorners = [
            { x: piece.x, y: piece.y },         // Top-left
            { x: piece.x + 2, y: piece.y },     // Top-right
            { x: piece.x, y: piece.y + 2 },     // Bottom-left
            { x: piece.x + 2, y: piece.y + 2 }  // Bottom-right
        ];
        
        // Adjust corners based on T-piece rotation
        switch (rotation) {
            case 0: return [baseCorners[0], baseCorners[1], baseCorners[2], baseCorners[3]];
            case 1: return [baseCorners[1], baseCorners[3], baseCorners[0], baseCorners[2]];
            case 2: return [baseCorners[3], baseCorners[2], baseCorners[1], baseCorners[0]];
            case 3: return [baseCorners[2], baseCorners[0], baseCorners[3], baseCorners[1]];
        }
    }
}
})();

/* scripts/grid.js */
(function() {
// Modern Tetris - Grid Management and Collision Detection

window.GRID_WIDTH = const GRID_WIDTH = 10;
window.GRID_HEIGHT = const GRID_HEIGHT = 20;
window.GRID_HIDDEN_ROWS = const GRID_HIDDEN_ROWS = 4; // Hidden rows above visible area

window.Grid = class Grid {
    constructor() {
        this.width = GRID_WIDTH;
        this.height = GRID_HEIGHT + GRID_HIDDEN_ROWS;
        this.cells = this.createEmptyGrid();
        this.linesCleared = 0;
        this.totalLines = 0;
    }

    // Create empty grid
    createEmptyGrid() {
        return Array(this.height).fill(null).map(() => 
            Array(this.width).fill(null)
        );
    }

    // Check if coordinates are within grid bounds
    isInBounds(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height;
    }

    // Check if cell is occupied
    isOccupied(x, y) {
        if (!this.isInBounds(x, y)) return true; // Out of bounds = occupied
        return this.cells[y][x] !== null;
    }

    // Get cell value
    getCell(x, y) {
        if (!this.isInBounds(x, y)) return null;
        return this.cells[y][x];
    }

    // Set cell value
    setCell(x, y, value) {
        if (this.isInBounds(x, y)) {
            this.cells[y][x] = value;
        }
    }

    // Check collision with piece
    checkCollision(piece) {
        const blocks = piece.getBlocks();
        
        for (const block of blocks) {
            if (this.isOccupied(block.x, block.y)) {
                return true;
            }
        }
        
        return false;
    }

    // Place piece on grid
    placePiece(piece) {
        const blocks = piece.getBlocks();
        
        for (const block of blocks) {
            if (this.isInBounds(block.x, block.y)) {
                this.cells[block.y][block.x] = {
                    color: block.color,
                    type: piece.type
                };
            }
        }
    }

    // Check for completed lines
    getCompletedLines() {
        const completedLines = [];
        
        for (let y = 0; y < this.height; y++) {
            if (this.isLineFull(y)) {
                completedLines.push(y);
            }
        }
        
        return completedLines;
    }

    // Check if line is full
    isLineFull(y) {
        if (!this.isInBounds(0, y)) return false;
        
        for (let x = 0; x < this.width; x++) {
            if (this.cells[y][x] === null) {
                return false;
            }
        }
        
        return true;
    }

    // Clear completed lines and return line count
    clearLines(linesToClear = null) {
        let completedLines = linesToClear || this.getCompletedLines();
        
        if (completedLines.length === 0) return 0;
        
        // Create a new grid without the completed lines
        const newCells = [];
        let actualClearedCount = 0;
        
        // Add empty lines at the top for each cleared line
        for (let i = 0; i < completedLines.length; i++) {
            newCells.push(Array(this.width).fill(null));
        }
        
        // Copy all non-completed lines to the new grid
        for (let y = 0; y < this.height; y++) {
            if (!completedLines.includes(y)) {
                newCells.push([...this.cells[y]]);
            } else {
                actualClearedCount++;
            }
        }
        
        // Replace the old grid with the new one
        this.cells = newCells;
        
        this.linesCleared = actualClearedCount;
        this.totalLines += actualClearedCount;
        
        return actualClearedCount;
    }

    // Get line clearing info for animations
    getLineClearInfo() {
        const completedLines = this.getCompletedLines();
        return {
            lines: completedLines,
            count: completedLines.length,
            isSpecial: this.isSpecialClear(completedLines.length)
        };
    }

    // Check for special clears
    isSpecialClear(lineCount) {
        switch (lineCount) {
            case 1: return 'single';
            case 2: return 'double';
            case 3: return 'triple';
            case 4: return 'tetris';
            default: return null;
        }
    }

    // Check for perfect clear (empty grid)
    isPerfectClear() {
        for (let y = GRID_HIDDEN_ROWS; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    return false;
                }
            }
        }
        return true;
    }

    // Get visible grid (without hidden rows)
    getVisibleGrid() {
        return this.cells.slice(GRID_HIDDEN_ROWS);
    }

    // Check game over condition
    isGameOver() {
        // Check if any blocks are above the visible area
        for (let y = 0; y < GRID_HIDDEN_ROWS; y++) {
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Reset grid
    reset() {
        this.cells = this.createEmptyGrid();
        this.linesCleared = 0;
        this.totalLines = 0;
    }
    
    // Load grid from array (for puzzle mode)
    loadFromArray(gridArray) {
        if (!gridArray || !Array.isArray(gridArray)) return;
        
        // Create a new grid with the provided data
        this.cells = this.createEmptyGrid();
        
        // The gridArray represents the visible portion of the grid (20 rows)
        // We need to map it to our internal grid which has hidden rows at the top
        const startRow = GRID_HIDDEN_ROWS; // Start after hidden rows
        
        for (let row = 0; row < gridArray.length && row < GRID_HEIGHT; row++) {
            if (!gridArray[row]) continue;
            for (let col = 0; col < gridArray[row].length && col < this.width; col++) {
                // Map non-zero values to colors (1-7 for standard pieces)
                const value = gridArray[row][col];
                if (value > 0) {
                    // Place in the visible area of the grid
                    this.cells[startRow + row][col] = value;
                }
            }
        }
    }
    
    // Check if grid is empty (for perfect clear)
    isEmpty() {
        for (let row = 0; row < this.height; row++) {
            for (let col = 0; col < this.width; col++) {
                if (this.cells[row][col] !== null && this.cells[row][col] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    
    // Save grid state
    saveState() {
        return {
            cells: this.cells.map(row => [...row]),
            linesCleared: this.linesCleared,
            totalLines: this.totalLines
        };
    }
    
    // Load grid state
    loadState(state) {
        if (state && state.cells) {
            this.cells = state.cells.map(row => [...row]);
            this.linesCleared = state.linesCleared || 0;
            this.totalLines = state.totalLines || 0;
        }
    }
    
    // Check for game over
    checkGameOver() {
        // Check if any cells in the hidden rows (top 4 rows) are occupied
        for (let row = 0; row < GRID_HIDDEN_ROWS; row++) {
            for (let col = 0; col < this.width; col++) {
                if (this.cells[row][col] !== null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Get grid state for rendering
    getRenderData() {
        const visibleGrid = this.getVisibleGrid();
        const renderData = [];
        
        for (let y = 0; y < visibleGrid.length; y++) {
            for (let x = 0; x < this.width; x++) {
                const cell = visibleGrid[y][x];
                if (cell !== null) {
                    renderData.push({
                        x,
                        y,
                        color: cell.color,
                        type: cell.type
                    });
                }
            }
        }
        
        return renderData;
    }

    // Test piece movement (returns valid position or null)
    testPieceMovement(piece, dx, dy) {
        const testPiece = piece.copy();
        testPiece.move(dx, dy);
        
        return this.checkCollision(testPiece) ? null : testPiece;
    }

    // Test piece rotation with wall kicks
    testPieceRotation(piece, direction = 1) {
        const newRotation = piece.getRotatedState(direction);
        const testPiece = piece.copy();
        testPiece.rotation = newRotation;
        
        // Get wall kick tests
        const wallKicks = this.getWallKicks(piece, direction);
        
        // Test original position first
        if (!this.checkCollision(testPiece)) {
            return testPiece;
        }
        
        // Try wall kicks
        for (const kick of wallKicks) {
            const kickTestPiece = testPiece.copy();
            kickTestPiece.x += kick[0];
            kickTestPiece.y += kick[1];
            
            if (!this.checkCollision(kickTestPiece)) {
                return kickTestPiece;
            }
        }
        
        return null; // Rotation not possible
    }

    // Get wall kick tests for rotation
    getWallKicks(piece, direction) {
        // Import WALL_KICKS synchronously from pieces module
        // This will be handled by the game engine which has already imported the module
        
        const from = piece.rotation;
        const to = piece.getRotatedState(direction);
        const kickKey = `${from}->${to}`;
        
        // Wall kick data defined here to avoid async import issues
        const WALL_KICKS = {
            JLSTZ: {
                '0->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '1->0': [[1, 0], [1, -1], [0, 2], [1, 2]],
                '1->2': [[1, 0], [1, -1], [0, 2], [1, 2]],
                '2->1': [[-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '2->3': [[1, 0], [1, 1], [0, -2], [1, -2]],
                '3->2': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '3->0': [[-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '0->3': [[1, 0], [1, 1], [0, -2], [1, -2]]
            },
            I: {
                '0->1': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
                '1->0': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
                '1->2': [[-1, 0], [2, 0], [-1, 2], [2, -1]],
                '2->1': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
                '2->3': [[2, 0], [-1, 0], [2, 1], [-1, -2]],
                '3->2': [[-2, 0], [1, 0], [-2, -1], [1, 2]],
                '3->0': [[1, 0], [-2, 0], [1, -2], [-2, 1]],
                '0->3': [[-1, 0], [2, 0], [-1, 2], [2, -1]]
            }
        };
        
        if (piece.type === 'I') {
            return WALL_KICKS.I[kickKey] || [];
        } else if (piece.type === 'O') {
            return []; // O piece doesn't need wall kicks
        } else {
            return WALL_KICKS.JLSTZ[kickKey] || [];
        }
    }

    // Get ghost piece position (hard drop preview)
    getGhostPosition(piece) {
        const ghostPiece = piece.copy();
        
        // Move down until collision
        while (!this.checkCollision(ghostPiece)) {
            ghostPiece.y += 1;
        }
        
        // Move back one step
        ghostPiece.y -= 1;
        
        return ghostPiece;
    }

    // Calculate drop distance for scoring
    getDropDistance(fromY, toY) {
        return Math.max(0, toY - fromY);
    }

    // Get grid statistics
    getStats() {
        let occupiedCells = 0;
        let highestRow = this.height;
        
        for (let y = GRID_HIDDEN_ROWS; y < this.height; y++) {
            let rowHasCells = false;
            for (let x = 0; x < this.width; x++) {
                if (this.cells[y][x] !== null) {
                    occupiedCells++;
                    rowHasCells = true;
                }
            }
            if (rowHasCells && y < highestRow) {
                highestRow = y;
            }
        }
        
        return {
            occupiedCells,
            height: highestRow === this.height ? 0 : (this.height - highestRow),
            totalLines: this.totalLines,
            isEmpty: occupiedCells === 0
        };
    }


    // Deep copy grid state
    copy() {
        const newGrid = new Grid();
        newGrid.cells = this.cells.map(row => [...row]);
        newGrid.linesCleared = this.linesCleared;
        newGrid.totalLines = this.totalLines;
        return newGrid;
    }
}
})();

/* scripts/storage-adapter.js */
(function() {
// Unified Storage Adapter - Works in both file:// and http:// contexts
window.StorageAdapter = class StorageAdapter {
    constructor() {
        // Detect execution context
        this.isFileProtocol = window.location.protocol === 'file:';
        this.hasServiceWorker = 'serviceWorker' in navigator && !this.isFileProtocol;
        this.hasIndexedDB = 'indexedDB' in window && !this.isFileProtocol;
        
        // Choose storage method based on context
        this.storageMethod = this.isFileProtocol ? 'localStorage' : 'hybrid';
        
        // Storage limits
        this.localStorageLimit = 5 * 1024 * 1024; // 5MB typical limit
        this.compressionEnabled = true;
        
        // Initialize IndexedDB if available
        this.db = null;
        this.dbName = 'TetrisUnifiedDB';
        this.dbVersion = 1;
        
        if (this.hasIndexedDB) {
            this.initIndexedDB();
        }
        
        console.log(`Storage Adapter initialized - Mode: ${this.storageMethod}, File Protocol: ${this.isFileProtocol}`);
    }
    
    // Initialize IndexedDB for http:// context
    async initIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.warn('IndexedDB not available, falling back to localStorage');
                this.storageMethod = 'localStorage';
                resolve(null);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                console.log('IndexedDB initialized successfully');
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create stores for different data types
                if (!db.objectStoreNames.contains('gameStates')) {
                    db.createObjectStore('gameStates', { keyPath: 'key' });
                }
                if (!db.objectStoreNames.contains('scores')) {
                    db.createObjectStore('scores', { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
        });
    }
    
    // Compress data if needed (for localStorage)
    compress(data) {
        if (!this.compressionEnabled) return data;
        
        try {
            // Simple compression using JSON stringify and base64
            const jsonStr = JSON.stringify(data);
            // For better compression, we could use LZ-string library if available
            if (typeof LZString !== 'undefined') {
                return LZString.compressToUTF16(jsonStr);
            }
            return jsonStr;
        } catch (e) {
            console.error('Compression failed:', e);
            return JSON.stringify(data);
        }
    }
    
    // Decompress data
    decompress(data) {
        if (!this.compressionEnabled || !data) return null;
        
        try {
            // Check if LZ-string is available
            if (typeof LZString !== 'undefined' && data.charAt(0) !== '{' && data.charAt(0) !== '[') {
                const decompressed = LZString.decompressFromUTF16(data);
                return JSON.parse(decompressed);
            }
            return JSON.parse(data);
        } catch (e) {
            console.error('Decompression failed:', e);
            return null;
        }
    }
    
    // Save data - unified interface
    async save(key, data, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.saveToLocalStorage(key, data);
        } else {
            return this.saveToIndexedDB(key, data, store);
        }
    }
    
    // Load data - unified interface
    async load(key, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.loadFromLocalStorage(key);
        } else {
            return this.loadFromIndexedDB(key, store);
        }
    }
    
    // Delete data - unified interface
    async delete(key, store = 'gameStates') {
        if (this.storageMethod === 'localStorage' || !this.db) {
            return this.deleteFromLocalStorage(key);
        } else {
            return this.deleteFromIndexedDB(key, store);
        }
    }
    
    // LocalStorage operations
    saveToLocalStorage(key, data) {
        try {
            const compressed = this.compress(data);
            const fullKey = `tetris_${key}`;
            
            // Check storage quota
            const dataSize = compressed.length * 2; // Rough estimate (UTF-16)
            if (dataSize > this.localStorageLimit) {
                console.warn(`Data too large for localStorage (${dataSize} bytes)`);
                // Try to clean old data
                this.cleanOldLocalStorageData();
            }
            
            localStorage.setItem(fullKey, compressed);
            return Promise.resolve(true);
        } catch (e) {
            console.error('localStorage save failed:', e);
            if (e.name === 'QuotaExceededError') {
                this.cleanOldLocalStorageData();
                // Retry once
                try {
                    const compressed = this.compress(data);
                    localStorage.setItem(`tetris_${key}`, compressed);
                    return Promise.resolve(true);
                } catch (retryError) {
                    return Promise.reject(retryError);
                }
            }
            return Promise.reject(e);
        }
    }
    
    loadFromLocalStorage(key) {
        try {
            const fullKey = `tetris_${key}`;
            const compressed = localStorage.getItem(fullKey);
            if (!compressed) return Promise.resolve(null);
            
            const data = this.decompress(compressed);
            return Promise.resolve(data);
        } catch (e) {
            console.error('localStorage load failed:', e);
            return Promise.resolve(null);
        }
    }
    
    deleteFromLocalStorage(key) {
        try {
            const fullKey = `tetris_${key}`;
            localStorage.removeItem(fullKey);
            return Promise.resolve(true);
        } catch (e) {
            console.error('localStorage delete failed:', e);
            return Promise.reject(e);
        }
    }
    
    // IndexedDB operations
    async saveToIndexedDB(key, data, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.saveToLocalStorage(key, data);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const record = {
                key: key,
                data: data,
                timestamp: Date.now()
            };
            
            const request = store.put(record);
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                console.error('IndexedDB save failed:', request.error);
                // Fallback to localStorage
                this.saveToLocalStorage(key, data).then(resolve).catch(reject);
            };
        });
    }
    
    async loadFromIndexedDB(key, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.loadFromLocalStorage(key);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            
            request.onsuccess = () => {
                const result = request.result;
                resolve(result ? result.data : null);
            };
            
            request.onerror = () => {
                console.error('IndexedDB load failed:', request.error);
                // Fallback to localStorage
                this.loadFromLocalStorage(key).then(resolve).catch(reject);
            };
        });
    }
    
    async deleteFromIndexedDB(key, storeName) {
        if (!this.db) {
            // Fallback to localStorage if IndexedDB not available
            return this.deleteFromLocalStorage(key);
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(key);
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                console.error('IndexedDB delete failed:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Clean old localStorage data to free space
    cleanOldLocalStorageData() {
        const keysToCheck = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('tetris_')) {
                keysToCheck.push(key);
            }
        }
        
        // Sort by timestamp if available, otherwise delete oldest entries
        const itemsWithTime = keysToCheck.map(key => {
            try {
                const data = localStorage.getItem(key);
                const parsed = this.decompress(data);
                return {
                    key,
                    timestamp: parsed?.timestamp || 0,
                    size: data.length * 2
                };
            } catch {
                return { key, timestamp: 0, size: 0 };
            }
        });
        
        // Sort by timestamp (oldest first)
        itemsWithTime.sort((a, b) => a.timestamp - b.timestamp);
        
        // Remove oldest 25% of items
        const toRemove = Math.floor(itemsWithTime.length * 0.25);
        for (let i = 0; i < toRemove; i++) {
            localStorage.removeItem(itemsWithTime[i].key);
            console.log(`Cleaned old data: ${itemsWithTime[i].key}`);
        }
    }
    
    // Get storage info
    async getStorageInfo() {
        const info = {
            method: this.storageMethod,
            isFileProtocol: this.isFileProtocol,
            hasServiceWorker: this.hasServiceWorker,
            hasIndexedDB: this.hasIndexedDB
        };
        
        if (this.storageMethod === 'localStorage') {
            let totalSize = 0;
            let itemCount = 0;
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tetris_')) {
                    const value = localStorage.getItem(key);
                    totalSize += (key.length + value.length) * 2; // UTF-16
                    itemCount++;
                }
            }
            
            info.localStorage = {
                itemCount,
                estimatedSize: totalSize,
                estimatedSizeMB: (totalSize / (1024 * 1024)).toFixed(2)
            };
        }
        
        if (this.db && navigator.storage && navigator.storage.estimate) {
            const estimate = await navigator.storage.estimate();
            info.indexedDB = {
                usage: estimate.usage,
                quota: estimate.quota,
                usageMB: (estimate.usage / (1024 * 1024)).toFixed(2),
                quotaMB: (estimate.quota / (1024 * 1024)).toFixed(2)
            };
        }
        
        return info;
    }
    
    // Check if running in offline-capable context
    isOfflineCapable() {
        return true; // Always capable with this adapter
    }
    
    // Get appropriate asset path based on context
    getAssetPath(path) {
        if (this.isFileProtocol) {
            // For file:// protocol, use relative paths
            return path.startsWith('/') ? '.' + path : path;
        }
        return path;
    }
}

// Create singleton instance
window.storage = const storage = new StorageAdapter();

// Expose globally for debugging
if (typeof window !== 'undefined') {
    window.TetrisStorage = storage;
}
})();

/* scripts/offline-storage.js */
(function() {
// Offline Storage Manager using IndexedDB
window.OfflineStorage = class OfflineStorage {
    constructor() {
        this.dbName = 'TetrisOfflineDB';
        this.dbVersion = 1;
        this.db = null;
        this.isOnline = navigator.onLine;
        this.pendingSyncCount = 0;
        
        this.initializeDB();
        this.setupEventListeners();
        this.checkPendingScores();
    }
    
    // Initialize IndexedDB
    async initializeDB() {
        // Check if IndexedDB is available and not in private mode
        if (!window.indexedDB) {
            console.warn('IndexedDB not available');
            return null;
        }
        
        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = () => {
                    console.warn('Failed to open IndexedDB:', request.error);
                    // Don't reject, just resolve with null to fallback to localStorage
                    resolve(null);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    
                    // Handle database closing errors
                    this.db.onerror = (event) => {
                        console.error('Database error:', event.target.error);
                    };
                    
                    this.db.onabort = (event) => {
                        console.error('Database transaction aborted:', event.target.error);
                    };
                    
                    console.log('IndexedDB initialized successfully');
                    resolve(this.db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains('scores')) {
                        const scoresStore = db.createObjectStore('scores', { 
                            keyPath: 'id', 
                            autoIncrement: true 
                        });
                        // Only create index if it doesn't exist
                        if (!scoresStore.indexNames.contains('synced')) {
                            scoresStore.createIndex('synced', 'synced', { unique: false });
                        }
                        if (!scoresStore.indexNames.contains('timestamp')) {
                            scoresStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    }
                    
                    if (!db.objectStoreNames.contains('leaderboard_cache')) {
                        const cacheStore = db.createObjectStore('leaderboard_cache', { 
                            keyPath: 'type' 
                        });
                        if (!cacheStore.indexNames.contains('timestamp')) {
                            cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    }
                    
                    console.log('IndexedDB schema created/updated');
                };
                
                request.onblocked = () => {
                    console.warn('IndexedDB blocked - close other tabs using this site');
                    resolve(null);
                };
            } catch (error) {
                console.warn('IndexedDB initialization error:', error);
                resolve(null);
            }
        });
    }
    
    // Setup online/offline event listeners
    setupEventListeners() {
        window.addEventListener('online', () => {
            console.log('Connection restored');
            this.isOnline = true;
            this.syncPendingScores();
            this.showNotification('Back online! Syncing scores...', 'success');
        });
        
        window.addEventListener('offline', () => {
            console.log('Connection lost');
            this.isOnline = false;
            this.showNotification('You are offline. Scores will be saved locally.', 'warning');
        });
        
        // Listen for messages from Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'SYNC_SCORES') {
                    this.syncPendingScores();
                }
            });
        }
    }
    
    // Save score locally
    async saveScoreLocally(scoreData) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readwrite');
        const store = transaction.objectStore('scores');
        
        const score = {
            ...scoreData,
            timestamp: Date.now(),
            synced: false
        };
        
        return new Promise((resolve, reject) => {
            const request = store.add(score);
            
            request.onsuccess = () => {
                console.log('Score saved locally:', request.result);
                this.pendingSyncCount++;
                this.updateSyncIndicator();
                resolve(request.result);
            };
            
            request.onerror = () => {
                console.error('Failed to save score locally:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Get all unsynced scores
    async getUnsyncedScores() {
        if (!this.db) {
            await this.initializeDB();
        }
        
        // If still no DB (IndexedDB not available), return empty array
        if (!this.db) {
            console.warn('IndexedDB not available, cannot get unsynced scores');
            return [];
        }
        
        try {
            const transaction = this.db.transaction(['scores'], 'readonly');
            const store = transaction.objectStore('scores');
            
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                
                request.onsuccess = () => {
                    // Filter for unsynced scores manually
                    const allScores = request.result || [];
                    const unsyncedScores = allScores.filter(score => score.synced === false);
                    resolve(unsyncedScores);
                };
                
                request.onerror = () => {
                    console.warn('Error getting unsynced scores:', request.error);
                    resolve([]); // Return empty array instead of rejecting
                };
            });
        } catch (error) {
            console.warn('Transaction error:', error);
            return [];
        }
    }
    
    // Mark score as synced
    async markScoreAsSynced(scoreId) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readwrite');
        const store = transaction.objectStore('scores');
        
        return new Promise((resolve, reject) => {
            const getRequest = store.get(scoreId);
            
            getRequest.onsuccess = () => {
                const score = getRequest.result;
                if (score) {
                    score.synced = true;
                    const updateRequest = store.put(score);
                    
                    updateRequest.onsuccess = () => {
                        this.pendingSyncCount = Math.max(0, this.pendingSyncCount - 1);
                        this.updateSyncIndicator();
                        resolve();
                    };
                    
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve();
                }
            };
            
            getRequest.onerror = () => reject(getRequest.error);
        });
    }
    
    // Sync pending scores with server
    async syncPendingScores() {
        if (!this.isOnline) {
            console.log('Cannot sync: offline');
            return;
        }
        
        const unsyncedScores = await this.getUnsyncedScores();
        
        if (unsyncedScores.length === 0) {
            console.log('No scores to sync');
            return;
        }
        
        console.log(`Syncing ${unsyncedScores.length} pending scores...`);
        this.showNotification(`Syncing ${unsyncedScores.length} pending scores...`, 'info');
        
        let syncedCount = 0;
        
        for (const score of unsyncedScores) {
            try {
                const response = await fetch('api/scores.php?action=save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerName: score.playerName,
                        score: score.score,
                        lines: score.lines,
                        level: score.level,
                        gameDuration: score.gameDuration,
                        specialAchievements: score.specialAchievements || {}
                    })
                });
                
                if (response.ok) {
                    await this.markScoreAsSynced(score.id);
                    syncedCount++;
                }
            } catch (error) {
                console.error('Failed to sync score:', error);
            }
        }
        
        if (syncedCount > 0) {
            this.showNotification(`${syncedCount} scores synced successfully!`, 'success');
        }
        
        return syncedCount;
    }
    
    // Cache leaderboard data
    async cacheLeaderboardData(type, data) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['leaderboard_cache'], 'readwrite');
        const store = transaction.objectStore('leaderboard_cache');
        
        const cacheEntry = {
            type: type, // 'top-scores' or 'recent'
            data: data,
            timestamp: Date.now()
        };
        
        return new Promise((resolve, reject) => {
            const request = store.put(cacheEntry);
            
            request.onsuccess = () => {
                console.log(`Cached ${type} leaderboard data`);
                resolve();
            };
            
            request.onerror = () => {
                console.error('Failed to cache leaderboard data:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Get cached leaderboard data
    async getCachedLeaderboardData(type) {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['leaderboard_cache'], 'readonly');
        const store = transaction.objectStore('leaderboard_cache');
        
        return new Promise((resolve, reject) => {
            const request = store.get(type);
            
            request.onsuccess = () => {
                const cached = request.result;
                if (cached) {
                    // Check if cache is less than 1 hour old
                    const isRecent = (Date.now() - cached.timestamp) < 3600000;
                    resolve({
                        data: cached.data,
                        timestamp: cached.timestamp,
                        isRecent: isRecent
                    });
                } else {
                    resolve(null);
                }
            };
            
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    
    // Get all local scores (synced and unsynced)
    async getAllLocalScores() {
        if (!this.db) {
            await this.initializeDB();
        }
        
        const transaction = this.db.transaction(['scores'], 'readonly');
        const store = transaction.objectStore('scores');
        
        return new Promise((resolve, reject) => {
            const request = store.getAll();
            
            request.onsuccess = () => {
                const scores = request.result || [];
                // Sort by score descending
                scores.sort((a, b) => b.score - a.score);
                resolve(scores);
            };
            
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    
    // Check for pending scores on startup
    async checkPendingScores() {
        try {
            const unsyncedScores = await this.getUnsyncedScores();
            this.pendingSyncCount = unsyncedScores.length;
            this.updateSyncIndicator();
            
            // Auto-sync if online
            if (this.isOnline && this.pendingSyncCount > 0) {
                setTimeout(() => this.syncPendingScores(), 2000);
            }
        } catch (error) {
            console.warn('Could not check pending scores:', error);
            this.pendingSyncCount = 0;
            this.updateSyncIndicator();
        }
    }
    
    // Update UI sync indicator
    updateSyncIndicator() {
        // Disabled - using mode-indicator in index.html instead
        // to avoid duplicate indicators
        return;
        
        /* Original code commented out to prevent conflicts
        const indicator = document.getElementById('offline-indicator');
        if (!indicator) {
            // Create indicator if it doesn't exist
            const div = document.createElement('div');
            div.id = 'offline-indicator';
            div.className = 'offline-indicator';
            document.body.appendChild(div);
        }
        
        const indicatorEl = document.getElementById('offline-indicator');
        
        if (!this.isOnline) {
            indicatorEl.innerHTML = `
                <span class="offline-icon"></span>
                <span>Offline Mode</span>
                ${this.pendingSyncCount > 0 ? `<span class="pending-count">${this.pendingSyncCount} pending</span>` : ''}
            `;
            indicatorEl.classList.add('visible', 'offline');
            indicatorEl.classList.remove('online');
        } else if (this.pendingSyncCount > 0) {
            indicatorEl.innerHTML = `
                <span class="sync-icon"></span>
                <span>Syncing ${this.pendingSyncCount} scores...</span>
            `;
            indicatorEl.classList.add('visible', 'syncing');
            indicatorEl.classList.remove('offline', 'online');
        } else {
            indicatorEl.classList.remove('visible', 'offline', 'syncing');
            indicatorEl.classList.add('online');
        }
        */
    }
    
    // Show notification
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `offline-notification ${type}`;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => notification.classList.add('visible'), 10);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.classList.remove('visible');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
    
    // Register background sync
    async registerBackgroundSync() {
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
            try {
                const registration = await navigator.serviceWorker.ready;
                await registration.sync.register('sync-scores');
                console.log('Background sync registered');
            } catch (error) {
                console.error('Failed to register background sync:', error);
            }
        }
    }
}

// Export singleton instance
window.offlineStorage = const offlineStorage = new OfflineStorage();
})();

/* scripts/audio.js */
(function() {
// Modern Tetris - 80s Style Audio System

window.AudioManager = class AudioManager {
    constructor() {
        this.audioContext = null;
        this.masterGain = null;
        this.musicGain = null;
        this.sfxGain = null;
        
        // Audio settings - Balanced for comfortable extended play
        this.settings = {
            masterVolume: 0.7,    // Reduced master for better headroom
            musicVolume: 0.5,     // Background music level - present but not overwhelming
            sfxVolume: 0.7,       // Clear sound effects that cut through
            musicEnabled: true,
            sfxEnabled: true
        };
        
        // Master mute state
        this.masterMuted = false;
        
        // Load settings from localStorage
        this.loadSettings();
        
        // Background music state
        this.currentMusic = null;
        this.musicLoop = null;
        this.musicTimeout = null;
        this.currentMusicNotes = [];
        this.currentGameLevel = 1; // Track game level for adaptive music
        
        this.initializeAudioContext();
    }

    async initializeAudioContext() {
        try {
            // Check if Web Audio API is supported
            if (!(window.AudioContext || window.webkitAudioContext)) {
                throw new Error('Web Audio API not supported');
            }
            
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create gain nodes for volume control
            this.masterGain = this.audioContext.createGain();
            this.musicGain = this.audioContext.createGain();
            this.sfxGain = this.audioContext.createGain();
            
            // Connect gain nodes
            this.musicGain.connect(this.masterGain);
            this.sfxGain.connect(this.masterGain);
            this.masterGain.connect(this.audioContext.destination);
            
            // Set initial volumes
            this.updateVolumes();
            
        } catch (error) {
            this.audioContext = null;
            this.showAudioError('Audio not available: ' + error.message);
        }
    }

    // Show audio error to user
    showAudioError(message) {
        // Silent error handling - removed console.warn
        
        // Create a temporary notification element
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 10000;
            font-family: Arial, sans-serif;
            font-size: 14px;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    // Ensure audio context is resumed (required for user interaction)
    async resumeAudioContext() {
        if (!this.audioContext) {
            return false;
        }
        
        if (this.audioContext.state === 'suspended') {
            try {
                await this.audioContext.resume();
                return true;
            } catch (error) {
                this.showAudioError('Failed to resume audio: ' + error.message);
                return false;
            }
        }
        
        return this.audioContext.state === 'running';
    }

    // Load audio settings from localStorage
    loadSettings() {
        const saved = localStorage.getItem('tetris_audio_settings');
        if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
        }
    }

    // Save audio settings to localStorage
    saveSettings() {
        localStorage.setItem('tetris_audio_settings', JSON.stringify(this.settings));
    }

    // Update all volume levels
    updateVolumes() {
        if (!this.audioContext) return;
        
        // Only update master volume if not muted
        if (!this.masterMuted) {
            this.masterGain.gain.value = this.settings.masterVolume;
        }
        this.musicGain.gain.value = this.settings.musicEnabled ? this.settings.musicVolume : 0;
        this.sfxGain.gain.value = this.settings.sfxEnabled ? this.settings.sfxVolume : 0;
    }

    // Generate 80s-style synthesizer tones
    createOscillator(frequency, type = 'square', duration = 0.1) {
        if (!this.audioContext) return null;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        
        // 80s-style envelope (attack, decay, sustain, release)
        const now = this.audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack
        gainNode.gain.exponentialRampToValueAtTime(0.1, now + duration * 0.3); // Decay
        gainNode.gain.setValueAtTime(0.1, now + duration * 0.7); // Sustain
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Release
        
        oscillator.connect(gainNode);
        gainNode.connect(this.sfxGain);
        
        return { oscillator, gainNode, duration };
    }

    // Play a synthesized sound effect
    async playSFX(type) {
        if (!this.settings.sfxEnabled || !this.audioContext) {
            return;
        }
        
        // Ensure audio context is resumed before playing
        const resumed = await this.resumeAudioContext();
        if (!resumed) {
            return;
        }
        
        try {
            switch (type) {
                case 'move':
                    this.playMoveSound();
                    break;
                case 'rotate':
                    this.playRotateSound();
                    break;
                case 'drop':
                    this.playDropSound();
                    break;
                case 'lock':
                    this.playLockSound();
                    break;
                case 'lineClear':
                    this.playLineClearSound();
                    break;
                case 'tetris':
                    this.playTetrisSound();
                    break;
                case 'levelUp':
                    this.playLevelUpSound();
                    break;
                case 'gameOver':
                    this.playGameOverSound();
                    break;
                case 'hold':
                    this.playHoldSound();
                    break;
                case 'tspin':
                    this.playTSpinSound();
                    break;
            }
        } catch (error) {
            this.showAudioError(`Sound effect error: ${error.message}`);
        }
    }

    playMoveSound() {
        const sound = this.createOscillator(220, 'square', 0.05);
        if (sound) {
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playRotateSound() {
        const sound = this.createOscillator(330, 'sawtooth', 0.08);
        if (sound) {
            // Add frequency sweep for rotation effect
            sound.oscillator.frequency.exponentialRampToValueAtTime(
                440, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playDropSound() {
        const sound = this.createOscillator(110, 'square', 0.1);
        if (sound) {
            // Descending pitch for drop effect
            sound.oscillator.frequency.exponentialRampToValueAtTime(
                55, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playLockSound() {
        // Two-tone lock sound
        const sound1 = this.createOscillator(660, 'square', 0.06);
        const sound2 = this.createOscillator(440, 'square', 0.06);
        
        if (sound1 && sound2) {
            const now = this.audioContext.currentTime;
            sound1.oscillator.start(now);
            sound1.oscillator.stop(now + 0.03);
            
            sound2.oscillator.start(now + 0.03);
            sound2.oscillator.stop(now + 0.06);
        }
    }

    playLineClearSound() {
        // Ascending arpeggio for line clear
        const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6
        frequencies.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'square', 0.15);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.05);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.15);
            }
        });
    }

    playTetrisSound() {
        // Epic Tetris chord progression
        const chord1 = [523, 659, 784]; // C major
        const chord2 = [587, 740, 880]; // D major
        const chord3 = [659, 831, 988]; // E major
        
        [chord1, chord2, chord3].forEach((chord, chordIndex) => {
            chord.forEach((freq, noteIndex) => {
                const sound = this.createOscillator(freq, 'sawtooth', 0.3);
                if (sound) {
                    const startTime = this.audioContext.currentTime + (chordIndex * 0.1);
                    sound.oscillator.start(startTime);
                    sound.oscillator.stop(startTime + 0.3);
                }
            });
        });
    }

    playLevelUpSound() {
        // Victory fanfare
        const melody = [523, 659, 784, 1047, 1319]; // C5 to E6
        melody.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'triangle', 0.2);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.1);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.2);
            }
        });
    }

    playGameOverSound() {
        // Descending minor scale
        const melody = [523, 494, 440, 415, 392, 370, 330]; // C5 down
        melody.forEach((freq, index) => {
            const sound = this.createOscillator(freq, 'sawtooth', 0.4);
            if (sound) {
                const startTime = this.audioContext.currentTime + (index * 0.15);
                sound.oscillator.start(startTime);
                sound.oscillator.stop(startTime + 0.4);
            }
        });
    }

    playHoldSound() {
        const sound = this.createOscillator(880, 'triangle', 0.12);
        if (sound) {
            sound.oscillator.frequency.linearRampToValueAtTime(
                660, this.audioContext.currentTime + sound.duration
            );
            sound.oscillator.start();
            sound.oscillator.stop(this.audioContext.currentTime + sound.duration);
        }
    }

    playTSpinSound() {
        // Special T-Spin sound with rapid frequency changes
        const sound = this.createOscillator(1000, 'square', 0.2);
        if (sound) {
            const now = this.audioContext.currentTime;
            sound.oscillator.frequency.setValueAtTime(1000, now);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.05);
            sound.oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
            sound.oscillator.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
            
            sound.oscillator.start();
            sound.oscillator.stop(now + sound.duration);
        }
    }

    // Background Music System - Classic Tetris Style
    // Features authentic chiptune melodies inspired by Korobeiniki,
    // proper square wave instrumentation, and energetic rhythms
    startBackgroundMusic() {
        // Start background music
        if (!this.settings.musicEnabled || this.musicLoop) return;
        
        this.resumeAudioContext();
        this.playBackgroundLoop();
    }

    stopBackgroundMusic() {
        if (this.musicLoop) {
            clearTimeout(this.musicLoop);
            this.musicLoop = null;
        }
        
        // Clear any scheduled timeouts
        if (this.musicTimeout) {
            clearTimeout(this.musicTimeout);
            this.musicTimeout = null;
        }
        
        // Gradually fade out currently playing notes instead of abrupt stop
        if (this.currentMusicNotes) {
            const now = this.audioContext ? this.audioContext.currentTime : 0;
            this.currentMusicNotes.forEach(note => {
                if (note.gainNode && this.audioContext) {
                    try {
                        // Fade out over 2 seconds for smooth transition
                        note.gainNode.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
                        if (note.oscillator) {
                            setTimeout(() => {
                                try {
                                    note.oscillator.stop();
                                } catch (e) {
                                    // Ignore if already stopped
                                }
                            }, 2100);
                        }
                    } catch (e) {
                        // Fallback to immediate stop if smooth fade fails
                        if (note.oscillator) {
                            try {
                                note.oscillator.stop();
                            } catch (e2) {
                                // Ignore if already stopped
                            }
                        }
                    }
                }
            });
            // Clear the array after fade completes
            setTimeout(() => {
                this.currentMusicNotes = [];
            }, 2200);
        }
    }

    playBackgroundLoop() {
        // Play background loop
        // ENHANCED TETRIS THEME - Korobeiniki-inspired but unique composition
        // Optimized for extended gameplay with perfect looping and non-fatiguing mix
        const composition = [
            // === PART A: THE ICONIC OPENING (8 bars) ===
            // More accurate to the original Tetris theme rhythm and intervals
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5 - Iconic opening
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'main' }, // B4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'main' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'main' }, // B4
            
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'main' }, // A4
            { note: 440.00, duration: 0.5, harmony: [220.00], section: 'main' }, // A4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'main' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            
            { note: 493.88, duration: 1.5, harmony: [246.94], section: 'main' }, // B4 - extended
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'main' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'main' }, // D5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'main' }, // E5
            
            { note: 523.25, duration: 1.0, harmony: [261.63], section: 'main' }, // C5
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'main' }, // A4
            { note: 440.00, duration: 2.0, harmony: [220.00], section: 'main' }, // A4 - hold
            
            // === PART B: THE ASCENDING SECTION (8 bars) ===
            // Creates variety and maintains interest
            { note: 0, duration: 0.5, harmony: [], section: 'bridge' }, // Rest
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'bridge' }, // D5
            { note: 698.46, duration: 1.0, harmony: [349.23], section: 'bridge' }, // F5
            { note: 880.00, duration: 1.0, harmony: [440.00], section: 'bridge' }, // A5
            
            { note: 784.00, duration: 0.5, harmony: [392.00], section: 'bridge' }, // G5
            { note: 698.46, duration: 0.5, harmony: [349.23], section: 'bridge' }, // F5
            { note: 659.25, duration: 1.5, harmony: [329.63], section: 'bridge' }, // E5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'bridge' }, // E5
            { note: 587.33, duration: 0.5, harmony: [293.66], section: 'bridge' }, // D5
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            { note: 493.88, duration: 2.0, harmony: [246.94], section: 'bridge' }, // B4 - hold
            
            { note: 493.88, duration: 0.5, harmony: [246.94], section: 'bridge' }, // B4
            { note: 523.25, duration: 0.5, harmony: [261.63], section: 'bridge' }, // C5
            { note: 587.33, duration: 1.0, harmony: [293.66], section: 'bridge' }, // D5
            { note: 659.25, duration: 1.0, harmony: [329.63], section: 'bridge' }, // E5
            
            { note: 523.25, duration: 1.0, harmony: [261.63], section: 'bridge' }, // C5
            { note: 440.00, duration: 1.0, harmony: [220.00], section: 'bridge' }, // A4
            { note: 440.00, duration: 2.0, harmony: [220.00], section: 'bridge' }, // A4 - hold
        ];
        
        // OPTIMIZED BASS LINE - More subtle and supportive, less fatiguing
        // Uses walking bass patterns that complement without overwhelming
        const bassPatterns = {
            main: [
                164.81, 0, 164.81, 0,      // E3 with rests - less constant
                110.00, 0, 110.00, 0,      // A2 with rests
                146.83, 0, 130.81, 0,      // D3, C3 walking pattern
                123.47, 0, 110.00, 0       // B2, A2 resolution
            ],
            bridge: [
                146.83, 0, 174.61, 0,      // D3, F3 with space
                220.00, 0, 196.00, 0,      // A3, G3 higher register
                164.81, 0, 130.81, 0,      // E3, C3 return
                123.47, 0, 146.83, 0       // B2, D3 turnaround
            ]
        };
        
        let noteIndex = 0;
        let sectionBassIndex = 0;
        this.currentMusicNotes = [];
        
        const playNextNote = async () => {
            if (!this.settings.musicEnabled) return;
            
            // Playing note
            
            // Clean up old notes to prevent memory leaks
            const now = this.audioContext ? this.audioContext.currentTime : 0;
            this.currentMusicNotes = this.currentMusicNotes.filter(note => {
                if (note.startTime && (now - note.startTime) > 5) { // Reduced from 10 to 5 seconds
                    try {
                        if (note.oscillator) {
                            note.oscillator.stop();
                            note.oscillator.disconnect();
                        }
                        if (note.gainNode) note.gainNode.disconnect();
                        if (note.filterNode) note.filterNode.disconnect();
                    } catch (e) {
                        // Already stopped or disconnected
                    }
                    return false;
                }
                return true;
            });
            
            const currentNote = composition[noteIndex];
            const currentSection = currentNote.section;
            const bassPattern = bassPatterns[currentSection];
            const bassNote = bassPattern[sectionBassIndex % bassPattern.length];
            
            // Play main melody note (skip if it's a rest - note frequency 0)
            if (currentNote.note > 0) {
                const mainSound = this.createMusicNote(currentNote.note, currentNote.duration, 'lead');
                if (mainSound) {
                    mainSound.startTime = now;
                    mainSound.oscillator.start(now);
                    this.currentMusicNotes.push(mainSound);
                }
                
                // Play harmony notes with tight, precise chiptune timing
                currentNote.harmony.forEach((harmonyFreq, index) => {
                    const harmonySound = this.createMusicNote(harmonyFreq, currentNote.duration, 'harmony');
                    if (harmonySound) {
                        const delay = index * 0.01; // Very tight timing for authentic chiptune feel
                        harmonySound.startTime = now + delay;
                        harmonySound.oscillator.start(now + delay);
                        this.currentMusicNotes.push(harmonySound);
                    }
                });
            }
            
            // Play bass line (only if melody isn't resting - bass follows melody rhythm)
            if (currentNote.note > 0 && bassNote > 0) {
                const bassSound = this.createMusicNote(bassNote, currentNote.duration, 'bass');
                if (bassSound) {
                    bassSound.startTime = now;
                    bassSound.oscillator.start(now);
                    this.currentMusicNotes.push(bassSound);
                }
            }
            
            noteIndex = (noteIndex + 1) % composition.length;
            sectionBassIndex++;
            
            // Reset bass index when changing sections
            const nextSection = composition[noteIndex].section;
            if (nextSection !== currentSection) {
                sectionBassIndex = 0;
            }
        };
        
        // Start playing with authentic Tetris tempo - fast, energetic, and addictive
        const scheduleNextNote = () => {
            if (!this.settings.musicEnabled) return;
            
            playNextNote();
            const currentNote = composition[noteIndex];
            // ADAPTIVE TEMPO - Starts moderate and can speed up with game level
            // Base tempo around 120 BPM for comfortable extended listening
            const tempoMultiplier = this.getMusicSpeedMultiplier ? this.getMusicSpeedMultiplier() : 1.0;
            const baseDelay = 250; // More relaxed base tempo (120 BPM)
            const nextDelay = (currentNote.duration * baseDelay) / tempoMultiplier;
            this.musicTimeout = setTimeout(scheduleNextNote, nextDelay);
        };
        
        // Set musicLoop to indicate music is playing (use timeout ID)
        this.musicLoop = setTimeout(scheduleNextNote, 50); // Start quickly
    }

    createMusicNote(frequency, duration, instrument = 'lead') {
        if (!this.audioContext || frequency === 0) return null; // Support rests
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filterNode = this.audioContext.createBiquadFilter();
        
        // Get current time first for consistent timing
        const now = this.audioContext.currentTime;
        
        // ENHANCED CHIPTUNE SYNTHESIS with better mixing
        switch (instrument) {
            case 'lead':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Subtle vibrato for character without being overwhelming
                const vibratoDepth = 0.002; // Much subtler vibrato
                const vibratoRate = 5; // Hz
                const lfo = this.audioContext.createOscillator();
                const lfoGain = this.audioContext.createGain();
                lfo.frequency.value = vibratoRate;
                lfoGain.gain.value = frequency * vibratoDepth;
                lfo.connect(lfoGain);
                lfoGain.connect(oscillator.frequency);
                lfo.start(now);
                lfo.stop(now + duration + 0.1);
                
                // Add gentle low-pass filter to soften harsh harmonics
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 2000;
                filterNode.Q.value = 0.5;
                break;
                
            case 'harmony':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Softer filter for harmony to sit behind lead
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 1500;
                filterNode.Q.value = 0.3;
                break;
                
            case 'bass':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(frequency, now);
                // Gentle pitch envelope for character
                oscillator.frequency.setValueAtTime(frequency * 0.98, now);
                oscillator.frequency.exponentialRampToValueAtTime(frequency, now + 0.01);
                
                // Low-pass filter to keep bass clean
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 800;
                filterNode.Q.value = 1.0;
                break;
                
            default:
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 2000;
        }
        
        // BALANCED MIXING - Pleasant for extended listening
        let volume;
        
        switch (instrument) {
            case 'lead':
                volume = 0.35; // Reduced but still prominent
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.002); // Quick attack
                gainNode.gain.linearRampToValueAtTime(volume * 0.85, now + 0.01); // Slight decay
                gainNode.gain.setValueAtTime(volume * 0.85, now + duration * 0.8); // Sustain
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.02); // Release
                break;
                
            case 'harmony':
                volume = 0.20; // Supportive, not overwhelming
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.003);
                gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.015);
                gainNode.gain.setValueAtTime(volume * 0.8, now + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.03);
                break;
                
            case 'bass':
                volume = 0.25; // Present but not boomy
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.001); // Tight attack
                gainNode.gain.linearRampToValueAtTime(volume * 0.9, now + 0.005);
                gainNode.gain.setValueAtTime(volume * 0.9, now + duration * 0.9);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.01);
                break;
                
            default:
                volume = 0.2;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.1);
        }
        
        // Connect with filter for better sound quality
        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(this.musicGain);
        
        return { oscillator, gainNode, filterNode };
    }

    // Volume Controls
    setMasterVolume(volume) {
        this.settings.masterVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    setMusicVolume(volume) {
        this.settings.musicVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    setSFXVolume(volume) {
        this.settings.sfxVolume = Math.max(0, Math.min(1, volume));
        this.updateVolumes();
        this.saveSettings();
    }

    // Toggle Controls
    toggleMusic() {
        this.settings.musicEnabled = !this.settings.musicEnabled;
        this.updateVolumes();
        this.saveSettings();
        
        if (this.settings.musicEnabled) {
            this.startBackgroundMusic();
        } else {
            this.stopBackgroundMusic();
        }
    }

    toggleSFX() {
        this.settings.sfxEnabled = !this.settings.sfxEnabled;
        this.updateVolumes();
        this.saveSettings();
    }

    // Master mute control (for window focus/blur)
    setMasterMute(muted) {
        if (!this.masterGain) return;
        
        this.masterMuted = muted;
        
        if (muted) {
            // Store current volume before muting
            this.previousMasterVolume = this.settings.masterVolume;
            this.masterGain.gain.value = 0;
        } else {
            // Restore previous volume or use current setting
            const volumeToRestore = this.previousMasterVolume ?? this.settings.masterVolume;
            this.masterGain.gain.value = volumeToRestore;
        }
    }

    // Get current settings for UI
    getSettings() {
        return { ...this.settings };
    }

    // Set game level for adaptive music tempo
    setGameLevel(level) {
        this.currentGameLevel = Math.max(1, Math.min(level, 20)); // Cap at level 20
    }
    
    // Get music speed multiplier based on game level
    getMusicSpeedMultiplier() {
        // Start at 1.0x speed, increase by 2% per level, max 1.4x at level 20
        return Math.min(1.4, 1.0 + (this.currentGameLevel - 1) * 0.02);
    }
    
    // Cleanup
    destroy() {
        this.stopBackgroundMusic();
        // Clean up all audio nodes
        this.currentMusicNotes.forEach(note => {
            try {
                if (note.oscillator) {
                    note.oscillator.stop();
                    note.oscillator.disconnect();
                }
                if (note.gainNode) note.gainNode.disconnect();
                if (note.filterNode) note.filterNode.disconnect();
            } catch (e) {
                // Ignore cleanup errors
            }
        });
        this.currentMusicNotes = [];
        
        if (this.audioContext) {
            this.audioContext.close();
        }
    }
}
})();

/* scripts/input.js */
(function() {
// Modern Tetris - Input Management System

window.InputManager = class InputManager {
    constructor(game) {
        this.game = game;
        this.keys = {};
        this.keyBindings = {
            // Movement
            'ArrowLeft': 'moveLeft',
            'ArrowRight': 'moveRight',
            'ArrowDown': 'softDrop',
            'ArrowUp': 'rotateClockwise',
            
            // Alternative controls
            'KeyA': 'moveLeft',
            'KeyD': 'moveRight',
            'KeyS': 'softDrop',
            'KeyW': 'rotateClockwise',
            'KeyQ': 'rotateCounterclockwise',
            'KeyE': 'rotateClockwise',
            
            // Special actions
            'Space': 'hardDrop',
            'KeyC': 'hold',
            'KeyP': 'pause',
            'Escape': 'menu',
            'KeyR': 'restart',
            'Enter': 'confirm'
        };
        
        // DAS (Delayed Auto Shift) settings
        this.das = {
            delay: 100,     // 100ms initial delay (more responsive)
            repeat: 20,     // 20ms repeat rate (50Hz, much faster)
            leftTime: 0,
            rightTime: 0,
            downTime: 0
        };
        
        // Track if first press was handled
        this.firstPress = {
            left: false,
            right: false,
            down: false
        };
        
        this.touchControls = {
            startX: 0,
            startY: 0,
            threshold: 25, // Reduced threshold for more responsive swipe detection
            isActive: false,
            startTime: 0,
            longPressThreshold: 800, // 800ms for long press (increased to avoid conflicts with continuous drop)
            longPressTriggered: false,
            isDownSwipe: false,
            downSwipeSpeed: 0,
            continuousDropActive: false
        };
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Keyboard events
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
        
        // Prevent default for game controls and handle key repeat issues
        document.addEventListener('keydown', (e) => {
            // Don't prevent default when modals are active to allow typing
            if (this.isNameInputActive() || this.isLeaderboardActive() || 
                this.isSettingsActive() || this.isHelpActive()) {
                return;
            }
            
            if (this.keyBindings[e.code]) {
                e.preventDefault();
                // Also stop propagation to prevent multiple handlers
                e.stopImmediatePropagation();
            }
        });
        
        // Touch and mouse events for canvas interactions
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
            canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
            canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            
            // Mouse events
            canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        }
        
        // Also add touch events to game overlay for pause/resume functionality
        const gameOverlay = document.getElementById('game-overlay');
        if (gameOverlay) {
            gameOverlay.addEventListener('touchstart', (e) => this.handleTouchStart(e));
            gameOverlay.addEventListener('touchmove', (e) => this.handleTouchMove(e));
            gameOverlay.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            gameOverlay.addEventListener('click', (e) => this.handleCanvasClick(e));
        }
        
        // Add touch support for UI elements
        this.initializeTouchUI();
        
        // Focus management
        window.addEventListener('blur', () => this.handleWindowBlur());
        window.addEventListener('focus', () => this.handleWindowFocus());
        
        // Page visibility API for better mobile support
        document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
    }

    handleKeyDown(e) {
        // Check if any modal is active - if so, ignore game controls
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) {
            // Only allow specific keys during name input
            if (this.isNameInputActive()) {
                // Allow normal typing, Enter for save, Escape to close
                if (e.code === 'Enter') {
                    const saveButton = document.getElementById('save-score-button');
                    if (saveButton) saveButton.click();
                    return;
                } else if (e.code === 'Escape') {
                    const skipButton = document.getElementById('skip-save-button');
                    if (skipButton) skipButton.click();
                    return;
                }
                // Let all other keys pass through for typing
                return;
            }
            
            // For leaderboard, only allow Escape to close
            if (this.isLeaderboardActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-leaderboard');
                if (closeButton) closeButton.click();
                return;
            }
            
            // For settings, only allow Escape to close
            if (this.isSettingsActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-settings');
                if (closeButton) closeButton.click();
                return;
            }
            
            // For help, only allow Escape to close
            if (this.isHelpActive() && e.code === 'Escape') {
                const closeButton = document.getElementById('close-help');
                if (closeButton) closeButton.click();
                return;
            }
            
            // Block all other game controls when modals are open
            e.preventDefault();
            return;
        }
        
        const action = this.keyBindings[e.code];
        if (!action) return;
        
        // Prevent key repeat for certain actions
        if (this.keys[e.code] && this.isInstantAction(action)) {
            return;
        }
        
        const wasPressed = this.keys[e.code];
        this.keys[e.code] = true;
        
        // Handle instant actions immediately
        if (this.isInstantAction(action)) {
            this.executeAction(action);
        } else if (!wasPressed) {
            // For movement actions, execute immediately on first press
            if (action === 'moveLeft') {
                this.executeAction(action);
                this.firstPress.left = true;
                this.das.leftTime = 0;
            } else if (action === 'moveRight') {
                this.executeAction(action);
                this.firstPress.right = true;
                this.das.rightTime = 0;
            } else if (action === 'softDrop') {
                this.executeAction(action);
                this.firstPress.down = true;
                this.das.downTime = 0;
            }
        }
    }

    handleKeyUp(e) {
        // Check if any modal is active - if so, ignore game key releases
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) {
            return;
        }
        
        this.keys[e.code] = false;
        
        // Reset DAS timers and first press flags
        const action = this.keyBindings[e.code];
        if (action === 'moveLeft') {
            this.das.leftTime = 0;
            this.firstPress.left = false;
        }
        if (action === 'moveRight') {
            this.das.rightTime = 0;
            this.firstPress.right = false;
        }
        if (action === 'softDrop') {
            this.das.downTime = 0;
            this.firstPress.down = false;
        }
    }

    handleTouchStart(e) {
        // Only prevent default for game canvas touches
        e.preventDefault();
        const touch = e.touches[0];
        
        // Get touch coordinates relative to canvas
        const rect = e.target.getBoundingClientRect();
        this.touchControls.startX = touch.clientX - rect.left;
        this.touchControls.startY = touch.clientY - rect.top;
        this.touchControls.startTime = Date.now();
        this.touchControls.isActive = true;
        this.touchControls.longPressTriggered = false;
        
        // Set timeout for long press detection
        this.longPressTimeout = setTimeout(() => {
            if (this.touchControls.isActive && 
                !this.touchControls.longPressTriggered && 
                !this.touchControls.isDownSwipe && 
                !this.touchControls.continuousDropActive) {
                this.touchControls.longPressTriggered = true;
                this.executeAction('hold');
            }
        }, this.touchControls.longPressThreshold);
    }

    handleTouchMove(e) {
        if (!this.touchControls.isActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = e.target.getBoundingClientRect();
        const currentY = touch.clientY - rect.top;
        const deltaY = currentY - this.touchControls.startY;
        
        // Detect continuous down swipe
        if (deltaY > this.touchControls.threshold && !this.touchControls.longPressTriggered) {
            if (!this.touchControls.isDownSwipe) {
                this.touchControls.isDownSwipe = true;
                this.touchControls.continuousDropActive = true;
                
                // Calculate swipe speed (distance per time)
                const timeElapsed = Date.now() - this.touchControls.startTime;
                this.touchControls.downSwipeSpeed = Math.min(deltaY / Math.max(timeElapsed, 1), 2); // Cap at 2x speed
                
                // Start continuous soft drop
                this.startContinuousDrop();
            }
        }
    }

    handleTouchEnd(e) {
        if (!this.touchControls.isActive) return;
        e.preventDefault();
        
        // Clear long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
        
        // Stop continuous drop if active
        if (this.touchControls.continuousDropActive) {
            this.stopContinuousDrop();
        }
        
        // Check if game is paused - allow tap to unpause
        if (this.game && this.game.state === 'paused') {
            const touchDuration = Date.now() - this.touchControls.startTime;
            // Only unpause on quick tap (not long press or swipe)
            if (touchDuration < 300 && !this.touchControls.longPressTriggered && !this.touchControls.isDownSwipe) {
                this.game.togglePause();
                this.resetTouchControls();
                return;
            }
        }
        
        // If long press was triggered, don't process other gestures
        if (this.touchControls.longPressTriggered) {
            this.resetTouchControls();
            return;
        }
        
        // If continuous drop was active, don't process other gestures
        if (this.touchControls.isDownSwipe) {
            this.resetTouchControls();
            return;
        }
        
        const touch = e.changedTouches[0];
        const rect = e.target.getBoundingClientRect();
        const endX = touch.clientX - rect.left;
        const endY = touch.clientY - rect.top;
        const deltaX = endX - this.touchControls.startX;
        const deltaY = endY - this.touchControls.startY;
        const threshold = this.touchControls.threshold;
        const touchDuration = Date.now() - this.touchControls.startTime;
        
        // Determine gesture
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Horizontal swipe
            if (Math.abs(deltaX) > threshold) {
                if (deltaX > 0) {
                    this.executeAction('moveRight');
                } else {
                    this.executeAction('moveLeft');
                }
            }
        } else {
            // Vertical swipe
            if (Math.abs(deltaY) > threshold) {
                if (deltaY < 0) {
                    // Swipe up - hard drop
                    this.executeAction('hardDrop');
                }
                // Note: Down swipe is now handled by continuous drop in touchMove
            } else if (touchDuration < this.touchControls.longPressThreshold) {
                // Quick tap - rotate
                this.executeAction('rotateClockwise');
            }
        }
        
        this.resetTouchControls();
    }

    handleCanvasClick(e) {
        // Handle canvas clicks for piece placement or rotation
        // For now, just rotate on click
        this.executeAction('rotateClockwise');
    }

    handleWindowBlur() {
        // Clear all keys when window loses focus
        this.keys = {};
        // Reset DAS and first press flags
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Stop any continuous touch actions
        this.stopContinuousDrop();
        this.resetTouchControls();
        
        // Auto-pause if game is active and mute audio
        if (this.game && this.game.state === 'playing') {
            this.game.pause();
            this.wasAutoPaused = true; // Flag to remember this was auto-paused
        }
        
        // Mute audio when window loses focus
        if (this.game && this.game.audioManager) {
            this.game.audioManager.setMasterMute(true);
        }
    }

    handleWindowFocus() {
        // Reset DAS timers and first press flags
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Restore audio when window regains focus
        if (this.game && this.game.audioManager) {
            this.game.audioManager.setMasterMute(false);
        }
        
        // Note: We don't auto-resume the game to let the user decide when to continue
        // The game will remain paused and can be resumed with P key or touch
        this.wasAutoPaused = false;
    }

    handleVisibilityChange() {
        if (document.hidden) {
            // Page is now hidden (mobile browser switching, etc.)
            this.handleWindowBlur();
        } else {
            // Page is now visible
            this.handleWindowFocus();
        }
    }

    // Update input state (called every frame)
    update(deltaTime) {
        if (!this.game || this.game.state !== 'playing') return;
        
        // Check if any modal is active - if so, disable game controls
        if (this.isNameInputActive() || this.isLeaderboardActive() || 
            this.isSettingsActive() || this.isHelpActive()) return;
        
        // Handle DAS (Delayed Auto Shift)
        this.updateDAS(deltaTime);
    }

    updateDAS(deltaTime) {
        // Left movement
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
            if (this.firstPress.left) {
                this.das.leftTime += deltaTime;
                if (this.das.leftTime >= this.das.delay) {
                    // After delay, start repeating
                    const repeatTime = this.das.leftTime - this.das.delay;
                    if (repeatTime >= this.das.repeat) {
                        this.executeAction('moveLeft');
                        this.das.leftTime = this.das.delay; // Reset repeat timer
                    }
                }
            }
        }
        
        // Right movement
        if (this.keys['ArrowRight'] || this.keys['KeyD']) {
            if (this.firstPress.right) {
                this.das.rightTime += deltaTime;
                if (this.das.rightTime >= this.das.delay) {
                    // After delay, start repeating
                    const repeatTime = this.das.rightTime - this.das.delay;
                    if (repeatTime >= this.das.repeat) {
                        this.executeAction('moveRight');
                        this.das.rightTime = this.das.delay; // Reset repeat timer
                    }
                }
            }
        }
        
        // Soft drop
        if (this.keys['ArrowDown'] || this.keys['KeyS']) {
            if (this.firstPress.down) {
                this.das.downTime += deltaTime;
                if (this.das.downTime >= this.das.repeat) {
                    this.executeAction('softDrop');
                    this.das.downTime = 0;
                }
            }
        }
    }

    // Execute game action
    executeAction(action) {
        if (!this.game) return;
        
        switch (action) {
            case 'moveLeft':
                this.game.movePiece(-1, 0);
                break;
            case 'moveRight':
                this.game.movePiece(1, 0);
                break;
            case 'softDrop':
                this.game.softDrop();
                break;
            case 'hardDrop':
                this.game.hardDrop();
                break;
            case 'rotateClockwise':
                this.game.rotatePiece(1);
                break;
            case 'rotateCounterclockwise':
                this.game.rotatePiece(-1);
                break;
            case 'hold':
                this.game.holdPiece();
                break;
            case 'pause':
                this.game.togglePause();
                break;
            case 'menu':
                // Return to home screen
                if (this.game.modalManager) {
                    this.game.modalManager.backToHome();
                }
                break;
            case 'restart':
                this.game.restart();
                break;
            case 'confirm':
                this.game.handleConfirm();
                break;
        }
    }

    // Check if action should only happen once per keypress
    isInstantAction(action) {
        return [
            'rotateClockwise',
            'rotateCounterclockwise',
            'hardDrop',
            'hold',
            'pause',
            'restart',
            'confirm'
        ].includes(action);
    }

    // Get current input state
    getInputState() {
        return {
            left: this.keys['ArrowLeft'] || this.keys['KeyA'],
            right: this.keys['ArrowRight'] || this.keys['KeyD'],
            down: this.keys['ArrowDown'] || this.keys['KeyS'],
            rotateClockwise: this.keys['ArrowUp'] || this.keys['KeyW'] || this.keys['KeyE'],
            rotateCounterclockwise: this.keys['KeyQ'],
            hardDrop: this.keys['Space'],
            hold: this.keys['KeyC'],
            pause: this.keys['KeyP'] || this.keys['Escape'],
            restart: this.keys['KeyR'],
            confirm: this.keys['Enter']
        };
    }

    // Check if name input modal is active
    isNameInputActive() {
        const overlay = document.getElementById('name-input-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if leaderboard modal is active
    isLeaderboardActive() {
        const overlay = document.getElementById('leaderboard-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if settings modal is active
    isSettingsActive() {
        const overlay = document.getElementById('settings-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }
    
    // Check if help modal is active
    isHelpActive() {
        const overlay = document.getElementById('help-overlay');
        return overlay && overlay.style.display !== 'none' && 
               window.getComputedStyle(overlay).display !== 'none';
    }

    // Start continuous drop for touch down swipe
    startContinuousDrop() {
        if (!this.game || this.game.state !== 'playing') return;
        
        // Calculate drop interval based on swipe speed (faster swipe = faster drop)
        const baseInterval = 50; // Base 50ms interval
        const speedMultiplier = Math.max(0.3, 1 - this.touchControls.downSwipeSpeed * 0.3);
        const dropInterval = baseInterval * speedMultiplier; // Faster swipe = shorter interval
        
        // Clear any existing interval
        if (this.continuousDropInterval) {
            clearInterval(this.continuousDropInterval);
        }
        
        // Start continuous dropping
        this.continuousDropInterval = setInterval(() => {
            if (!this.touchControls.continuousDropActive || !this.game || this.game.state !== 'playing') {
                this.stopContinuousDrop();
                return;
            }
            this.executeAction('softDrop');
        }, dropInterval);
    }
    
    // Stop continuous drop
    stopContinuousDrop() {
        if (this.continuousDropInterval) {
            clearInterval(this.continuousDropInterval);
            this.continuousDropInterval = null;
        }
        this.touchControls.continuousDropActive = false;
    }
    
    // Reset touch controls state
    resetTouchControls() {
        this.touchControls.isActive = false;
        this.touchControls.isDownSwipe = false;
        this.touchControls.longPressTriggered = false;
        this.touchControls.continuousDropActive = false;
        this.touchControls.downSwipeSpeed = 0;
    }

    // Update DAS settings
    updateDASSettings(settings) {
        if (settings.delay !== undefined) this.das.delay = settings.delay;
        if (settings.repeat !== undefined) this.das.repeat = settings.repeat;
    }

    // Reset input state
    reset() {
        this.keys = {};
        this.das.leftTime = 0;
        this.das.rightTime = 0;
        this.das.downTime = 0;
        this.firstPress.left = false;
        this.firstPress.right = false;
        this.firstPress.down = false;
        
        // Reset touch controls
        this.stopContinuousDrop();
        this.resetTouchControls();
        
        // Clear any pending long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
    }
    
    // Initialize touch support for UI elements
    initializeTouchUI() {
        // Add better touch support for all buttons
        const buttons = document.querySelectorAll('button, .btn-primary, .btn-secondary, .btn-icon, .btn-close');
        buttons.forEach(button => {
            // Ensure buttons are clickable on mobile
            button.style.touchAction = 'manipulation';
            
            // Add active state for better touch feedback
            button.addEventListener('touchstart', (e) => {
                button.classList.add('touch-active');
                e.stopPropagation(); // Prevent game touch handling
            }, { passive: false });
            
            button.addEventListener('touchend', (e) => {
                button.classList.remove('touch-active');
                e.stopPropagation();
            }, { passive: false });
            
            button.addEventListener('touchcancel', () => {
                button.classList.remove('touch-active');
            });
        });
        
        // Add touch support for modal overlays (to prevent closing on touch)
        const modals = document.querySelectorAll('.name-input-content, .leaderboard-content, .settings-content, .help-content');
        modals.forEach(modal => {
            modal.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });
            modal.addEventListener('touchend', (e) => {
                e.stopPropagation();
            });
        });
        
        // Ensure input fields work properly on touch devices
        const inputs = document.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.style.touchAction = 'manipulation';
            input.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });
        });
    }
    
    // Cleanup event listeners
    destroy() {
        document.removeEventListener('keydown', this.handleKeyDown);
        document.removeEventListener('keyup', this.handleKeyUp);
        
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            canvas.removeEventListener('touchstart', this.handleTouchStart);
            canvas.removeEventListener('touchmove', this.handleTouchMove);
            canvas.removeEventListener('touchend', this.handleTouchEnd);
        }
        
        // Clean up continuous drop
        this.stopContinuousDrop();
        
        // Clear long press timeout
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
        
        window.removeEventListener('blur', this.handleWindowBlur);
        window.removeEventListener('focus', this.handleWindowFocus);
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
    }
}
})();

/* scripts/puzzles/puzzleData.js */
(function() {
// Puzzle Data - 150 unique puzzle challenges
window.PUZZLES = const PUZZLES = [
    // Beginner Puzzles (1-30) - Teaching basics
    {
        id: 1,
        name: "First Clear",
        category: "beginner",
        difficulty: 1,
        objective: "clear",
        targetLines: 1,
        description: "Clear 1 line",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,1,1,0,1,1,1]
        ],
        pieces: ['I'],
        maxPieces: 3,
        timeLimit: 0
    },
    {
        id: 2,
        name: "Double Trouble",
        category: "beginner",
        difficulty: 1,
        objective: "clear",
        targetLines: 2,
        description: "Clear 2 lines at once",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,0,0,1,1,1,1],
            [1,1,1,1,0,0,1,1,1,1]
        ],
        pieces: ['O', 'O'],  // Changed to 2 O pieces for feasibility
        maxPieces: 5,  // Increased to allow more attempts
        timeLimit: 0
    },
    {
        id: 3,
        name: "T-Spin Tutorial",
        category: "beginner",
        difficulty: 2,
        objective: "tspin",
        targetTSpins: 1,
        description: "Perform your first T-Spin",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1],
            [1,1,1,1,1,1,1,1,0,1]
        ],
        pieces: ['T'],
        maxPieces: 5,
        timeLimit: 0
    },
    {
        id: 4,
        name: "Tetris Time",
        category: "beginner",
        difficulty: 2,
        objective: "tetris",
        targetTetris: 1,
        description: "Clear 4 lines at once (Tetris)",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1]
        ],
        pieces: ['I'],
        maxPieces: 2,
        timeLimit: 0
    },
    {
        id: 5,
        name: "Perfect Clear",
        category: "beginner",
        difficulty: 3,
        objective: "perfectclear",
        description: "Clear the entire board",
        initialGrid: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,0,0,1,1,1,1]
        ],
        pieces: 'random',  // Changed to random for perfect clear
        maxPieces: 10,      // More pieces for flexibility
        timeLimit: 0
    }
];

// Generate additional puzzles programmatically
function generatePuzzles() {
    const additionalPuzzles = [];
    let id = 6;
    
    // Intermediate Puzzles (31-60)
    for (let i = 0; i < 25; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Challenge ${id}`,
            category: "intermediate",
            difficulty: 3 + Math.floor(i / 8),
            objective: ["clear", "tspin", "tetris", "perfectclear"][i % 4],
            targetLines: 2 + Math.floor(i / 5),
            description: `Clear ${2 + Math.floor(i / 5)} lines with style`,
            initialGrid: generateRandomGrid(10 + i % 5),
            pieces: generatePieceSet(3 + Math.floor(i / 10)),
            maxPieces: 10 + Math.floor(i / 5),  // Increased for better playability
            timeLimit: i > 15 ? 120 : 0
        });
    }
    
    // Advanced Puzzles (61-90)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Expert ${id}`,
            category: "advanced",
            difficulty: 6 + Math.floor(i / 10),
            objective: ["combo", "tspin", "tetris", "perfectclear"][i % 4],
            targetLines: 3 + Math.floor(i / 4),
            targetCombo: i % 4 === 0 ? 3 + Math.floor(i / 10) : undefined,
            targetTSpins: i % 4 === 1 ? 2 : undefined,
            targetTetris: i % 4 === 2 ? 1 : undefined,
            description: `Advanced technique required`,
            initialGrid: generateComplexGrid(12 + i % 6),
            pieces: generatePieceSet(4 + Math.floor(i / 8)),
            maxPieces: 12 + Math.floor(i / 8),  // Increased for better playability
            timeLimit: 90 - (i * 2)
        });
    }
    
    // Expert Puzzles (91-120)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Master ${id}`,
            category: "expert",
            difficulty: 8 + Math.floor(i / 15),
            objective: "mixed",
            targetLines: 4 + Math.floor(i / 3),
            targetTSpins: 1 + Math.floor(i / 15),
            targetCombo: 4 + Math.floor(i / 10),
            description: `Master-level challenge`,
            initialGrid: generateExpertGrid(14 + i % 4),
            pieces: generateMixedPieceSet(5 + Math.floor(i / 6)),
            maxPieces: 15 + Math.floor(i / 6),  // Increased for better playability
            timeLimit: 60
        });
    }
    
    // Grandmaster Puzzles (121-150)
    for (let i = 0; i < 30; i++) {
        additionalPuzzles.push({
            id: id++,
            name: `Grandmaster ${id}`,
            category: "grandmaster",
            difficulty: 10,
            objective: "survival",
            targetLines: 5 + Math.floor(i / 2),
            minScore: 1000 * (i + 1),
            description: `Ultimate Tetris challenge`,
            initialGrid: generateGrandmasterGrid(16 + i % 3),
            pieces: "random",
            maxPieces: 20 + Math.floor(i / 3),  // Increased significantly for survival mode
            timeLimit: 45
        });
    }
    
    return additionalPuzzles;
}

// Helper functions to generate grids
function generateRandomGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    for (let row = 20 - filledRows; row < 20; row++) {
        for (let col = 0; col < 10; col++) {
            if (Math.random() > 0.2) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateComplexGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    for (let row = 20 - filledRows; row < 20; row++) {
        const holes = Math.floor(Math.random() * 3) + 1;
        const holePositions = [];
        for (let i = 0; i < holes; i++) {
            holePositions.push(Math.floor(Math.random() * 10));
        }
        for (let col = 0; col < 10; col++) {
            if (!holePositions.includes(col)) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateExpertGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    // Create challenging patterns
    for (let row = 20 - filledRows; row < 20; row++) {
        const pattern = row % 3;
        for (let col = 0; col < 10; col++) {
            if (pattern === 0 && col % 2 === 0) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            } else if (pattern === 1 && col % 2 === 1) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            } else if (pattern === 2 && col !== 4 && col !== 5) {
                grid[row][col] = Math.floor(Math.random() * 7) + 1;
            }
        }
    }
    return grid;
}

function generateGrandmasterGrid(filledRows) {
    const grid = Array(20).fill(null).map(() => Array(10).fill(0));
    // Create very challenging patterns with minimal clearing opportunities
    for (let row = 20 - filledRows; row < 20; row++) {
        const clearable = row === 19 || Math.random() > 0.7;
        if (clearable) {
            // Leave strategic holes
            const hole = Math.floor(Math.random() * 10);
            for (let col = 0; col < 10; col++) {
                if (col !== hole) {
                    grid[row][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        } else {
            // Complex pattern
            for (let col = 0; col < 10; col++) {
                if (Math.random() > 0.15) {
                    grid[row][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }
    }
    return grid;
}

function generatePieceSet(count) {
    const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    const set = [];
    for (let i = 0; i < count; i++) {
        set.push(pieces[Math.floor(Math.random() * pieces.length)]);
    }
    return set;
}

function generateMixedPieceSet(count) {
    const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    const set = [];
    // Ensure variety
    pieces.forEach(piece => {
        if (set.length < count) {
            set.push(piece);
        }
    });
    // Fill remaining with random
    while (set.length < count) {
        set.push(pieces[Math.floor(Math.random() * pieces.length)]);
    }
    return set;
}

// Add generated puzzles to the main array
PUZZLES.push(...generatePuzzles());

// Export puzzle utilities
window.getPuzzleById = function getPuzzleById(id) {
    return PUZZLES.find(p => p.id === id);
}

window.getPuzzlesByCategory = function getPuzzlesByCategory(category) {
    return PUZZLES.filter(p => p.category === category);
}

window.getPuzzlesByDifficulty = function getPuzzlesByDifficulty(difficulty) {
    return PUZZLES.filter(p => p.difficulty === difficulty);
}

window.getUnlockedPuzzles = function getUnlockedPuzzles(completedIds = []) {
    // First 5 puzzles are always unlocked
    // Each completed puzzle unlocks the next 2
    const baseUnlocked = 5;
    const unlockedCount = baseUnlocked + (completedIds.length * 2);
    return PUZZLES.slice(0, Math.min(unlockedCount, PUZZLES.length));
}

window.getNextPuzzle = function getNextPuzzle(currentId, completedIds = []) {
    const currentIndex = PUZZLES.findIndex(p => p.id === currentId);
    if (currentIndex === -1 || currentIndex === PUZZLES.length - 1) {
        return null;
    }
    
    const nextPuzzle = PUZZLES[currentIndex + 1];
    const unlockedPuzzles = getUnlockedPuzzles(completedIds);
    
    if (unlockedPuzzles.find(p => p.id === nextPuzzle.id)) {
        return nextPuzzle;
    }
    return null;
}

window.PUZZLE_CATEGORIES = const PUZZLE_CATEGORIES = [
    { id: 'beginner', name: 'Beginner', color: '#00ff00', icon: '' },
    { id: 'intermediate', name: 'Intermediate', color: '#ffff00', icon: '' },
    { id: 'advanced', name: 'Advanced', color: '#ff8800', icon: '' },
    { id: 'expert', name: 'Expert', color: '#ff0000', icon: '' },
    { id: 'grandmaster', name: 'Grandmaster', color: '#ff00ff', icon: '' }
];

window.PUZZLE_OBJECTIVES = const PUZZLE_OBJECTIVES = {
    clear: { name: 'Line Clear', description: 'Clear specified number of lines' },
    tspin: { name: 'T-Spin', description: 'Perform T-Spin clears' },
    tetris: { name: 'Tetris', description: 'Clear 4 lines at once' },
    perfectclear: { name: 'Perfect Clear', description: 'Clear the entire board' },
    combo: { name: 'Combo', description: 'Achieve combo chains' },
    mixed: { name: 'Mixed', description: 'Complete multiple objectives' },
    survival: { name: 'Survival', description: 'Survive and score high' }
};

// Make PUZZLES available globally for UI
if (typeof window !== 'undefined') {
    window.PUZZLES = PUZZLES;
}
})();

/* scripts/puzzles/puzzleObjectives.js */
(function() {
// Enhanced Puzzle Objectives System
window.PUZZLE_OBJECTIVE_TYPES = const PUZZLE_OBJECTIVE_TYPES = {
    // Classic objectives
    CLEAR: 'clear',
    PERFECT: 'perfect',
    TSPIN: 'tspin',
    TETRIS: 'tetris',
    COMBO: 'combo',
    
    // New objectives
    CASCADE: 'cascade',
    SPEED: 'speed',
    NO_ROTATION: 'norotation',
    CHAIN: 'chain',
    PATTERN: 'pattern',
    SURVIVAL: 'survival'
};

window.PuzzleObjective = class PuzzleObjective {
    constructor(type, config = {}) {
        this.type = type;
        this.config = config;
        this.progress = 0;
        this.completed = false;
        this.failed = false;
        this.startTime = null;
    }
    
    initialize() {
        this.progress = 0;
        this.completed = false;
        this.failed = false;
        this.startTime = Date.now();
    }
    
    checkCompletion(gameState, event) {
        switch (this.type) {
            case PUZZLE_OBJECTIVE_TYPES.CASCADE:
                return this.checkCascade(gameState, event);
            
            case PUZZLE_OBJECTIVE_TYPES.SPEED:
                return this.checkSpeed(gameState, event);
            
            case PUZZLE_OBJECTIVE_TYPES.NO_ROTATION:
                return this.checkNoRotation(gameState, event);
                
            case PUZZLE_OBJECTIVE_TYPES.CHAIN:
                return this.checkChain(gameState, event);
                
            case PUZZLE_OBJECTIVE_TYPES.PATTERN:
                return this.checkPattern(gameState, event);
                
            case PUZZLE_OBJECTIVE_TYPES.SURVIVAL:
                return this.checkSurvival(gameState, event);
                
            default:
                return this.checkClassicObjective(gameState, event);
        }
    }
    
    checkCascade(gameState, event) {
        // Cascade: Clear multiple lines with gravity effect
        if (event.type === 'lines_cleared') {
            if (event.cascade) {
                this.progress += event.linesCleared;
                
                if (this.progress >= (this.config.targetCascade || 3)) {
                    this.completed = true;
                    return {
                        completed: true,
                        message: `Cascade complete! ${this.progress} lines cleared with gravity!`
                    };
                }
            }
        }
        
        return { completed: false, progress: this.progress };
    }
    
    checkSpeed(gameState, event) {
        // Speed: Complete objective within time limit
        const elapsed = Date.now() - this.startTime;
        const timeLimit = (this.config.timeLimit || 30) * 1000;
        
        if (event.type === 'lines_cleared') {
            this.progress += event.linesCleared;
            
            if (this.progress >= (this.config.targetLines || 5)) {
                if (elapsed <= timeLimit) {
                    this.completed = true;
                    const timeBonus = Math.floor((timeLimit - elapsed) / 1000);
                    return {
                        completed: true,
                        message: `Speed clear! Completed with ${timeBonus}s to spare!`,
                        bonus: timeBonus * 100
                    };
                } else {
                    this.failed = true;
                    return {
                        failed: true,
                        message: 'Too slow! Time limit exceeded.'
                    };
                }
            }
        }
        
        if (elapsed > timeLimit && !this.completed) {
            this.failed = true;
            return {
                failed: true,
                message: 'Time limit exceeded!'
            };
        }
        
        return { 
            completed: false, 
            progress: this.progress,
            timeRemaining: Math.max(0, Math.floor((timeLimit - elapsed) / 1000))
        };
    }
    
    checkNoRotation(gameState, event) {
        // No Rotation: Complete without rotating pieces
        if (event.type === 'piece_rotated') {
            this.failed = true;
            return {
                failed: true,
                message: 'Failed! You rotated a piece.'
            };
        }
        
        if (event.type === 'lines_cleared') {
            this.progress += event.linesCleared;
            
            if (this.progress >= (this.config.targetLines || 3)) {
                this.completed = true;
                return {
                    completed: true,
                    message: 'No-rotation mastery! Completed without rotating!'
                };
            }
        }
        
        return { completed: false, progress: this.progress };
    }
    
    checkChain(gameState, event) {
        // Chain: Clear lines in consecutive drops
        if (event.type === 'lines_cleared') {
            if (event.linesCleared > 0) {
                this.progress++;
                
                if (this.progress >= (this.config.targetChain || 5)) {
                    this.completed = true;
                    return {
                        completed: true,
                        message: `Chain complete! ${this.progress} consecutive clears!`
                    };
                }
            }
        } else if (event.type === 'piece_placed' && !event.clearedLines) {
            // Chain broken
            if (this.progress > 0) {
                const broken = this.progress;
                this.progress = 0;
                return {
                    chainBroken: true,
                    message: `Chain broken at ${broken}! Start over.`
                };
            }
        }
        
        return { completed: false, progress: this.progress };
    }
    
    checkPattern(gameState, event) {
        // Pattern: Create specific shape or pattern
        if (event.type === 'piece_placed' || event.type === 'lines_cleared') {
            const pattern = this.config.pattern || 'checkerboard';
            const matched = this.checkGridPattern(gameState.grid, pattern);
            
            if (matched) {
                this.completed = true;
                return {
                    completed: true,
                    message: `Pattern complete! Created ${pattern} successfully!`
                };
            }
            
            // Calculate pattern progress
            this.progress = this.calculatePatternProgress(gameState.grid, pattern);
        }
        
        return { 
            completed: false, 
            progress: Math.floor(this.progress * 100),
            hint: this.getPatternHint(this.config.pattern)
        };
    }
    
    checkSurvival(gameState, event) {
        // Survival: Survive for duration without topping out
        const elapsed = Date.now() - this.startTime;
        const survivalTime = (this.config.survivalTime || 60) * 1000;
        
        if (gameState.gameOver) {
            this.failed = true;
            return {
                failed: true,
                message: `Failed! Survived ${Math.floor(elapsed / 1000)}s`
            };
        }
        
        if (elapsed >= survivalTime) {
            this.completed = true;
            return {
                completed: true,
                message: `Survival complete! Lasted ${Math.floor(survivalTime / 1000)}s!`
            };
        }
        
        this.progress = (elapsed / survivalTime) * 100;
        
        return {
            completed: false,
            progress: Math.floor(this.progress),
            timeRemaining: Math.floor((survivalTime - elapsed) / 1000)
        };
    }
    
    checkClassicObjective(gameState, event) {
        // Handle classic objectives
        switch (this.type) {
            case PUZZLE_OBJECTIVE_TYPES.CLEAR:
                if (event.type === 'lines_cleared') {
                    this.progress += event.linesCleared;
                    if (this.progress >= (this.config.targetLines || 1)) {
                        this.completed = true;
                    }
                }
                break;
                
            case PUZZLE_OBJECTIVE_TYPES.PERFECT:
                if (gameState.grid && gameState.grid.isEmpty()) {
                    this.completed = true;
                }
                break;
                
            case PUZZLE_OBJECTIVE_TYPES.TSPIN:
                if (event.type === 'special_clear' && event.clearType === 'tspin') {
                    this.progress++;
                    if (this.progress >= (this.config.targetTSpins || 1)) {
                        this.completed = true;
                    }
                }
                break;
                
            case PUZZLE_OBJECTIVE_TYPES.TETRIS:
                if (event.type === 'lines_cleared' && event.linesCleared === 4) {
                    this.progress++;
                    if (this.progress >= (this.config.targetTetris || 1)) {
                        this.completed = true;
                    }
                }
                break;
                
            case PUZZLE_OBJECTIVE_TYPES.COMBO:
                if (event.type === 'combo_update') {
                    this.progress = Math.max(this.progress, event.combo);
                    if (this.progress >= (this.config.targetCombo || 3)) {
                        this.completed = true;
                    }
                }
                break;
        }
        
        return { 
            completed: this.completed, 
            progress: this.progress 
        };
    }
    
    checkGridPattern(grid, patternType) {
        switch (patternType) {
            case 'checkerboard':
                return this.isCheckerboard(grid);
            case 'pyramid':
                return this.isPyramid(grid);
            case 'stairs':
                return this.isStairs(grid);
            case 'columns':
                return this.isColumns(grid);
            case 'zigzag':
                return this.isZigzag(grid);
            default:
                return false;
        }
    }
    
    isCheckerboard(grid) {
        // Check if bottom rows form a checkerboard pattern
        const checkRows = 4;
        const startRow = grid.length - checkRows;
        
        for (let row = startRow; row < grid.length; row++) {
            for (let col = 0; col < grid[row].length; col++) {
                const expected = ((row + col) % 2 === 0) ? 1 : 0;
                if ((grid[row][col] > 0 ? 1 : 0) !== expected) {
                    return false;
                }
            }
        }
        return true;
    }
    
    isPyramid(grid) {
        // Check if blocks form a pyramid shape
        const height = 5;
        const startRow = grid.length - height;
        const centerCol = Math.floor(grid[0].length / 2);
        
        for (let i = 0; i < height; i++) {
            const row = startRow + i;
            const width = height - i;
            const startCol = centerCol - width + 1;
            const endCol = centerCol + width - 1;
            
            for (let col = 0; col < grid[row].length; col++) {
                if (col >= startCol && col <= endCol) {
                    if (grid[row][col] === 0) return false;
                } else {
                    if (grid[row][col] !== 0) return false;
                }
            }
        }
        return true;
    }
    
    isStairs(grid) {
        // Check if blocks form stairs pattern
        const height = 4;
        const startRow = grid.length - height;
        
        for (let i = 0; i < height; i++) {
            const row = startRow + i;
            const expectedHeight = height - i;
            
            for (let col = 0; col < expectedHeight; col++) {
                if (grid[row][col] === 0) return false;
            }
            for (let col = expectedHeight; col < grid[row].length; col++) {
                if (grid[row][col] !== 0) return false;
            }
        }
        return true;
    }
    
    isColumns(grid) {
        // Check if blocks form alternating columns
        const height = 6;
        const startRow = grid.length - height;
        
        for (let row = startRow; row < grid.length; row++) {
            for (let col = 0; col < grid[row].length; col++) {
                const expected = (col % 2 === 0) ? 1 : 0;
                if ((grid[row][col] > 0 ? 1 : 0) !== expected) {
                    return false;
                }
            }
        }
        return true;
    }
    
    isZigzag(grid) {
        // Check if blocks form zigzag pattern
        const height = 4;
        const startRow = grid.length - height;
        
        for (let i = 0; i < height; i++) {
            const row = startRow + i;
            const offset = i % 2;
            
            for (let col = 0; col < grid[row].length - 1; col++) {
                const expected = ((col + offset) % 2 === 0) ? 1 : 0;
                if ((grid[row][col] > 0 ? 1 : 0) !== expected) {
                    return false;
                }
            }
        }
        return true;
    }
    
    calculatePatternProgress(grid, patternType) {
        // Calculate how close the grid is to matching the pattern
        let totalCells = 0;
        let matchingCells = 0;
        
        switch (patternType) {
            case 'checkerboard':
                const checkRows = 4;
                const startRow = grid.length - checkRows;
                totalCells = checkRows * grid[0].length;
                
                for (let row = startRow; row < grid.length; row++) {
                    for (let col = 0; col < grid[row].length; col++) {
                        const expected = ((row + col) % 2 === 0);
                        const actual = grid[row][col] > 0;
                        if (expected === actual) matchingCells++;
                    }
                }
                break;
                
            // Add other pattern progress calculations...
        }
        
        return totalCells > 0 ? matchingCells / totalCells : 0;
    }
    
    getPatternHint(patternType) {
        const hints = {
            checkerboard: 'Create alternating filled and empty cells',
            pyramid: 'Build a pyramid shape in the center',
            stairs: 'Create descending stairs from left to right',
            columns: 'Form alternating vertical columns',
            zigzag: 'Create a zigzag pattern'
        };
        return hints[patternType] || 'Create the required pattern';
    }
    
    getDescription() {
        switch (this.type) {
            case PUZZLE_OBJECTIVE_TYPES.CASCADE:
                return `Clear ${this.config.targetCascade || 3} lines with cascade effect`;
                
            case PUZZLE_OBJECTIVE_TYPES.SPEED:
                return `Clear ${this.config.targetLines || 5} lines in ${this.config.timeLimit || 30} seconds`;
                
            case PUZZLE_OBJECTIVE_TYPES.NO_ROTATION:
                return `Clear ${this.config.targetLines || 3} lines without rotating`;
                
            case PUZZLE_OBJECTIVE_TYPES.CHAIN:
                return `Clear lines in ${this.config.targetChain || 5} consecutive drops`;
                
            case PUZZLE_OBJECTIVE_TYPES.PATTERN:
                return `Create a ${this.config.pattern || 'checkerboard'} pattern`;
                
            case PUZZLE_OBJECTIVE_TYPES.SURVIVAL:
                return `Survive for ${this.config.survivalTime || 60} seconds`;
                
            default:
                return 'Complete the objective';
        }
    }
    
    getProgressText() {
        switch (this.type) {
            case PUZZLE_OBJECTIVE_TYPES.CASCADE:
                return `Cascade: ${this.progress}/${this.config.targetCascade || 3}`;
                
            case PUZZLE_OBJECTIVE_TYPES.SPEED:
                return `Lines: ${this.progress}/${this.config.targetLines || 5}`;
                
            case PUZZLE_OBJECTIVE_TYPES.NO_ROTATION:
                return `No-Rotation: ${this.progress}/${this.config.targetLines || 3}`;
                
            case PUZZLE_OBJECTIVE_TYPES.CHAIN:
                return `Chain: ${this.progress}/${this.config.targetChain || 5}`;
                
            case PUZZLE_OBJECTIVE_TYPES.PATTERN:
                return `Pattern: ${Math.floor(this.progress * 100)}%`;
                
            case PUZZLE_OBJECTIVE_TYPES.SURVIVAL:
                return `Survival: ${Math.floor(this.progress)}%`;
                
            default:
                return `Progress: ${this.progress}`;
        }
    }
}

// Factory function to create objectives from puzzle data
window.createObjective = function createObjective(puzzleData) {
    const type = puzzleData.objective || PUZZLE_OBJECTIVE_TYPES.CLEAR;
    const config = {
        targetLines: puzzleData.targetLines,
        targetCascade: puzzleData.targetCascade,
        targetTSpins: puzzleData.targetTSpins,
        targetTetris: puzzleData.targetTetris,
        targetCombo: puzzleData.targetCombo,
        targetChain: puzzleData.targetChain,
        timeLimit: puzzleData.timeLimit,
        survivalTime: puzzleData.survivalTime,
        pattern: puzzleData.pattern,
        minScore: puzzleData.minScore
    };
    
    return new PuzzleObjective(type, config);
}
})();

/* scripts/puzzles/hintSystem.js */
(function() {
// Hint System for Puzzle Mode
window.HintSystem = class HintSystem {
    constructor(game) {
        this.game = game;
        this.hintsAvailable = 3; // Maximum hints per puzzle
        this.hintsUsed = 0;
        this.hintCooldown = 0;
        this.cooldownDuration = 5000; // 5 seconds between hints
        this.lastHintTime = 0;
        this.currentHintAnimation = null;
    }
    
    initialize(puzzle) {
        this.hintsAvailable = 3;
        this.hintsUsed = 0;
        this.hintCooldown = 0;
        this.lastHintTime = 0;
        this.puzzle = puzzle;
        
        // Add hint button to UI
        this.createHintButton();
    }
    
    createHintButton() {
        // Check if button already exists
        let hintButton = document.getElementById('hint-button');
        if (!hintButton) {
            hintButton = document.createElement('button');
            hintButton.id = 'hint-button';
            hintButton.className = 'hint-button';
            hintButton.innerHTML = `
                <span class="hint-icon"></span>
                <span class="hint-count">${this.hintsAvailable - this.hintsUsed}/3</span>
            `;
            
            // Add to game UI
            const gameHeader = document.querySelector('.game-header');
            if (gameHeader) {
                gameHeader.appendChild(hintButton);
            }
            
            // Add click handler
            hintButton.addEventListener('click', () => {
                this.useHint();
            });
        }
        
        this.updateHintButton();
    }
    
    updateHintButton() {
        const hintButton = document.getElementById('hint-button');
        if (!hintButton) return;
        
        const countSpan = hintButton.querySelector('.hint-count');
        if (countSpan) {
            countSpan.textContent = `${this.hintsAvailable - this.hintsUsed}/3`;
        }
        
        // Update button state
        const isOnCooldown = Date.now() - this.lastHintTime < this.cooldownDuration;
        const hasHintsLeft = this.hintsUsed < this.hintsAvailable;
        
        hintButton.disabled = !hasHintsLeft || isOnCooldown;
        
        if (isOnCooldown) {
            const remainingTime = Math.ceil((this.cooldownDuration - (Date.now() - this.lastHintTime)) / 1000);
            hintButton.title = `Cooldown: ${remainingTime}s`;
        } else if (!hasHintsLeft) {
            hintButton.title = 'No hints remaining';
        } else {
            hintButton.title = `Use hint (costs 1 star)`;
        }
    }
    
    useHint() {
        // Check if hint can be used
        if (this.hintsUsed >= this.hintsAvailable) {
            this.showMessage('No hints remaining!', 'warning');
            return false;
        }
        
        // Check cooldown
        if (Date.now() - this.lastHintTime < this.cooldownDuration) {
            const remaining = Math.ceil((this.cooldownDuration - (Date.now() - this.lastHintTime)) / 1000);
            this.showMessage(`Hint cooldown: ${remaining}s`, 'info');
            return false;
        }
        
        // Determine hint level based on hints used
        const hintLevel = this.hintsUsed + 1;
        
        switch(hintLevel) {
            case 1:
                this.showHintLevel1(); // Position suggestion
                break;
            case 2:
                this.showHintLevel2(); // Rotation suggestion
                break;
            case 3:
                this.showHintLevel3(); // Full solution
                break;
        }
        
        // Update hint usage
        this.hintsUsed++;
        this.lastHintTime = Date.now();
        
        // Update button
        this.updateHintButton();
        
        // Notify game mode
        if (this.game.gameMode && this.game.gameMode.hintsUsed !== undefined) {
            this.game.gameMode.hintsUsed = this.hintsUsed;
        }
        
        // Start cooldown timer
        this.startCooldownTimer();
        
        return true;
    }
    
    showHintLevel1() {
        // Level 1: Show optimal column position
        const optimalPosition = this.calculateOptimalPosition();
        
        if (optimalPosition !== null) {
            // Create visual indicator
            this.createColumnHighlight(optimalPosition);
            
            this.showMessage('Hint 1: Best column highlighted (1)', 'hint');
            
            // Play hint sound
            if (this.game.audioManager) {
                this.game.audioManager.playSFX('hint');
            }
        }
    }
    
    showHintLevel2() {
        // Level 2: Show optimal rotation
        const optimalRotation = this.calculateOptimalRotation();
        
        if (optimalRotation !== null) {
            // Create rotation indicator
            this.createRotationIndicator(optimalRotation);
            
            this.showMessage(`Hint 2: Rotate ${optimalRotation} times (1)`, 'hint');
            
            // Play hint sound
            if (this.game.audioManager) {
                this.game.audioManager.playSFX('hint');
            }
        }
    }
    
    showHintLevel3() {
        // Level 3: Show full ghost solution
        const solution = this.calculateFullSolution();
        
        if (solution) {
            // Create enhanced ghost piece
            this.createSolutionGhost(solution);
            
            this.showMessage('Hint 3: Full solution shown (2)', 'hint');
            
            // Play hint sound
            if (this.game.audioManager) {
                this.game.audioManager.playSFX('hint_major');
            }
        }
    }
    
    calculateOptimalPosition() {
        if (!this.game.currentPiece) return null;
        
        // Simple heuristic: find position that creates least holes
        let bestColumn = Math.floor(this.game.grid.width / 2);
        let minHoles = Infinity;
        
        for (let col = 0; col < this.game.grid.width - this.game.currentPiece.shape[0].length + 1; col++) {
            // Test placing piece at this column
            const testPiece = Object.assign({}, this.game.currentPiece);
            testPiece.x = col;
            
            // Find drop position
            while (testPiece.canMove(0, 1, this.game.grid)) {
                testPiece.y++;
            }
            
            // Count holes that would be created
            const holes = this.countHolesAfterPlacement(testPiece);
            
            if (holes < minHoles) {
                minHoles = holes;
                bestColumn = col;
            }
        }
        
        return bestColumn;
    }
    
    calculateOptimalRotation() {
        if (!this.game.currentPiece) return null;
        
        // Test all 4 rotations
        let bestRotation = 0;
        let bestScore = -Infinity;
        
        for (let rot = 0; rot < 4; rot++) {
            const testPiece = Object.assign({}, this.game.currentPiece);
            
            // Apply rotations
            for (let i = 0; i < rot; i++) {
                testPiece.rotate(this.game.grid);
            }
            
            // Evaluate position
            const score = this.evaluatePosition(testPiece);
            
            if (score > bestScore) {
                bestScore = score;
                bestRotation = rot;
            }
        }
        
        return bestRotation;
    }
    
    calculateFullSolution() {
        if (!this.game.currentPiece) return null;
        
        // Find best position and rotation
        let bestSolution = null;
        let bestScore = -Infinity;
        
        for (let rot = 0; rot < 4; rot++) {
            for (let col = 0; col < this.game.grid.width; col++) {
                const testPiece = Object.assign({}, this.game.currentPiece);
                
                // Apply rotation
                for (let i = 0; i < rot; i++) {
                    testPiece.rotate(this.game.grid);
                }
                
                // Set position
                testPiece.x = col;
                
                // Check if valid
                if (!testPiece.isValidPosition(this.game.grid)) continue;
                
                // Find drop position
                while (testPiece.canMove(0, 1, this.game.grid)) {
                    testPiece.y++;
                }
                
                // Evaluate
                const score = this.evaluatePosition(testPiece);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestSolution = {
                        x: testPiece.x,
                        y: testPiece.y,
                        rotation: rot,
                        shape: testPiece.shape
                    };
                }
            }
        }
        
        return bestSolution;
    }
    
    evaluatePosition(piece) {
        // Scoring heuristic for position quality
        let score = 0;
        
        // Penalize height
        score -= piece.y * 10;
        
        // Penalize holes
        score -= this.countHolesAfterPlacement(piece) * 30;
        
        // Reward line clears
        score += this.countPotentialLineClears(piece) * 100;
        
        // Penalize column differences (bumpiness)
        score -= this.calculateBumpiness(piece) * 5;
        
        return score;
    }
    
    countHolesAfterPlacement(piece) {
        // Simulate placement and count holes
        let holes = 0;
        
        // This is a simplified version - in reality would need full simulation
        for (let y = piece.y + piece.shape.length; y < this.game.grid.height; y++) {
            for (let x = 0; x < this.game.grid.width; x++) {
                if (this.game.grid.cells[y][x] === 0) {
                    // Check if there's a block above
                    for (let checkY = y - 1; checkY >= 0; checkY--) {
                        if (this.game.grid.cells[checkY][x] !== 0) {
                            holes++;
                            break;
                        }
                    }
                }
            }
        }
        
        return holes;
    }
    
    countPotentialLineClears(piece) {
        // Count how many lines would be cleared
        let clears = 0;
        
        for (let y = 0; y < piece.shape.length; y++) {
            let lineComplete = true;
            for (let x = 0; x < this.game.grid.width; x++) {
                // Check if this position would be filled
                const pieceHasBlock = (x >= piece.x && 
                                       x < piece.x + piece.shape[0].length &&
                                       piece.shape[y][x - piece.x] !== 0);
                
                if (!pieceHasBlock && this.game.grid.cells[piece.y + y][x] === 0) {
                    lineComplete = false;
                    break;
                }
            }
            
            if (lineComplete) clears++;
        }
        
        return clears;
    }
    
    calculateBumpiness(piece) {
        // Calculate height differences between columns
        const heights = [];
        
        for (let x = 0; x < this.game.grid.width; x++) {
            let height = 0;
            for (let y = 0; y < this.game.grid.height; y++) {
                if (this.game.grid.cells[y][x] !== 0) {
                    height = this.game.grid.height - y;
                    break;
                }
            }
            heights.push(height);
        }
        
        let bumpiness = 0;
        for (let i = 0; i < heights.length - 1; i++) {
            bumpiness += Math.abs(heights[i] - heights[i + 1]);
        }
        
        return bumpiness;
    }
    
    createColumnHighlight(column) {
        // Remove existing highlight
        this.clearHintAnimations();
        
        // Create highlight element
        const highlight = document.createElement('div');
        highlight.className = 'hint-column-highlight';
        highlight.style.cssText = `
            position: absolute;
            left: ${column * this.game.cellSize}px;
            top: 0;
            width: ${this.game.cellSize}px;
            height: 100%;
            background: linear-gradient(180deg, 
                rgba(255, 255, 0, 0.3) 0%, 
                rgba(255, 255, 0, 0.1) 100%);
            border: 2px solid #ffff00;
            pointer-events: none;
            animation: pulse 1s infinite;
            z-index: 10;
        `;
        
        // Add to canvas container
        const canvasContainer = this.game.canvas.parentElement;
        if (canvasContainer) {
            canvasContainer.style.position = 'relative';
            canvasContainer.appendChild(highlight);
            
            this.currentHintAnimation = highlight;
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.remove();
                }
            }, 5000);
        }
    }
    
    createRotationIndicator(rotations) {
        // Create rotation arrow indicator
        const indicator = document.createElement('div');
        indicator.className = 'hint-rotation-indicator';
        indicator.innerHTML = `  ${rotations}`;
        indicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            animation: rotateHint 2s ease-out;
            pointer-events: none;
            z-index: 1000;
        `;
        
        document.body.appendChild(indicator);
        
        this.currentHintAnimation = indicator;
        
        // Remove after animation
        setTimeout(() => {
            if (indicator.parentNode) {
                indicator.remove();
            }
        }, 2000);
    }
    
    createSolutionGhost(solution) {
        // Clear existing
        this.clearHintAnimations();
        
        // Create enhanced ghost piece at solution position
        if (this.game.ghostPiece) {
            this.game.ghostPiece.x = solution.x;
            this.game.ghostPiece.y = solution.y;
            this.game.ghostPiece.shape = solution.shape;
            
            // Add glowing effect to ghost
            this.game.ghostPiece.hintMode = true;
        }
        
        // Show arrows indicating movement
        this.createMovementArrows(solution);
    }
    
    createMovementArrows(solution) {
        // Create visual arrows showing how to move piece
        const currentX = this.game.currentPiece.x;
        const targetX = solution.x;
        
        if (currentX !== targetX) {
            const arrow = document.createElement('div');
            arrow.className = 'hint-movement-arrow';
            arrow.innerHTML = targetX > currentX ? '' : '';
            arrow.style.cssText = `
                position: absolute;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 4rem;
                color: #ffff00;
                animation: slideHint 1s infinite;
                pointer-events: none;
                z-index: 100;
            `;
            
            const canvasContainer = this.game.canvas.parentElement;
            if (canvasContainer) {
                canvasContainer.appendChild(arrow);
                
                setTimeout(() => {
                    if (arrow.parentNode) {
                        arrow.remove();
                    }
                }, 5000);
            }
        }
    }
    
    clearHintAnimations() {
        // Remove any existing hint animations
        if (this.currentHintAnimation && this.currentHintAnimation.parentNode) {
            this.currentHintAnimation.remove();
        }
        
        // Clear hint mode on ghost piece
        if (this.game.ghostPiece) {
            this.game.ghostPiece.hintMode = false;
        }
    }
    
    startCooldownTimer() {
        // Update button every second during cooldown
        const interval = setInterval(() => {
            this.updateHintButton();
            
            if (Date.now() - this.lastHintTime >= this.cooldownDuration) {
                clearInterval(interval);
            }
        }, 1000);
    }
    
    showMessage(text, type) {
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(text, type, 2000);
        }
    }
    
    cleanup() {
        // Remove hint button
        const hintButton = document.getElementById('hint-button');
        if (hintButton) {
            hintButton.remove();
        }
        
        // Clear animations
        this.clearHintAnimations();
    }
    
    getHintsUsed() {
        return this.hintsUsed;
    }
}
})();

/* scripts/puzzles/puzzleValidator.js */
(function() {
// Puzzle Validator - Automatic validation system for puzzle feasibility


window.PuzzleValidator = class PuzzleValidator {
    constructor() {
        this.pieceShapes = this.initializePieceShapes();
    }
    
    initializePieceShapes() {
        const shapes = {};
        for (const [type, rotations] of Object.entries(PIECE_SHAPES)) {
            // PIECE_SHAPES already contains all rotations
            shapes[type] = rotations;
        }
        return shapes;
    }
    
    getAllRotations(shape) {
        const rotations = [shape];
        let current = shape;
        
        // Get all 4 rotations
        for (let i = 0; i < 3; i++) {
            current = this.rotateMatrix(current);
            rotations.push(current);
        }
        
        return rotations;
    }
    
    rotateMatrix(matrix) {
        const n = matrix.length;
        const rotated = Array(n).fill(null).map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                rotated[j][n - 1 - i] = matrix[i][j];
            }
        }
        
        return rotated;
    }
    
    /**
     * Validates if a puzzle is solvable
     * @param {Object} puzzle - Puzzle configuration
     * @returns {Object} Validation result with details
     */
    validatePuzzle(puzzle) {
        const result = {
            valid: false,
            solvable: false,
            difficulty: 'unknown',
            issues: [],
            suggestions: [],
            minPiecesRequired: 0,
            theoreticalSolutions: 0
        };
        
        // Basic validation
        if (!puzzle.grid || !puzzle.objective || !puzzle.pieces) {
            result.issues.push('Missing required puzzle properties');
            return result;
        }
        
        // Check if grid is valid
        if (!this.isValidGrid(puzzle.grid)) {
            result.issues.push('Invalid grid configuration');
            return result;
        }
        
        // Check objective feasibility
        const objectiveAnalysis = this.analyzeObjective(puzzle);
        if (!objectiveAnalysis.feasible) {
            result.issues.push(objectiveAnalysis.issue);
            result.suggestions.push(objectiveAnalysis.suggestion);
            return result;
        }
        
        // Calculate minimum pieces needed
        const minPieces = this.calculateMinimumPieces(puzzle);
        result.minPiecesRequired = minPieces;
        
        // Check if enough pieces are provided
        if (puzzle.pieces.length < minPieces) {
            result.issues.push(`Not enough pieces: ${puzzle.pieces.length} provided, ${minPieces} required`);
            result.suggestions.push(`Add at least ${minPieces - puzzle.pieces.length} more pieces`);
            return result;
        }
        
        // Check if pieces can actually solve the puzzle
        const solutionAnalysis = this.findSolutions(puzzle);
        result.theoreticalSolutions = solutionAnalysis.count;
        result.solvable = solutionAnalysis.count > 0;
        
        if (!result.solvable) {
            result.issues.push('No valid solution found with given pieces');
            result.suggestions = result.suggestions.concat(solutionAnalysis.suggestions);
            return result;
        }
        
        // Determine difficulty based on solution count and constraints
        result.difficulty = this.calculateDifficulty(puzzle, solutionAnalysis);
        
        // Mark as valid if we made it here
        result.valid = true;
        
        return result;
    }
    
    isValidGrid(grid) {
        if (!Array.isArray(grid) || grid.length !== GRID_HEIGHT) {
            return false;
        }
        
        for (const row of grid) {
            if (!Array.isArray(row) || row.length !== GRID_WIDTH) {
                return false;
            }
            for (const cell of row) {
                if (typeof cell !== 'number' || cell < 0 || cell > 9) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    analyzeObjective(puzzle) {
        const result = {
            feasible: true,
            issue: '',
            suggestion: ''
        };
        
        switch (puzzle.objective.type) {
            case 'lines':
                const maxPossibleLines = this.calculateMaxPossibleLines(puzzle);
                if (puzzle.objective.count > maxPossibleLines) {
                    result.feasible = false;
                    result.issue = `Objective requires ${puzzle.objective.count} lines but only ${maxPossibleLines} are possible`;
                    result.suggestion = `Reduce objective to ${maxPossibleLines} lines or modify grid`;
                }
                break;
                
            case 'clear':
                const totalBlocks = this.countBlocks(puzzle.grid);
                const maxClearable = this.calculateMaxClearableBlocks(puzzle);
                if (totalBlocks > maxClearable) {
                    result.feasible = false;
                    result.issue = `Cannot clear all blocks with available pieces`;
                    result.suggestion = `Add more pieces or reduce initial blocks`;
                }
                break;
                
            case 'score':
                // Score objectives are generally feasible if lines can be cleared
                const canScore = this.calculateMaxPossibleLines(puzzle) > 0;
                if (!canScore) {
                    result.feasible = false;
                    result.issue = `No lines can be cleared to generate score`;
                    result.suggestion = `Modify grid to allow line clears`;
                }
                break;
        }
        
        return result;
    }
    
    calculateMinimumPieces(puzzle) {
        switch (puzzle.objective.type) {
            case 'lines':
                // Each piece can contribute to at most 1 line (4 blocks per line / 4 blocks per piece)
                return Math.ceil(puzzle.objective.count);
                
            case 'clear':
                // Need to fill gaps to clear the board
                const emptySpaces = this.countEmptySpaces(puzzle.grid);
                return Math.ceil(emptySpaces / 4); // Each piece has 4 blocks
                
            case 'score':
                // Depends on target score, but minimum 1 line clear
                return Math.ceil(puzzle.objective.target / 1000); // Rough estimate
                
            default:
                return 1;
        }
    }
    
    findSolutions(puzzle) {
        const result = {
            count: 0,
            suggestions: []
        };
        
        // Simplified solution finder - checks if pieces can theoretically achieve objective
        // This is a basic implementation - a full solver would use backtracking
        
        const totalBlocks = puzzle.pieces.length * 4;
        const requiredBlocks = this.calculateRequiredBlocks(puzzle);
        
        if (totalBlocks < requiredBlocks) {
            result.suggestions.push(`Need at least ${Math.ceil(requiredBlocks / 4)} pieces`);
            return result;
        }
        
        // Check if specific pieces are needed
        if (puzzle.objective.type === 'lines') {
            const analysis = this.analyzeLineRequirements(puzzle);
            if (analysis.needsSpecificPieces) {
                result.suggestions = result.suggestions.concat(analysis.suggestions);
                if (!analysis.hasSolution) {
                    return result;
                }
            }
        }
        
        // If we made it here, assume at least one solution exists
        // (Full implementation would actually find solutions)
        result.count = 1;
        
        return result;
    }
    
    calculateRequiredBlocks(puzzle) {
        switch (puzzle.objective.type) {
            case 'lines':
                // Need to fill complete lines
                const emptyInTargetLines = this.countEmptyInTargetLines(puzzle);
                return emptyInTargetLines;
                
            case 'clear':
                // Need to fill all empty spaces
                return this.countEmptySpaces(puzzle.grid);
                
            default:
                return 0;
        }
    }
    
    countEmptyInTargetLines(puzzle) {
        let count = 0;
        const targetLines = puzzle.objective.count;
        
        // Count from bottom up
        for (let row = GRID_HEIGHT - 1; row >= GRID_HEIGHT - targetLines && row >= 0; row--) {
            for (let col = 0; col < GRID_WIDTH; col++) {
                if (puzzle.grid[row][col] === 0) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    analyzeLineRequirements(puzzle) {
        const result = {
            needsSpecificPieces: false,
            hasSolution: true,
            suggestions: []
        };
        
        // Check each target line
        const targetLines = puzzle.objective.count;
        for (let i = 0; i < targetLines; i++) {
            const row = GRID_HEIGHT - 1 - i;
            if (row < 0) break;
            
            const emptyCount = puzzle.grid[row].filter(cell => cell === 0).length;
            
            // Special cases
            if (emptyCount === 1) {
                // Need exactly 1 block - only I piece in specific orientation
                result.needsSpecificPieces = true;
                if (!puzzle.pieces.includes('I')) {
                    result.hasSolution = false;
                    result.suggestions.push(`Line ${i + 1} has 1 gap - needs I piece`);
                }
            } else if (emptyCount === 2) {
                // Need 2 blocks - O piece is perfect
                if (!puzzle.pieces.includes('O') && puzzle.pieces.length < 2) {
                    result.suggestions.push(`Line ${i + 1} has 2 gaps - O piece recommended`);
                }
            }
        }
        
        return result;
    }
    
    calculateDifficulty(puzzle, solutionAnalysis) {
        const factors = {
            solutionCount: solutionAnalysis.count,
            pieceConstraint: puzzle.maxPieces / puzzle.pieces.length,
            gridComplexity: this.calculateGridComplexity(puzzle.grid),
            objectiveDifficulty: this.getObjectiveDifficulty(puzzle.objective)
        };
        
        // Weight the factors
        const score = 
            (1 / Math.max(1, factors.solutionCount)) * 40 +  // Fewer solutions = harder
            (1 / Math.max(1, factors.pieceConstraint)) * 20 + // Tighter constraint = harder
            factors.gridComplexity * 20 +                      // Complex grid = harder
            factors.objectiveDifficulty * 20;                  // Harder objective = harder
        
        if (score < 25) return 'easy';
        if (score < 50) return 'medium';
        if (score < 75) return 'hard';
        return 'expert';
    }
    
    calculateGridComplexity(grid) {
        let complexity = 0;
        
        // Check for holes and overhangs
        for (let col = 0; col < GRID_WIDTH; col++) {
            let foundBlock = false;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    foundBlock = true;
                } else if (foundBlock) {
                    complexity += 0.1; // Hole or overhang
                }
            }
        }
        
        // Check for irregular patterns
        for (let row = 0; row < GRID_HEIGHT - 1; row++) {
            for (let col = 0; col < GRID_WIDTH - 1; col++) {
                const pattern = [
                    grid[row][col],
                    grid[row][col + 1],
                    grid[row + 1][col],
                    grid[row + 1][col + 1]
                ];
                
                const uniqueValues = new Set(pattern).size;
                if (uniqueValues === 4) {
                    complexity += 0.05; // Very irregular
                }
            }
        }
        
        return Math.min(1, complexity);
    }
    
    getObjectiveDifficulty(objective) {
        switch (objective.type) {
            case 'lines':
                return Math.min(1, objective.count / 4); // 4+ lines is max difficulty
            case 'clear':
                return 0.8; // Clearing all is generally hard
            case 'score':
                return Math.min(1, objective.target / 10000); // Higher score = harder
            default:
                return 0.5;
        }
    }
    
    calculateMaxPossibleLines(puzzle) {
        // Count how many complete lines could theoretically be made
        let possibleLines = 0;
        let totalBlocks = puzzle.pieces.length * 4; // Changed from const to let
        
        for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
            const filledCount = puzzle.grid[row].filter(cell => cell !== 0).length;
            const emptyCount = GRID_WIDTH - filledCount;
            
            // Can we fill this line with available pieces?
            if (emptyCount <= totalBlocks) {
                possibleLines++;
                // Subtract blocks used for this line from total
                totalBlocks -= emptyCount;
            }
        }
        
        return possibleLines;
    }
    
    calculateMaxClearableBlocks(puzzle) {
        return puzzle.pieces.length * 4; // Each piece has 4 blocks
    }
    
    countBlocks(grid) {
        let count = 0;
        for (const row of grid) {
            for (const cell of row) {
                if (cell !== 0) count++;
            }
        }
        return count;
    }
    
    countEmptySpaces(grid) {
        let count = 0;
        for (const row of grid) {
            for (const cell of row) {
                if (cell === 0) count++;
            }
        }
        return count;
    }
    
    /**
     * Batch validate all puzzles
     * @param {Array} puzzles - Array of puzzle configurations
     * @returns {Object} Validation report
     */
    validateAllPuzzles(puzzles) {
        const report = {
            total: puzzles.length,
            valid: 0,
            invalid: 0,
            issues: [],
            byDifficulty: {
                easy: 0,
                medium: 0,
                hard: 0,
                expert: 0
            }
        };
        
        puzzles.forEach((puzzle, index) => {
            const result = this.validatePuzzle(puzzle);
            
            if (result.valid) {
                report.valid++;
                report.byDifficulty[result.difficulty]++;
            } else {
                report.invalid++;
                report.issues.push({
                    puzzleIndex: index,
                    puzzleName: puzzle.name || `Puzzle ${index + 1}`,
                    issues: result.issues,
                    suggestions: result.suggestions
                });
            }
        });
        
        return report;
    }
}

// Export singleton instance
window.puzzleValidator = const puzzleValidator = new PuzzleValidator();
})();

/* scripts/puzzles/puzzleAutoSolver.js */
(function() {
// Puzzle Auto-Solver with AI pathfinding
window.PuzzleAutoSolver = class PuzzleAutoSolver {
    constructor() {
        this.maxDepth = 10; // Maximum search depth
        this.maxStates = 10000; // Maximum states to explore
        this.statesExplored = 0;
        this.solution = null;
    }
    
    // Main solve function
    solve(puzzle) {
        this.statesExplored = 0;
        this.solution = null;
        
        // Convert puzzle to initial state
        const initialState = {
            grid: this.copyGrid(puzzle.grid || this.createEmptyGrid()),
            pieces: puzzle.pieces === 'random' ? this.generateRandomPieces(7) : [...puzzle.pieces],
            pieceIndex: 0,
            moves: [],
            linesCleared: 0,
            score: 0,
            objective: puzzle.objective,
            targetValue: this.getTargetValue(puzzle)
        };
        
        // Use iterative deepening DFS with alpha-beta pruning
        for (let depth = 1; depth <= this.maxDepth && !this.solution; depth++) {
            this.depthFirstSearch(initialState, depth, 0);
            
            if (this.statesExplored > this.maxStates) {
                break;
            }
        }
        
        return this.solution;
    }
    
    // Depth-first search with pruning
    depthFirstSearch(state, maxDepth, currentDepth) {
        if (this.solution || this.statesExplored > this.maxStates) {
            return;
        }
        
        this.statesExplored++;
        
        // Check if objective is met
        if (this.checkObjective(state)) {
            this.solution = {
                moves: state.moves,
                finalGrid: state.grid,
                linesCleared: state.linesCleared,
                piecesUsed: state.pieceIndex,
                score: state.score,
                success: true
            };
            return;
        }
        
        // Check if we've reached max depth or run out of pieces
        if (currentDepth >= maxDepth || state.pieceIndex >= state.pieces.length) {
            return;
        }
        
        // Get current piece
        const pieceType = state.pieces[state.pieceIndex];
        const piece = this.createPiece(pieceType);
        
        // Generate all possible placements
        const placements = this.generatePlacements(state.grid, piece);
        
        // Sort placements by heuristic score
        placements.sort((a, b) => this.evaluatePlacement(b, state) - this.evaluatePlacement(a, state));
        
        // Try top placements
        const topPlacements = placements.slice(0, Math.min(5, placements.length));
        
        for (const placement of topPlacements) {
            // Create new state
            const newState = this.applyPlacement(state, placement);
            
            // Recursively search
            this.depthFirstSearch(newState, maxDepth, currentDepth + 1);
            
            if (this.solution) {
                return;
            }
        }
    }
    
    // Generate all possible placements for a piece
    generatePlacements(grid, piece) {
        const placements = [];
        
        // Try all rotations
        for (let rotation = 0; rotation < 4; rotation++) {
            const rotatedPiece = this.rotatePiece(piece, rotation);
            
            // Try all columns
            for (let col = 0; col <= 10 - rotatedPiece[0].length; col++) {
                // Find drop position
                let row = 0;
                while (row < 20 && this.canPlace(grid, rotatedPiece, row + 1, col)) {
                    row++;
                }
                
                if (this.canPlace(grid, rotatedPiece, row, col)) {
                    placements.push({
                        piece: rotatedPiece,
                        row: row,
                        col: col,
                        rotation: rotation
                    });
                }
            }
        }
        
        return placements;
    }
    
    // Check if piece can be placed at position
    canPlace(grid, piece, row, col) {
        for (let r = 0; r < piece.length; r++) {
            for (let c = 0; c < piece[r].length; c++) {
                if (piece[r][c] !== 0) {
                    const gridRow = row + r;
                    const gridCol = col + c;
                    
                    if (gridRow < 0 || gridRow >= 20 || 
                        gridCol < 0 || gridCol >= 10 ||
                        grid[gridRow][gridCol] !== 0) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    // Apply placement and return new state
    applyPlacement(state, placement) {
        const newGrid = this.copyGrid(state.grid);
        
        // Place piece
        for (let r = 0; r < placement.piece.length; r++) {
            for (let c = 0; c < placement.piece[r].length; c++) {
                if (placement.piece[r][c] !== 0) {
                    newGrid[placement.row + r][placement.col + c] = placement.piece[r][c];
                }
            }
        }
        
        // Clear lines
        const clearedLines = this.clearLines(newGrid);
        
        // Create new state
        return {
            grid: newGrid,
            pieces: state.pieces,
            pieceIndex: state.pieceIndex + 1,
            moves: [...state.moves, {
                piece: state.pieces[state.pieceIndex],
                rotation: placement.rotation,
                column: placement.col,
                row: placement.row
            }],
            linesCleared: state.linesCleared + clearedLines.length,
            score: state.score + this.calculateScore(clearedLines.length),
            objective: state.objective,
            targetValue: state.targetValue
        };
    }
    
    // Evaluate placement quality
    evaluatePlacement(placement, state) {
        let score = 0;
        
        // Prefer lower placements
        score -= placement.row * 10;
        
        // Check for line clears
        const testGrid = this.copyGrid(state.grid);
        for (let r = 0; r < placement.piece.length; r++) {
            for (let c = 0; c < placement.piece[r].length; c++) {
                if (placement.piece[r][c] !== 0) {
                    testGrid[placement.row + r][placement.col + c] = placement.piece[r][c];
                }
            }
        }
        
        const clearedLines = this.clearLines(testGrid);
        score += clearedLines.length * 100;
        
        // Objective-specific scoring
        switch (state.objective.type) {
            case 'lines':
            case 'clear':
                score += clearedLines.length * 200;
                break;
                
            case 'tspin':
                if (this.isTSpin(placement, state.grid)) {
                    score += 500;
                }
                break;
                
            case 'tetris':
                if (clearedLines.length === 4) {
                    score += 1000;
                }
                break;
                
            case 'perfect':
                if (this.isPerfectClear(testGrid)) {
                    score += 2000;
                }
                break;
        }
        
        // Penalize holes
        score -= this.countHoles(testGrid) * 30;
        
        // Penalize height
        score -= this.getMaxHeight(testGrid) * 5;
        
        return score;
    }
    
    // Check if objective is met
    checkObjective(state) {
        switch (state.objective.type) {
            case 'lines':
                return state.linesCleared >= state.targetValue;
                
            case 'clear':
                return this.isGridEmpty(state.grid);
                
            case 'score':
                return state.score >= state.targetValue;
                
            case 'perfect':
                return this.isPerfectClear(state.grid);
                
            default:
                return false;
        }
    }
    
    // Detect T-Spin
    isTSpin(placement, grid) {
        // Simplified T-Spin detection
        const piece = placement.piece;
        const row = placement.row;
        const col = placement.col;
        
        // Check if it's a T piece
        if (!this.isTShape(piece)) return false;
        
        // Check corners for T-Spin pattern
        let filledCorners = 0;
        const corners = [
            [row, col],
            [row, col + 2],
            [row + 2, col],
            [row + 2, col + 2]
        ];
        
        for (const [r, c] of corners) {
            if (r >= 0 && r < 20 && c >= 0 && c < 10 && grid[r][c] !== 0) {
                filledCorners++;
            }
        }
        
        return filledCorners >= 3;
    }
    
    // Check if piece is T-shaped
    isTShape(piece) {
        // Simple check for T-piece pattern
        const flatPiece = piece.flat().filter(cell => cell !== 0);
        return flatPiece.length === 4; // T-piece has 4 blocks
    }
    
    // Clear complete lines
    clearLines(grid) {
        const clearedLines = [];
        
        for (let row = 19; row >= 0; row--) {
            if (grid[row].every(cell => cell !== 0)) {
                clearedLines.push(row);
                grid.splice(row, 1);
                grid.unshift(new Array(10).fill(0));
                row++; // Check same row again
            }
        }
        
        return clearedLines;
    }
    
    // Count holes in grid
    countHoles(grid) {
        let holes = 0;
        
        for (let col = 0; col < 10; col++) {
            let blockFound = false;
            for (let row = 0; row < 20; row++) {
                if (grid[row][col] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        
        return holes;
    }
    
    // Get maximum height
    getMaxHeight(grid) {
        for (let row = 0; row < 20; row++) {
            if (grid[row].some(cell => cell !== 0)) {
                return 20 - row;
            }
        }
        return 0;
    }
    
    // Check if grid is empty
    isGridEmpty(grid) {
        return grid.every(row => row.every(cell => cell === 0));
    }
    
    // Check for perfect clear
    isPerfectClear(grid) {
        return this.isGridEmpty(grid);
    }
    
    // Calculate score for lines cleared
    calculateScore(lines) {
        const scores = [0, 100, 300, 500, 800];
        return scores[Math.min(lines, 4)];
    }
    
    // Utility functions
    copyGrid(grid) {
        return grid.map(row => [...row]);
    }
    
    createEmptyGrid() {
        return Array(20).fill(null).map(() => Array(10).fill(0));
    }
    
    createPiece(type) {
        const pieces = {
            'I': [[1,1,1,1]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1]],
            'S': [[0,1,1],[1,1,0]],
            'Z': [[1,1,0],[0,1,1]],
            'J': [[1,0,0],[1,1,1]],
            'L': [[0,0,1],[1,1,1]]
        };
        return pieces[type] || pieces['T'];
    }
    
    rotatePiece(piece, times) {
        let rotated = piece;
        for (let i = 0; i < times; i++) {
            rotated = this.rotate90(rotated);
        }
        return rotated;
    }
    
    rotate90(matrix) {
        const n = matrix.length;
        const m = matrix[0].length;
        const rotated = Array(m).fill(null).map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < m; j++) {
                rotated[j][n - 1 - i] = matrix[i][j];
            }
        }
        
        return rotated;
    }
    
    generateRandomPieces(count) {
        const types = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        const pieces = [];
        for (let i = 0; i < count; i++) {
            pieces.push(types[Math.floor(Math.random() * types.length)]);
        }
        return pieces;
    }
    
    getTargetValue(puzzle) {
        return puzzle.targetLines || puzzle.targetScore || 
               puzzle.targetTSpins || puzzle.targetTetris || 
               puzzle.targetCombo || 1;
    }
}
})();

/* scripts/puzzles/puzzleDifficultyAnalyzer.js */
(function() {
// Puzzle Difficulty Analyzer

window.PuzzleDifficultyAnalyzer = class PuzzleDifficultyAnalyzer {
    constructor() {
        this.solver = new PuzzleAutoSolver();
        this.metrics = {};
    }
    
    // Analyze puzzle difficulty
    analyze(puzzle) {
        this.metrics = {
            // Basic metrics
            gridComplexity: this.analyzeGridComplexity(puzzle.grid),
            pieceConstraints: this.analyzePieceConstraints(puzzle),
            objectiveDifficulty: this.analyzeObjectiveDifficulty(puzzle),
            
            // Advanced metrics
            solutionComplexity: 0,
            minimumMoves: 0,
            optimalPath: null,
            alternativeSolutions: 0,
            
            // Skill requirements
            skillsRequired: [],
            techniques: [],
            
            // Time estimates
            estimatedTime: {
                beginner: 0,
                intermediate: 0,
                expert: 0
            },
            
            // Overall rating
            difficulty: 1,
            difficultyLabel: 'Easy',
            confidence: 0
        };
        
        // Run solver to get solution metrics
        const solution = this.solver.solve(puzzle);
        if (solution) {
            this.metrics.solutionComplexity = this.calculateSolutionComplexity(solution);
            this.metrics.minimumMoves = solution.moves.length;
            this.metrics.optimalPath = solution.moves;
        }
        
        // Calculate overall difficulty
        this.calculateOverallDifficulty();
        
        // Identify required skills
        this.identifyRequiredSkills(puzzle);
        
        // Estimate completion times
        this.estimateCompletionTimes();
        
        return this.metrics;
    }
    
    // Analyze grid complexity
    analyzeGridComplexity(grid) {
        if (!grid) return { score: 0, factors: [] };
        
        let score = 0;
        const factors = [];
        
        // Height of existing blocks
        const maxHeight = this.getMaxHeight(grid);
        score += maxHeight * 2;
        if (maxHeight > 10) factors.push('High starting blocks');
        
        // Number of holes
        const holes = this.countHoles(grid);
        score += holes * 5;
        if (holes > 3) factors.push(`${holes} holes to clear`);
        
        // Overhangs (blocks with empty space below)
        const overhangs = this.countOverhangs(grid);
        score += overhangs * 4;
        if (overhangs > 2) factors.push('Complex overhangs');
        
        // Wells (deep gaps)
        const wells = this.countWells(grid);
        score += wells * 6;
        if (wells > 0) factors.push(`${wells} well${wells > 1 ? 's' : ''}`);
        
        // Pattern complexity
        const patternScore = this.analyzePattern(grid);
        score += patternScore;
        if (patternScore > 20) factors.push('Complex pattern');
        
        // Accessibility (how easy to clear lines)
        const accessibility = this.analyzeAccessibility(grid);
        score += (100 - accessibility);
        if (accessibility < 50) factors.push('Difficult line access');
        
        return { score, factors };
    }
    
    // Analyze piece constraints
    analyzePieceConstraints(puzzle) {
        let score = 0;
        const factors = [];
        
        if (puzzle.pieces && puzzle.pieces !== 'random') {
            // Limited piece set
            const uniquePieces = new Set(puzzle.pieces).size;
            if (uniquePieces < 4) {
                score += 20;
                factors.push('Limited piece variety');
            }
            
            // Specific piece requirements
            if (puzzle.objective === 'tspin' && !puzzle.pieces.includes('T')) {
                score += 50;
                factors.push('T-Spin without T pieces!');
            }
            
            if (puzzle.objective === 'tetris' && !puzzle.pieces.includes('I')) {
                score += 40;
                factors.push('Tetris without I pieces!');
            }
        }
        
        // Piece limit constraints
        if (puzzle.maxPieces) {
            const efficiency = puzzle.maxPieces / (puzzle.targetLines || 1);
            if (efficiency < 3) {
                score += 30;
                factors.push('Very tight piece limit');
            } else if (efficiency < 5) {
                score += 15;
                factors.push('Tight piece limit');
            }
        }
        
        // Time constraints
        if (puzzle.timeLimit) {
            if (puzzle.timeLimit < 30) {
                score += 25;
                factors.push('Very short time limit');
            } else if (puzzle.timeLimit < 60) {
                score += 10;
                factors.push('Short time limit');
            }
        }
        
        return { score, factors };
    }
    
    // Analyze objective difficulty
    analyzeObjectiveDifficulty(puzzle) {
        let score = 0;
        const factors = [];
        
        const objectiveScores = {
            'clear': 10,
            'lines': 15,
            'score': 20,
            'tspin': 40,
            'tetris': 35,
            'combo': 30,
            'perfect': 50,
            'cascade': 35,
            'speed': 25,
            'norotation': 45,
            'chain': 40,
            'pattern': 30,
            'survival': 20
        };
        
        score = objectiveScores[puzzle.objective] || 15;
        
        // Adjust for target values
        if (puzzle.targetLines > 5) {
            score += (puzzle.targetLines - 5) * 2;
            factors.push(`Clear ${puzzle.targetLines} lines`);
        }
        
        if (puzzle.targetCombo > 5) {
            score += (puzzle.targetCombo - 5) * 5;
            factors.push(`${puzzle.targetCombo}x combo required`);
        }
        
        if (puzzle.targetTSpins > 1) {
            score += puzzle.targetTSpins * 15;
            factors.push(`${puzzle.targetTSpins} T-Spins required`);
        }
        
        return { score, factors };
    }
    
    // Calculate solution complexity
    calculateSolutionComplexity(solution) {
        if (!solution || !solution.moves) return 0;
        
        let complexity = 0;
        
        // Number of moves
        complexity += solution.moves.length * 2;
        
        // Rotation complexity
        const rotations = solution.moves.reduce((sum, move) => sum + move.rotation, 0);
        complexity += rotations * 1.5;
        
        // Placement precision (edges and corners)
        solution.moves.forEach(move => {
            if (move.column === 0 || move.column === 9) complexity += 2;
            if (move.row > 15) complexity += 3; // High placement
        });
        
        return complexity;
    }
    
    // Calculate overall difficulty
    calculateOverallDifficulty() {
        const gridScore = this.metrics.gridComplexity.score;
        const pieceScore = this.metrics.pieceConstraints.score;
        const objectiveScore = this.metrics.objectiveDifficulty.score;
        const solutionScore = this.metrics.solutionComplexity;
        
        const totalScore = gridScore + pieceScore + objectiveScore + solutionScore;
        
        // Determine difficulty level (1-5)
        if (totalScore < 30) {
            this.metrics.difficulty = 1;
            this.metrics.difficultyLabel = 'Easy';
        } else if (totalScore < 60) {
            this.metrics.difficulty = 2;
            this.metrics.difficultyLabel = 'Medium';
        } else if (totalScore < 100) {
            this.metrics.difficulty = 3;
            this.metrics.difficultyLabel = 'Hard';
        } else if (totalScore < 150) {
            this.metrics.difficulty = 4;
            this.metrics.difficultyLabel = 'Expert';
        } else {
            this.metrics.difficulty = 5;
            this.metrics.difficultyLabel = 'Master';
        }
        
        // Calculate confidence (0-100%)
        this.metrics.confidence = Math.min(100, 
            (this.metrics.optimalPath ? 50 : 0) +
            (gridScore > 0 ? 25 : 0) +
            (objectiveScore > 0 ? 25 : 0)
        );
    }
    
    // Identify required skills
    identifyRequiredSkills(puzzle) {
        const skills = [];
        const techniques = [];
        
        // Check objective requirements
        switch (puzzle.objective) {
            case 'tspin':
                skills.push('T-Spin Mastery');
                techniques.push('T-Spin Setup', '3-Corner Rule');
                break;
            case 'tetris':
                skills.push('Tetris Setup');
                techniques.push('Well Building', 'I-Piece Management');
                break;
            case 'combo':
                skills.push('Combo Building');
                techniques.push('Skimming', '4-Wide Strategy');
                break;
            case 'perfect':
                skills.push('Perfect Clear Knowledge');
                techniques.push('PC Patterns', 'Residue Management');
                break;
            case 'norotation':
                skills.push('Placement Precision');
                techniques.push('Column Selection', 'Drop Timing');
                break;
            case 'cascade':
                skills.push('Gravity Manipulation');
                techniques.push('Cascade Setup', 'Chain Reactions');
                break;
            case 'pattern':
                skills.push('Pattern Recognition');
                techniques.push('Shape Building', 'Symmetry');
                break;
        }
        
        // Check grid requirements
        if (this.metrics.gridComplexity.factors.includes('Complex overhangs')) {
            skills.push('Overhang Navigation');
            techniques.push('Tuck Unders', 'Slide Moves');
        }
        
        if (this.metrics.gridComplexity.factors.includes('wells')) {
            skills.push('Well Clearing');
            techniques.push('I-Piece Placement', 'Well Stacking');
        }
        
        // Check constraints
        if (puzzle.maxPieces && puzzle.maxPieces < 10) {
            skills.push('Efficiency Optimization');
            techniques.push('Minimal Moves', 'Multi-Line Clears');
        }
        
        if (puzzle.timeLimit && puzzle.timeLimit < 60) {
            skills.push('Speed Execution');
            techniques.push('Finesse', 'Quick Decision Making');
        }
        
        this.metrics.skillsRequired = skills;
        this.metrics.techniques = techniques;
    }
    
    // Estimate completion times
    estimateCompletionTimes() {
        const baseTime = this.metrics.minimumMoves * 2; // 2 seconds per move base
        
        // Adjust for difficulty
        const difficultyMultipliers = {
            1: { beginner: 3, intermediate: 1.5, expert: 1 },
            2: { beginner: 4, intermediate: 2, expert: 1.2 },
            3: { beginner: 6, intermediate: 3, expert: 1.5 },
            4: { beginner: 10, intermediate: 5, expert: 2 },
            5: { beginner: 15, intermediate: 8, expert: 3 }
        };
        
        const multipliers = difficultyMultipliers[this.metrics.difficulty];
        
        this.metrics.estimatedTime = {
            beginner: Math.round(baseTime * multipliers.beginner),
            intermediate: Math.round(baseTime * multipliers.intermediate),
            expert: Math.round(baseTime * multipliers.expert)
        };
    }
    
    // Helper functions
    getMaxHeight(grid) {
        for (let row = 0; row < 20; row++) {
            if (grid[row].some(cell => cell !== 0)) {
                return 20 - row;
            }
        }
        return 0;
    }
    
    countHoles(grid) {
        let holes = 0;
        for (let col = 0; col < 10; col++) {
            let blockFound = false;
            for (let row = 0; row < 20; row++) {
                if (grid[row][col] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        return holes;
    }
    
    countOverhangs(grid) {
        let overhangs = 0;
        for (let row = 0; row < 19; row++) {
            for (let col = 0; col < 10; col++) {
                if (grid[row][col] !== 0 && grid[row + 1][col] === 0) {
                    // Check if there's any block below in the column
                    for (let checkRow = row + 2; checkRow < 20; checkRow++) {
                        if (grid[checkRow][col] !== 0) {
                            overhangs++;
                            break;
                        }
                    }
                }
            }
        }
        return overhangs;
    }
    
    countWells(grid) {
        let wells = 0;
        for (let col = 1; col < 9; col++) {
            let wellDepth = 0;
            for (let row = 0; row < 20; row++) {
                if (grid[row][col] === 0 && 
                    grid[row][col - 1] !== 0 && 
                    grid[row][col + 1] !== 0) {
                    wellDepth++;
                } else {
                    if (wellDepth >= 3) wells++;
                    wellDepth = 0;
                }
            }
            if (wellDepth >= 3) wells++;
        }
        return wells;
    }
    
    analyzePattern(grid) {
        let score = 0;
        let transitions = 0;
        
        // Count transitions (changes from empty to filled)
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 9; col++) {
                if ((grid[row][col] === 0) !== (grid[row][col + 1] === 0)) {
                    transitions++;
                }
            }
        }
        
        score = transitions * 2;
        return score;
    }
    
    analyzeAccessibility(grid) {
        // Percentage of how easy it is to clear lines
        let accessible = 0;
        let total = 0;
        
        for (let row = 0; row < 20; row++) {
            const filled = grid[row].filter(cell => cell !== 0).length;
            if (filled > 0) {
                total++;
                if (filled >= 7) accessible++; // Nearly complete lines
            }
        }
        
        return total > 0 ? (accessible / total) * 100 : 100;
    }
    
    // Generate difficulty report
    generateReport() {
        return {
            overall: {
                difficulty: this.metrics.difficulty,
                label: this.metrics.difficultyLabel,
                confidence: `${this.metrics.confidence}%`
            },
            breakdown: {
                grid: this.metrics.gridComplexity,
                pieces: this.metrics.pieceConstraints,
                objective: this.metrics.objectiveDifficulty
            },
            solution: {
                minimumMoves: this.metrics.minimumMoves,
                complexity: this.metrics.solutionComplexity,
                hasOptimalPath: !!this.metrics.optimalPath
            },
            requirements: {
                skills: this.metrics.skillsRequired,
                techniques: this.metrics.techniques
            },
            timeEstimates: this.metrics.estimatedTime,
            factors: [
                ...this.metrics.gridComplexity.factors,
                ...this.metrics.pieceConstraints.factors,
                ...this.metrics.objectiveDifficulty.factors
            ]
        };
    }
}
})();

/* scripts/puzzles/puzzleVerificationSuite.js */
(function() {
// Comprehensive Puzzle Verification Suite




window.PuzzleVerificationSuite = class PuzzleVerificationSuite {
    constructor() {
        this.solver = new PuzzleAutoSolver();
        this.analyzer = new PuzzleDifficultyAnalyzer();
        this.results = [];
        this.impossiblePuzzles = [];
        this.fixes = {};
    }
    
    // Verify all puzzles
    async verifyAllPuzzles() {
        console.log(' Starting comprehensive puzzle verification...');
        
        this.results = [];
        this.impossiblePuzzles = [];
        this.fixes = {};
        
        for (let i = 0; i < PUZZLES.length; i++) {
            const puzzle = PUZZLES[i];
            const result = await this.verifyPuzzle(puzzle);
            
            this.results.push(result);
            
            if (!result.solvable) {
                this.impossiblePuzzles.push(puzzle.id);
                
                // Attempt to fix
                const fix = this.generateFix(puzzle, result);
                if (fix) {
                    this.fixes[puzzle.id] = fix;
                }
            }
            
            // Progress update
            if ((i + 1) % 10 === 0) {
                console.log(`Verified ${i + 1}/${PUZZLES.length} puzzles...`);
            }
        }
        
        // Generate report
        const report = this.generateReport();
        
        // Save verification results
        await this.saveResults(report);
        
        return report;
    }
    
    // Verify single puzzle
    async verifyPuzzle(puzzle) {
        const startTime = Date.now();
        
        const result = {
            id: puzzle.id,
            name: puzzle.name,
            solvable: false,
            solution: null,
            difficulty: null,
            issues: [],
            warnings: [],
            time: 0
        };
        
        try {
            // Basic validation
            const validationIssues = this.validatePuzzleStructure(puzzle);
            result.issues.push(...validationIssues);
            
            // Convert puzzle to proper format
            const puzzleConfig = this.normalizePuzzle(puzzle);
            
            // Attempt to solve
            const solution = this.solver.solve(puzzleConfig);
            
            if (solution && solution.success) {
                result.solvable = true;
                result.solution = solution;
                
                // Analyze difficulty
                const analysis = this.analyzer.analyze(puzzleConfig);
                result.difficulty = analysis;
                
                // Check for warnings
                result.warnings = this.checkForWarnings(puzzle, solution, analysis);
            } else {
                result.solvable = false;
                result.issues.push('No solution found');
                
                // Detailed failure analysis
                const failureReasons = this.analyzeFailure(puzzle);
                result.issues.push(...failureReasons);
            }
            
        } catch (error) {
            result.issues.push(`Error during verification: ${error.message}`);
        }
        
        result.time = Date.now() - startTime;
        
        return result;
    }
    
    // Validate puzzle structure
    validatePuzzleStructure(puzzle) {
        const issues = [];
        
        // Check required fields
        if (!puzzle.id) issues.push('Missing puzzle ID');
        if (!puzzle.name) issues.push('Missing puzzle name');
        if (!puzzle.objective) issues.push('Missing objective');
        
        // Validate grid
        if (puzzle.initialGrid) {
            if (puzzle.initialGrid.length !== 20) {
                issues.push(`Invalid grid height: ${puzzle.initialGrid.length} (should be 20)`);
            } else if (puzzle.initialGrid[0].length !== 10) {
                issues.push(`Invalid grid width: ${puzzle.initialGrid[0].length} (should be 10)`);
            }
            
            // Check for invalid values
            for (let row = 0; row < puzzle.initialGrid.length; row++) {
                for (let col = 0; col < puzzle.initialGrid[row].length; col++) {
                    const value = puzzle.initialGrid[row][col];
                    if (value < 0 || value > 7) {
                        issues.push(`Invalid grid value at [${row},${col}]: ${value}`);
                    }
                }
            }
        }
        
        // Validate pieces
        if (puzzle.pieces && puzzle.pieces !== 'random') {
            const validPieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            for (const piece of puzzle.pieces) {
                if (!validPieces.includes(piece)) {
                    issues.push(`Invalid piece type: ${piece}`);
                }
            }
            
            // Check piece count vs requirements
            if (puzzle.maxPieces && puzzle.pieces.length < puzzle.maxPieces) {
                issues.push(`Not enough pieces: ${puzzle.pieces.length} < ${puzzle.maxPieces}`);
            }
        }
        
        // Validate objective requirements
        const objectiveIssues = this.validateObjective(puzzle);
        issues.push(...objectiveIssues);
        
        return issues;
    }
    
    // Validate objective feasibility
    validateObjective(puzzle) {
        const issues = [];
        
        switch (puzzle.objective) {
            case 'clear':
            case 'lines':
                if (puzzle.targetLines) {
                    const maxPossibleLines = this.calculateMaxPossibleLines(puzzle);
                    if (puzzle.targetLines > maxPossibleLines) {
                        issues.push(`Target lines (${puzzle.targetLines}) exceeds maximum possible (${maxPossibleLines})`);
                    }
                }
                break;
                
            case 'tspin':
                if (puzzle.targetTSpins && puzzle.pieces !== 'random') {
                    const tPieces = puzzle.pieces.filter(p => p === 'T').length;
                    if (tPieces < puzzle.targetTSpins) {
                        issues.push(`Not enough T pieces (${tPieces}) for target T-spins (${puzzle.targetTSpins})`);
                    }
                }
                break;
                
            case 'tetris':
                if (puzzle.targetTetris && puzzle.pieces !== 'random') {
                    const iPieces = puzzle.pieces.filter(p => p === 'I').length;
                    if (iPieces < puzzle.targetTetris) {
                        issues.push(`Not enough I pieces (${iPieces}) for target Tetris (${puzzle.targetTetris})`);
                    }
                }
                break;
                
            case 'perfect':
            case 'perfectclear':
                // Check if grid has correct number of blocks for perfect clear
                const blockCount = this.countBlocks(puzzle.initialGrid);
                if (blockCount % 4 !== 0) {
                    issues.push(`Grid has ${blockCount} blocks - not divisible by 4 for perfect clear`);
                }
                break;
        }
        
        return issues;
    }
    
    // Normalize puzzle to standard format
    normalizePuzzle(puzzle) {
        return {
            id: puzzle.id,
            name: puzzle.name,
            grid: puzzle.initialGrid || this.createEmptyGrid(),
            pieces: puzzle.pieces === 'random' ? null : puzzle.pieces,
            maxPieces: puzzle.maxPieces || 999,
            objective: {
                type: puzzle.objective,
                targetLines: puzzle.targetLines,
                targetScore: puzzle.minScore,
                targetTSpins: puzzle.targetTSpins,
                targetTetris: puzzle.targetTetris,
                targetCombo: puzzle.targetCombo
            },
            timeLimit: puzzle.timeLimit
        };
    }
    
    // Analyze why puzzle failed
    analyzeFailure(puzzle) {
        const reasons = [];
        
        // Check piece-objective mismatch
        if (puzzle.objective === 'tspin' && puzzle.pieces) {
            if (!puzzle.pieces.includes('T')) {
                reasons.push('T-spin objective without T pieces');
            }
        }
        
        if (puzzle.objective === 'tetris' && puzzle.pieces) {
            if (!puzzle.pieces.includes('I')) {
                reasons.push('Tetris objective without I pieces');
            }
        }
        
        // Check if pieces are insufficient
        if (puzzle.maxPieces) {
            const minRequired = this.calculateMinimumPieces(puzzle);
            if (puzzle.maxPieces < minRequired) {
                reasons.push(`Piece limit (${puzzle.maxPieces}) below minimum required (${minRequired})`);
            }
        }
        
        // Check for impossible grid configurations
        const gridIssues = this.checkGridFeasibility(puzzle.initialGrid);
        reasons.push(...gridIssues);
        
        return reasons;
    }
    
    // Check for warnings (puzzle works but has issues)
    checkForWarnings(puzzle, solution, analysis) {
        const warnings = [];
        
        // Difficulty warnings
        if (analysis.difficulty >= 4) {
            warnings.push(`Very high difficulty (${analysis.difficultyLabel})`);
        }
        
        // Efficiency warnings
        if (solution.moves.length > puzzle.maxPieces * 0.9) {
            warnings.push('Solution uses nearly all available pieces');
        }
        
        // Objective warnings
        if (puzzle.objective === 'perfect' && solution.linesCleared < 4) {
            warnings.push('Perfect clear with very few lines');
        }
        
        // Time warnings
        if (puzzle.timeLimit && analysis.estimatedTime) {
            if (analysis.estimatedTime.beginner > puzzle.timeLimit * 1000) {
                warnings.push('Time limit may be too strict for beginners');
            }
        }
        
        return warnings;
    }
    
    // Generate fix for impossible puzzle
    generateFix(puzzle, verificationResult) {
        const fix = {
            original: { ...puzzle },
            changes: [],
            fixed: { ...puzzle }
        };
        
        // Fix based on issues
        for (const issue of verificationResult.issues) {
            if (issue.includes('Not enough T pieces')) {
                // Add more T pieces
                const needed = puzzle.targetTSpins || 1;
                const current = puzzle.pieces.filter(p => p === 'T').length;
                for (let i = current; i < needed + 2; i++) {
                    fix.fixed.pieces.push('T');
                }
                fix.changes.push(`Added ${needed + 2 - current} T pieces`);
            }
            
            if (issue.includes('Not enough I pieces')) {
                // Add more I pieces
                const needed = puzzle.targetTetris || 1;
                const current = puzzle.pieces.filter(p => p === 'I').length;
                for (let i = current; i < needed + 1; i++) {
                    fix.fixed.pieces.push('I');
                }
                fix.changes.push(`Added ${needed + 1 - current} I pieces`);
            }
            
            if (issue.includes('Piece limit') && issue.includes('below minimum')) {
                // Increase piece limit
                const minRequired = this.calculateMinimumPieces(puzzle);
                fix.fixed.maxPieces = minRequired + 5;
                fix.changes.push(`Increased piece limit from ${puzzle.maxPieces} to ${fix.fixed.maxPieces}`);
            }
            
            if (issue.includes('Target lines') && issue.includes('exceeds maximum')) {
                // Reduce target lines
                const maxPossible = this.calculateMaxPossibleLines(puzzle);
                fix.fixed.targetLines = Math.max(1, maxPossible - 1);
                fix.changes.push(`Reduced target lines from ${puzzle.targetLines} to ${fix.fixed.targetLines}`);
            }
            
            if (issue.includes('not divisible by 4')) {
                // Adjust grid for perfect clear
                const blockCount = this.countBlocks(puzzle.initialGrid);
                const toRemove = blockCount % 4;
                fix.fixed.initialGrid = this.removeBlocks(puzzle.initialGrid, toRemove);
                fix.changes.push(`Removed ${toRemove} blocks for perfect clear compatibility`);
            }
        }
        
        // If no specific fixes, try general improvements
        if (fix.changes.length === 0) {
            if (puzzle.maxPieces && puzzle.maxPieces < 10) {
                fix.fixed.maxPieces = 15;
                fix.changes.push('Increased piece limit for better solvability');
            }
            
            if (puzzle.pieces && puzzle.pieces.length < 7) {
                fix.fixed.pieces = [...puzzle.pieces, 'I', 'T', 'O'];
                fix.changes.push('Added variety pieces for flexibility');
            }
        }
        
        return fix.changes.length > 0 ? fix : null;
    }
    
    // Helper functions
    calculateMaxPossibleLines(puzzle) {
        if (!puzzle.initialGrid) return 20;
        
        let maxLines = 0;
        for (let row = 0; row < 20; row++) {
            const filled = puzzle.initialGrid[row].filter(cell => cell !== 0).length;
            if (filled >= 7) { // Could potentially complete this line
                maxLines++;
            }
        }
        
        // Add potential from pieces
        if (puzzle.maxPieces) {
            maxLines += Math.floor(puzzle.maxPieces * 4 / 10); // Average 4 blocks per piece
        }
        
        return Math.min(20, maxLines);
    }
    
    calculateMinimumPieces(puzzle) {
        let minPieces = 0;
        
        switch (puzzle.objective) {
            case 'clear':
            case 'lines':
                // Minimum 2.5 pieces per line average
                minPieces = Math.ceil((puzzle.targetLines || 1) * 2.5);
                break;
                
            case 'tetris':
                // Need I pieces plus setup
                minPieces = (puzzle.targetTetris || 1) + 6;
                break;
                
            case 'tspin':
                // Need T pieces plus setup
                minPieces = (puzzle.targetTSpins || 1) * 3 + 4;
                break;
                
            case 'perfect':
                // Need exact pieces for clearing
                const blocks = this.countBlocks(puzzle.initialGrid);
                minPieces = Math.ceil(blocks / 4) + 2;
                break;
                
            default:
                minPieces = 5;
        }
        
        return minPieces;
    }
    
    checkGridFeasibility(grid) {
        const issues = [];
        
        if (!grid) return issues;
        
        // Check for completely blocked rows at top
        for (let row = 0; row < 4; row++) {
            if (grid[row].every(cell => cell !== 0)) {
                issues.push(`Row ${row} is completely filled at top - likely impossible`);
            }
        }
        
        // Check for isolated single blocks
        let isolatedBlocks = 0;
        for (let row = 1; row < 19; row++) {
            for (let col = 1; col < 9; col++) {
                if (grid[row][col] !== 0 &&
                    grid[row-1][col] === 0 && grid[row+1][col] === 0 &&
                    grid[row][col-1] === 0 && grid[row][col+1] === 0) {
                    isolatedBlocks++;
                }
            }
        }
        
        if (isolatedBlocks > 3) {
            issues.push(`${isolatedBlocks} isolated blocks make clearing very difficult`);
        }
        
        // Check for unreachable areas
        const unreachable = this.findUnreachableAreas(grid);
        if (unreachable > 0) {
            issues.push(`${unreachable} unreachable cells detected`);
        }
        
        return issues;
    }
    
    findUnreachableAreas(grid) {
        // Simplified check for cells that can't be reached by pieces
        let unreachable = 0;
        
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (grid[row][col] === 0) {
                    // Check if surrounded by blocks on 3+ sides
                    let surroundedSides = 0;
                    
                    if (row > 0 && grid[row-1][col] !== 0) surroundedSides++;
                    if (row < 19 && grid[row+1][col] !== 0) surroundedSides++;
                    if (col > 0 && grid[row][col-1] !== 0) surroundedSides++;
                    if (col < 9 && grid[row][col+1] !== 0) surroundedSides++;
                    
                    if (surroundedSides >= 3) {
                        unreachable++;
                    }
                }
            }
        }
        
        return unreachable;
    }
    
    countBlocks(grid) {
        if (!grid) return 0;
        
        let count = 0;
        for (let row = 0; row < grid.length; row++) {
            for (let col = 0; col < grid[row].length; col++) {
                if (grid[row][col] !== 0) count++;
            }
        }
        return count;
    }
    
    removeBlocks(grid, count) {
        const newGrid = grid.map(row => [...row]);
        let removed = 0;
        
        // Remove from top rows first
        for (let row = 0; row < 20 && removed < count; row++) {
            for (let col = 0; col < 10 && removed < count; col++) {
                if (newGrid[row][col] !== 0) {
                    newGrid[row][col] = 0;
                    removed++;
                }
            }
        }
        
        return newGrid;
    }
    
    createEmptyGrid() {
        return Array(20).fill(null).map(() => Array(10).fill(0));
    }
    
    // Generate comprehensive report
    generateReport() {
        const totalPuzzles = this.results.length;
        const solvablePuzzles = this.results.filter(r => r.solvable).length;
        const impossiblePuzzles = this.results.filter(r => !r.solvable).length;
        
        // Difficulty distribution
        const difficultyDist = {
            1: 0, 2: 0, 3: 0, 4: 0, 5: 0
        };
        
        this.results.forEach(r => {
            if (r.difficulty) {
                difficultyDist[r.difficulty.difficulty]++;
            }
        });
        
        // Issues summary
        const allIssues = {};
        this.results.forEach(r => {
            r.issues.forEach(issue => {
                allIssues[issue] = (allIssues[issue] || 0) + 1;
            });
        });
        
        return {
            summary: {
                total: totalPuzzles,
                solvable: solvablePuzzles,
                impossible: impossiblePuzzles,
                successRate: `${((solvablePuzzles / totalPuzzles) * 100).toFixed(1)}%`
            },
            difficulty: difficultyDist,
            impossiblePuzzles: this.impossiblePuzzles,
            commonIssues: Object.entries(allIssues)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10),
            fixes: this.fixes,
            verificationTime: `${this.results.reduce((sum, r) => sum + r.time, 0)}ms`,
            timestamp: new Date().toISOString()
        };
    }
    
    // Save verification results
    async saveResults(report) {
        await storage.save('puzzle_verification_results', {
            report: report,
            results: this.results,
            fixes: this.fixes,
            timestamp: Date.now()
        });
        
        console.log(' Verification results saved');
    }
    
    // Apply fixes to puzzle data
    async applyFixes() {
        const fixedPuzzles = [];
        
        for (const [puzzleId, fix] of Object.entries(this.fixes)) {
            const puzzleIndex = PUZZLES.findIndex(p => p.id === parseInt(puzzleId));
            if (puzzleIndex >= 0) {
                // Apply fix
                Object.assign(PUZZLES[puzzleIndex], fix.fixed);
                fixedPuzzles.push(puzzleId);
                
                console.log(` Fixed puzzle ${puzzleId}: ${fix.changes.join(', ')}`);
            }
        }
        
        console.log(`Applied ${fixedPuzzles.length} fixes`);
        
        return fixedPuzzles;
    }
}

// Export singleton instance
window.puzzleVerifier = const puzzleVerifier = new PuzzleVerificationSuite();
})();

/* scripts/powerups/powerUpTypes.js */
(function() {
// Power-Up Types and Definitions
window.POWER_UP_TYPES = const POWER_UP_TYPES = {
    SLOW_TIME: {
        id: 'slow_time',
        name: 'Slow Time',
        icon: '',
        color: '#00ffff',
        duration: 10000, // 10 seconds
        description: 'Slows down piece falling speed by 50%',
        rarity: 'common',
        effect: (game) => {
            game.dropInterval *= 2; // Double the drop interval (slower)
        },
        cleanup: (game) => {
            game.dropInterval /= 2; // Restore original speed
        }
    },
    
    LINE_BOMB: {
        id: 'line_bomb',
        name: 'Line Bomb',
        icon: '',
        color: '#ff4444',
        duration: 0, // Instant use
        description: 'Instantly clears the bottom line',
        rarity: 'uncommon',
        effect: (game) => {
            if (game.grid) {
                // Clear the bottom line
                for (let x = 0; x < game.grid.width; x++) {
                    game.grid.cells[game.grid.height - 1][x] = 0;
                }
                // Collapse grid
                game.grid.collapseEmptySpaces();
                game.score += 100;
                
                // Play explosion sound
                if (game.audioManager) {
                    game.audioManager.playSFX('explosion');
                }
            }
        },
        cleanup: null
    },
    
    GHOST_MODE: {
        id: 'ghost_mode',
        name: 'Ghost Mode',
        icon: '',
        color: '#9966ff',
        duration: 5000, // 5 seconds
        description: 'Pieces can pass through blocks',
        rarity: 'rare',
        effect: (game) => {
            game.ghostModeActive = true;
        },
        cleanup: (game) => {
            game.ghostModeActive = false;
        }
    },
    
    LIGHTNING: {
        id: 'lightning',
        name: 'Lightning Clear',
        icon: '',
        color: '#ffff00',
        duration: 0, // Instant
        description: 'Clears all isolated single blocks',
        rarity: 'uncommon',
        effect: (game) => {
            if (game.grid) {
                let blocksCleared = 0;
                for (let y = 0; y < game.grid.height; y++) {
                    for (let x = 0; x < game.grid.width; x++) {
                        if (game.grid.cells[y][x] !== 0) {
                            // Check if block is isolated (no neighbors)
                            const neighbors = [
                                [y-1, x], [y+1, x], [y, x-1], [y, x+1]
                            ];
                            let isolated = true;
                            for (const [ny, nx] of neighbors) {
                                if (ny >= 0 && ny < game.grid.height && 
                                    nx >= 0 && nx < game.grid.width &&
                                    game.grid.cells[ny][nx] !== 0) {
                                    isolated = false;
                                    break;
                                }
                            }
                            if (isolated) {
                                game.grid.cells[y][x] = 0;
                                blocksCleared++;
                            }
                        }
                    }
                }
                game.score += blocksCleared * 20;
            }
        },
        cleanup: null
    },
    
    PRECISION: {
        id: 'precision',
        name: 'Precision View',
        icon: '',
        color: '#00ff00',
        duration: 15000, // 15 seconds
        description: 'Shows 5 next pieces instead of 3',
        rarity: 'common',
        effect: (game) => {
            game.extendedPreview = true;
            // Add 2 more pieces to preview
            if (game.nextPieces && game.pieceBag) {
                while (game.nextPieces.length < 5) {
                    game.nextPieces.push(game.pieceBag.getNextPiece().type);
                }
            }
        },
        cleanup: (game) => {
            game.extendedPreview = false;
            // Restore to 3 pieces
            if (game.nextPieces) {
                game.nextPieces = game.nextPieces.slice(0, 3);
            }
        }
    },
    
    DOUBLE_SCORE: {
        id: 'double_score',
        name: '2x Score',
        icon: '',
        color: '#ffd700',
        duration: 10000, // 10 seconds
        description: 'Doubles all points earned',
        rarity: 'common',
        effect: (game) => {
            game.scoreMultiplier = (game.scoreMultiplier || 1) * 2;
        },
        cleanup: (game) => {
            game.scoreMultiplier = (game.scoreMultiplier || 2) / 2;
        }
    },
    
    SHUFFLE: {
        id: 'shuffle',
        name: 'Grid Shuffle',
        icon: '',
        color: '#ff9900',
        duration: 0, // Instant
        description: 'Randomly reorganizes existing blocks',
        rarity: 'rare',
        effect: (game) => {
            if (game.grid) {
                // Collect all non-empty blocks
                const blocks = [];
                for (let y = 0; y < game.grid.height; y++) {
                    for (let x = 0; x < game.grid.width; x++) {
                        if (game.grid.cells[y][x] !== 0) {
                            blocks.push(game.grid.cells[y][x]);
                            game.grid.cells[y][x] = 0;
                        }
                    }
                }
                
                // Randomly redistribute blocks from bottom
                let blockIndex = 0;
                for (let y = game.grid.height - 1; y >= 0 && blockIndex < blocks.length; y--) {
                    for (let x = 0; x < game.grid.width && blockIndex < blocks.length; x++) {
                        if (Math.random() > 0.3) { // 70% chance to place
                            game.grid.cells[y][x] = blocks[blockIndex++];
                        }
                    }
                }
            }
        },
        cleanup: null
    },
    
    MAGNET: {
        id: 'magnet',
        name: 'Magnet Mode',
        icon: '',
        color: '#ff00ff',
        duration: 8000, // 8 seconds
        description: 'Auto-attracts pieces to fill gaps',
        rarity: 'uncommon',
        effect: (game) => {
            game.magnetMode = true;
        },
        cleanup: (game) => {
            game.magnetMode = false;
        }
    }
};

// Power-up generation chances based on accomplishments
window.POWER_UP_CHANCES = const POWER_UP_CHANCES = {
    tetris: 1.0,        // 100% chance
    tspin: 0.5,         // 50% chance
    combo5: 0.75,       // 75% chance
    combo10: 1.0,       // 100% chance
    perfectClear: 2.0,  // 200% chance (2 power-ups)
    lines10: 0.3,       // 30% chance
    lines20: 0.6,       // 60% chance
    score1000: 0.25,    // 25% chance
    score5000: 0.5      // 50% chance
};

// Get random power-up based on rarity
window.getRandomPowerUp = function getRandomPowerUp() {
    const powerUps = Object.values(POWER_UP_TYPES);
    const weights = {
        common: 50,
        uncommon: 30,
        rare: 20
    };
    
    // Calculate total weight
    let totalWeight = 0;
    for (const powerUp of powerUps) {
        totalWeight += weights[powerUp.rarity];
    }
    
    // Random selection
    let random = Math.random() * totalWeight;
    for (const powerUp of powerUps) {
        random -= weights[powerUp.rarity];
        if (random <= 0) {
            return powerUp;
        }
    }
    
    // Fallback
    return powerUps[0];
}

// Check if accomplishment should generate power-up
window.shouldGeneratePowerUp = function shouldGeneratePowerUp(accomplishment) {
    const chance = POWER_UP_CHANCES[accomplishment] || 0;
    return Math.random() < chance;
}

// Get multiple power-ups for special accomplishments
window.getPowerUpCount = function getPowerUpCount(accomplishment) {
    const chance = POWER_UP_CHANCES[accomplishment] || 0;
    return Math.floor(chance);
}
})();

/* scripts/powerups/powerUpManager.js */
(function() {
// Power-Up Manager - Handles power-up logic and state

window.PowerUpManager = class PowerUpManager {
    constructor(game) {
        this.game = game;
        this.slots = [null, null]; // Max 2 power-ups
        this.activePowerUps = []; // Currently active power-ups with timers
        this.accomplishmentQueue = [];
        this.lastAccomplishment = null;
        this.particleEffects = [];
    }
    
    // Initialize the manager
    initialize() {
        this.slots = [null, null];
        this.activePowerUps = [];
        this.accomplishmentQueue = [];
        this.lastAccomplishment = null;
        this.particleEffects = [];
    }
    
    // Update active power-ups (called each frame)
    update(deltaTime) {
        // Update active power-up timers
        for (let i = this.activePowerUps.length - 1; i >= 0; i--) {
            const active = this.activePowerUps[i];
            if (active.duration > 0) {
                active.timeRemaining -= deltaTime;
                
                // Update UI timer
                this.updatePowerUpTimer(active);
                
                if (active.timeRemaining <= 0) {
                    // Power-up expired, cleanup
                    this.deactivatePowerUp(i);
                }
            }
        }
        
        // Process accomplishment queue
        this.processAccomplishments();
        
        // Update particle effects
        this.updateParticles(deltaTime);
    }
    
    // Register an accomplishment
    registerAccomplishment(type, value = 1) {
        this.accomplishmentQueue.push({ type, value, timestamp: Date.now() });
    }
    
    // Process accomplishments and generate power-ups
    processAccomplishments() {
        while (this.accomplishmentQueue.length > 0) {
            const accomplishment = this.accomplishmentQueue.shift();
            
            // Check if we should generate power-up
            if (shouldGeneratePowerUp(accomplishment.type)) {
                const count = getPowerUpCount(accomplishment.type) || 1;
                
                for (let i = 0; i < count; i++) {
                    this.generatePowerUp();
                }
            }
        }
    }
    
    // Generate a new power-up
    generatePowerUp() {
        const powerUp = getRandomPowerUp();
        
        // Try to add to an empty slot
        for (let i = 0; i < this.slots.length; i++) {
            if (!this.slots[i]) {
                this.slots[i] = {
                    ...powerUp,
                    slotIndex: i,
                    generated: Date.now()
                };
                
                // Show notification
                this.showPowerUpNotification(powerUp);
                
                // Update UI
                this.updateSlotDisplay(i);
                
                // Play sound
                if (this.game.audioManager) {
                    this.game.audioManager.playSFX('powerup_collect');
                }
                
                return true;
            }
        }
        
        // All slots full - replace oldest
        const oldestSlot = this.slots[0].generated < this.slots[1].generated ? 0 : 1;
        this.slots[oldestSlot] = {
            ...powerUp,
            slotIndex: oldestSlot,
            generated: Date.now()
        };
        
        this.showPowerUpNotification(powerUp);
        this.updateSlotDisplay(oldestSlot);
        
        return true;
    }
    
    // Activate a power-up from slot
    activatePowerUp(slotIndex) {
        if (slotIndex < 0 || slotIndex >= this.slots.length) return false;
        
        const powerUp = this.slots[slotIndex];
        if (!powerUp) return false;
        
        // Clear the slot
        this.slots[slotIndex] = null;
        this.updateSlotDisplay(slotIndex);
        
        // Apply effect
        if (powerUp.effect) {
            powerUp.effect(this.game);
        }
        
        // If it has duration, add to active list
        if (powerUp.duration > 0) {
            this.activePowerUps.push({
                ...powerUp,
                timeRemaining: powerUp.duration,
                startTime: Date.now()
            });
            
            // Update active display
            this.updateActivePowerUpsDisplay();
        }
        
        // Create visual effect
        this.createActivationEffect(powerUp);
        
        // Play activation sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('powerup_activate');
        }
        
        return true;
    }
    
    // Deactivate expired power-up
    deactivatePowerUp(index) {
        const active = this.activePowerUps[index];
        
        // Run cleanup if exists
        if (active.cleanup) {
            active.cleanup(this.game);
        }
        
        // Remove from active list
        this.activePowerUps.splice(index, 1);
        
        // Update display
        this.updateActivePowerUpsDisplay();
        
        // Play deactivation sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('powerup_expire');
        }
    }
    
    // UI Update Methods
    updateSlotDisplay(slotIndex) {
        const slotElement = document.getElementById(`powerup-slot-${slotIndex}`);
        if (!slotElement) return;
        
        const powerUp = this.slots[slotIndex];
        
        if (powerUp) {
            slotElement.innerHTML = `
                <div class="powerup-icon">${powerUp.icon}</div>
                <div class="powerup-name">${powerUp.name}</div>
            `;
            slotElement.style.background = `linear-gradient(135deg, ${powerUp.color}33, ${powerUp.color}11)`;
            slotElement.style.border = `2px solid ${powerUp.color}`;
            slotElement.classList.add('filled');
        } else {
            slotElement.innerHTML = `
                <div class="powerup-empty">Empty</div>
            `;
            slotElement.style.background = 'rgba(255, 255, 255, 0.05)';
            slotElement.style.border = '2px solid rgba(255, 255, 255, 0.2)';
            slotElement.classList.remove('filled');
        }
    }
    
    updateActivePowerUpsDisplay() {
        const container = document.getElementById('active-powerups');
        if (!container) return;
        
        container.innerHTML = '';
        
        this.activePowerUps.forEach(active => {
            const element = document.createElement('div');
            element.className = 'active-powerup';
            element.style.borderColor = active.color;
            
            const progress = active.timeRemaining / active.duration;
            
            element.innerHTML = `
                <div class="active-powerup-icon">${active.icon}</div>
                <div class="active-powerup-timer">
                    <div class="timer-fill" style="width: ${progress * 100}%; background: ${active.color}"></div>
                </div>
            `;
            
            container.appendChild(element);
        });
    }
    
    updatePowerUpTimer(active) {
        // This is called frequently, so we just trigger display update
        // The actual timer display is handled in updateActivePowerUpsDisplay
    }
    
    showPowerUpNotification(powerUp) {
        const notification = document.createElement('div');
        notification.className = 'powerup-notification';
        notification.style.color = powerUp.color;
        notification.innerHTML = `
            <span class="notification-icon">${powerUp.icon}</span>
            <span class="notification-text">Power-Up Collected: ${powerUp.name}</span>
        `;
        
        document.body.appendChild(notification);
        
        // Animate and remove
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 500);
        }, 2000);
    }
    
    createActivationEffect(powerUp) {
        // Create particle burst effect at game canvas center
        const canvas = this.game.canvas;
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Create particles
        for (let i = 0; i < 20; i++) {
            const particle = {
                x: centerX,
                y: centerY,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                color: powerUp.color,
                life: 1000,
                size: Math.random() * 4 + 2
            };
            this.particleEffects.push(particle);
        }
    }
    
    updateParticles(deltaTime) {
        // Update and render particles (would need canvas overlay for full effect)
        for (let i = this.particleEffects.length - 1; i >= 0; i--) {
            const particle = this.particleEffects[i];
            particle.life -= deltaTime;
            
            if (particle.life <= 0) {
                this.particleEffects.splice(i, 1);
            } else {
                particle.x += particle.vx * deltaTime / 100;
                particle.y += particle.vy * deltaTime / 100;
                particle.vy += 0.5; // Gravity
            }
        }
    }
    
    // Check for specific accomplishments during gameplay
    checkAccomplishments(event, data) {
        switch (event) {
            case 'lines_cleared':
                if (data.count === 4) {
                    this.registerAccomplishment('tetris');
                }
                if (data.total >= 10 && data.total % 10 === 0) {
                    this.registerAccomplishment('lines10');
                }
                if (data.total >= 20 && data.total % 20 === 0) {
                    this.registerAccomplishment('lines20');
                }
                break;
                
            case 'tspin':
                this.registerAccomplishment('tspin');
                break;
                
            case 'combo':
                if (data >= 5) {
                    this.registerAccomplishment('combo5');
                }
                if (data >= 10) {
                    this.registerAccomplishment('combo10');
                }
                break;
                
            case 'perfect_clear':
                this.registerAccomplishment('perfectClear');
                break;
                
            case 'score':
                if (data >= 1000 && data < 1100) {
                    this.registerAccomplishment('score1000');
                }
                if (data >= 5000 && data < 5100) {
                    this.registerAccomplishment('score5000');
                }
                break;
        }
    }
    
    // Get current state for saving
    getState() {
        return {
            slots: this.slots,
            activePowerUps: this.activePowerUps.map(p => ({
                ...p,
                timeRemaining: p.timeRemaining
            }))
        };
    }
    
    // Restore from saved state
    loadState(state) {
        if (state.slots) {
            this.slots = state.slots;
            this.slots.forEach((slot, i) => {
                if (slot) {
                    this.updateSlotDisplay(i);
                }
            });
        }
        
        if (state.activePowerUps) {
            this.activePowerUps = state.activePowerUps;
            this.updateActivePowerUpsDisplay();
        }
    }
}
})();

/* scripts/progression/playerProgression.js */
(function() {
// Global Player Progression System

window.PlayerProgression = class PlayerProgression {
    constructor() {
        this.level = 1;
        this.xp = 0;
        this.totalXP = 0;
        this.rank = 'Novice';
        this.stats = {
            gamesPlayed: 0,
            totalScore: 0,
            totalLines: 0,
            totalTime: 0,
            favoriteMode: null,
            achievements: [],
            trophies: [],
            puzzlesCompleted: 0,
            dailyChallengesCompleted: 0,
            highestCombo: 0,
            totalTSpins: 0,
            totalTetris: 0,
            perfectClears: 0
        };
        this.unlocks = {
            themes: ['default'],
            music: ['classic'],
            backgrounds: ['space'],
            pieceStyles: ['neon'],
            effects: ['basic']
        };
        this.badges = [];
        this.loadProgress();
    }
    
    async loadProgress() {
        const saved = await storage.load('player_progression');
        if (saved) {
            Object.assign(this, saved);
        }
    }
    
    async saveProgress() {
        await storage.save('player_progression', {
            level: this.level,
            xp: this.xp,
            totalXP: this.totalXP,
            rank: this.rank,
            stats: this.stats,
            unlocks: this.unlocks,
            badges: this.badges
        });
    }
    
    addXP(amount, source = 'gameplay') {
        this.xp += amount;
        this.totalXP += amount;
        
        // Check for level up
        const requiredXP = this.getRequiredXP();
        while (this.xp >= requiredXP) {
            this.levelUp();
        }
        
        // Update rank
        this.updateRank();
        
        // Save progress
        this.saveProgress();
        
        return {
            xpGained: amount,
            currentXP: this.xp,
            level: this.level,
            rank: this.rank,
            source: source
        };
    }
    
    getRequiredXP() {
        // XP required for next level (exponential curve)
        return Math.floor(100 * Math.pow(1.5, this.level - 1));
    }
    
    levelUp() {
        const requiredXP = this.getRequiredXP();
        this.xp -= requiredXP;
        this.level++;
        
        // Check for unlocks
        const newUnlocks = this.checkUnlocks();
        
        // Trigger level up event
        this.onLevelUp(newUnlocks);
        
        return {
            newLevel: this.level,
            unlocks: newUnlocks
        };
    }
    
    updateRank() {
        const ranks = [
            { level: 1, name: 'Novice' },
            { level: 5, name: 'Apprentice' },
            { level: 10, name: 'Adept' },
            { level: 20, name: 'Expert' },
            { level: 30, name: 'Master' },
            { level: 40, name: 'Grandmaster' },
            { level: 50, name: 'Champion' },
            { level: 60, name: 'Legend' },
            { level: 75, name: 'Mythic' },
            { level: 100, name: 'Eternal' }
        ];
        
        for (let i = ranks.length - 1; i >= 0; i--) {
            if (this.level >= ranks[i].level) {
                this.rank = ranks[i].name;
                break;
            }
        }
    }
    
    checkUnlocks() {
        const unlocks = [];
        
        // Theme unlocks
        const themeUnlocks = [
            { level: 5, theme: 'cyberpunk', name: 'Cyberpunk Theme' },
            { level: 10, theme: 'retro', name: 'Retro Theme' },
            { level: 15, theme: 'nature', name: 'Nature Theme' },
            { level: 20, theme: 'minimal', name: 'Minimal Theme' },
            { level: 30, theme: 'galaxy', name: 'Galaxy Theme' },
            { level: 40, theme: 'matrix', name: 'Matrix Theme' },
            { level: 50, theme: 'rainbow', name: 'Rainbow Theme' }
        ];
        
        themeUnlocks.forEach(unlock => {
            if (this.level === unlock.level && !this.unlocks.themes.includes(unlock.theme)) {
                this.unlocks.themes.push(unlock.theme);
                unlocks.push({ type: 'theme', id: unlock.theme, name: unlock.name });
            }
        });
        
        // Music unlocks
        const musicUnlocks = [
            { level: 3, track: 'chiptune', name: 'Chiptune Music' },
            { level: 8, track: 'synthwave', name: 'Synthwave Music' },
            { level: 12, track: 'orchestral', name: 'Orchestral Music' },
            { level: 18, track: 'jazz', name: 'Jazz Remix' },
            { level: 25, track: 'metal', name: 'Metal Version' },
            { level: 35, track: 'lofi', name: 'Lo-Fi Beats' }
        ];
        
        musicUnlocks.forEach(unlock => {
            if (this.level === unlock.level && !this.unlocks.music.includes(unlock.track)) {
                this.unlocks.music.push(unlock.track);
                unlocks.push({ type: 'music', id: unlock.track, name: unlock.name });
            }
        });
        
        // Piece style unlocks
        const pieceUnlocks = [
            { level: 7, style: 'glass', name: 'Glass Pieces' },
            { level: 14, style: 'pixel', name: 'Pixel Art Pieces' },
            { level: 22, style: 'hologram', name: 'Hologram Pieces' },
            { level: 28, style: 'crystal', name: 'Crystal Pieces' },
            { level: 45, style: 'animated', name: 'Animated Pieces' }
        ];
        
        pieceUnlocks.forEach(unlock => {
            if (this.level === unlock.level && !this.unlocks.pieceStyles.includes(unlock.style)) {
                this.unlocks.pieceStyles.push(unlock.style);
                unlocks.push({ type: 'pieceStyle', id: unlock.style, name: unlock.name });
            }
        });
        
        // Effect unlocks
        const effectUnlocks = [
            { level: 6, effect: 'particles', name: 'Particle Effects' },
            { level: 11, effect: 'trails', name: 'Piece Trails' },
            { level: 16, effect: 'explosions', name: 'Line Clear Explosions' },
            { level: 24, effect: 'lightning', name: 'Lightning Effects' },
            { level: 32, effect: 'shatter', name: 'Shatter Effects' },
            { level: 55, effect: 'quantum', name: 'Quantum Effects' }
        ];
        
        effectUnlocks.forEach(unlock => {
            if (this.level === unlock.level && !this.unlocks.effects.includes(unlock.effect)) {
                this.unlocks.effects.push(unlock.effect);
                unlocks.push({ type: 'effect', id: unlock.effect, name: unlock.name });
            }
        });
        
        return unlocks;
    }
    
    onLevelUp(unlocks) {
        // Create level up notification
        const notification = {
            type: 'levelUp',
            level: this.level,
            rank: this.rank,
            unlocks: unlocks,
            timestamp: Date.now()
        };
        
        // Dispatch event
        window.dispatchEvent(new CustomEvent('playerLevelUp', { detail: notification }));
        
        // Show UI notification
        if (window.game && window.game.uiManager) {
            window.game.uiManager.showLevelUp(this.level, this.rank, unlocks);
        }
    }
    
    updateStats(gameResults) {
        this.stats.gamesPlayed++;
        this.stats.totalScore += gameResults.score || 0;
        this.stats.totalLines += gameResults.lines || 0;
        this.stats.totalTime += gameResults.time || 0;
        
        if (gameResults.combo > this.stats.highestCombo) {
            this.stats.highestCombo = gameResults.combo;
        }
        
        this.stats.totalTSpins += gameResults.tspins || 0;
        this.stats.totalTetris += gameResults.tetris || 0;
        
        if (gameResults.perfectClear) {
            this.stats.perfectClears++;
        }
        
        // Update favorite mode
        if (gameResults.mode) {
            if (!this.stats.modeCount) {
                this.stats.modeCount = {};
            }
            this.stats.modeCount[gameResults.mode] = (this.stats.modeCount[gameResults.mode] || 0) + 1;
            
            // Find most played mode
            let maxCount = 0;
            let favoriteMode = null;
            for (const [mode, count] of Object.entries(this.stats.modeCount)) {
                if (count > maxCount) {
                    maxCount = count;
                    favoriteMode = mode;
                }
            }
            this.stats.favoriteMode = favoriteMode;
        }
        
        this.saveProgress();
    }
    
    calculateGameXP(gameResults) {
        let xp = 0;
        
        // Base XP from score
        xp += Math.floor(gameResults.score / 100);
        
        // Lines cleared
        xp += gameResults.lines * 10;
        
        // Special moves
        xp += gameResults.tspins * 50;
        xp += gameResults.tetris * 30;
        xp += gameResults.perfectClears * 100;
        
        // Combo bonus
        if (gameResults.combo >= 10) xp += 100;
        if (gameResults.combo >= 20) xp += 200;
        
        // Mode multipliers
        const modeMultipliers = {
            classic: 1.0,
            sprint: 1.2,
            marathon: 1.5,
            puzzle: 1.3,
            battle: 1.4,
            powerup: 1.1,
            zen: 0.8
        };
        
        const multiplier = modeMultipliers[gameResults.mode] || 1.0;
        xp = Math.floor(xp * multiplier);
        
        // First win of the day bonus
        if (this.isFirstWinOfDay()) {
            xp *= 2;
        }
        
        return xp;
    }
    
    isFirstWinOfDay() {
        const today = new Date().toISOString().split('T')[0];
        const lastWin = this.stats.lastWinDate;
        
        if (lastWin !== today) {
            this.stats.lastWinDate = today;
            return true;
        }
        return false;
    }
    
    addBadge(badge) {
        if (!this.badges.find(b => b.id === badge.id)) {
            this.badges.push({
                ...badge,
                unlockedAt: Date.now()
            });
            this.saveProgress();
            return true;
        }
        return false;
    }
    
    getProgressToNextLevel() {
        const required = this.getRequiredXP();
        return {
            current: this.xp,
            required: required,
            percentage: Math.floor((this.xp / required) * 100)
        };
    }
    
    getPlayerCard() {
        return {
            name: this.getPlayerName(),
            level: this.level,
            rank: this.rank,
            totalXP: this.totalXP,
            badges: this.badges.length,
            stats: {
                games: this.stats.gamesPlayed,
                avgScore: Math.floor(this.stats.totalScore / Math.max(1, this.stats.gamesPlayed)),
                favoriteMode: this.stats.favoriteMode,
                achievements: this.stats.achievements.length
            },
            unlocks: {
                themes: this.unlocks.themes.length,
                music: this.unlocks.music.length,
                effects: this.unlocks.effects.length
            }
        };
    }
    
    getPlayerName() {
        // Get from settings or use default
        return localStorage.getItem('tetris_player_name') || 'Player';
    }
    
    reset() {
        this.level = 1;
        this.xp = 0;
        this.totalXP = 0;
        this.rank = 'Novice';
        this.stats = {
            gamesPlayed: 0,
            totalScore: 0,
            totalLines: 0,
            totalTime: 0,
            favoriteMode: null,
            achievements: [],
            trophies: [],
            puzzlesCompleted: 0,
            dailyChallengesCompleted: 0,
            highestCombo: 0,
            totalTSpins: 0,
            totalTetris: 0,
            perfectClears: 0
        };
        this.unlocks = {
            themes: ['default'],
            music: ['classic'],
            backgrounds: ['space'],
            pieceStyles: ['neon'],
            effects: ['basic']
        };
        this.badges = [];
        this.saveProgress();
    }
}

window.playerProgression = const playerProgression = new PlayerProgression();
})();

/* scripts/achievements/achievementSystem.js */
(function() {
// Achievement and Trophy System


window.ACHIEVEMENTS = const ACHIEVEMENTS = {
    // Beginner Achievements
    FIRST_LINE: {
        id: 'first_line',
        name: 'First Step',
        description: 'Clear your first line',
        icon: '',
        xp: 10,
        category: 'beginner'
    },
    FIRST_TETRIS: {
        id: 'first_tetris',
        name: 'Tetris!',
        description: 'Clear 4 lines at once',
        icon: '',
        xp: 50,
        category: 'beginner'
    },
    FIRST_TSPIN: {
        id: 'first_tspin',
        name: 'Spin Master',
        description: 'Perform your first T-Spin',
        icon: '',
        xp: 100,
        category: 'beginner'
    },
    
    // Line Clearing Achievements
    LINES_100: {
        id: 'lines_100',
        name: 'Century',
        description: 'Clear 100 lines total',
        icon: '',
        xp: 100,
        category: 'lines'
    },
    LINES_1000: {
        id: 'lines_1000',
        name: 'Millennium',
        description: 'Clear 1000 lines total',
        icon: '',
        xp: 500,
        category: 'lines'
    },
    LINES_10000: {
        id: 'lines_10000',
        name: 'Line Legend',
        description: 'Clear 10000 lines total',
        icon: '',
        xp: 2000,
        category: 'lines'
    },
    
    // Score Achievements
    SCORE_10K: {
        id: 'score_10k',
        name: 'Five Figures',
        description: 'Score 10,000 points in a single game',
        icon: '',
        xp: 50,
        category: 'score'
    },
    SCORE_100K: {
        id: 'score_100k',
        name: 'High Scorer',
        description: 'Score 100,000 points in a single game',
        icon: '',
        xp: 200,
        category: 'score'
    },
    SCORE_1M: {
        id: 'score_1m',
        name: 'Millionaire',
        description: 'Score 1,000,000 points in a single game',
        icon: '',
        xp: 1000,
        category: 'score'
    },
    
    // Combo Achievements
    COMBO_5: {
        id: 'combo_5',
        name: 'Combo Starter',
        description: 'Achieve a 5x combo',
        icon: '',
        xp: 30,
        category: 'combo'
    },
    COMBO_10: {
        id: 'combo_10',
        name: 'Combo Expert',
        description: 'Achieve a 10x combo',
        icon: '',
        xp: 100,
        category: 'combo'
    },
    COMBO_20: {
        id: 'combo_20',
        name: 'Combo God',
        description: 'Achieve a 20x combo',
        icon: '',
        xp: 500,
        category: 'combo'
    },
    
    // Perfect Clear Achievements
    PERFECT_CLEAR: {
        id: 'perfect_clear',
        name: 'Perfectionist',
        description: 'Clear the entire board',
        icon: '',
        xp: 200,
        category: 'special'
    },
    PERFECT_CLEAR_5: {
        id: 'perfect_clear_5',
        name: 'Perfect Practice',
        description: 'Achieve 5 perfect clears total',
        icon: '',
        xp: 500,
        category: 'special'
    },
    
    // T-Spin Achievements
    TSPIN_DOUBLE: {
        id: 'tspin_double',
        name: 'Double Spin',
        description: 'Perform a T-Spin Double',
        icon: '',
        xp: 150,
        category: 'special'
    },
    TSPIN_TRIPLE: {
        id: 'tspin_triple',
        name: 'Triple Threat',
        description: 'Perform a T-Spin Triple',
        icon: '',
        xp: 300,
        category: 'special'
    },
    TSPIN_MASTER: {
        id: 'tspin_master',
        name: 'Spin Doctor',
        description: 'Perform 100 T-Spins total',
        icon: '',
        xp: 1000,
        category: 'special'
    },
    
    // Mode-Specific Achievements
    SPRINT_SUB60: {
        id: 'sprint_sub60',
        name: 'Speed Demon',
        description: 'Complete Sprint mode in under 60 seconds',
        icon: '',
        xp: 300,
        category: 'modes'
    },
    MARATHON_COMPLETE: {
        id: 'marathon_complete',
        name: 'Marathon Runner',
        description: 'Complete Marathon mode (150 lines)',
        icon: '',
        xp: 500,
        category: 'modes'
    },
    PUZZLE_50: {
        id: 'puzzle_50',
        name: 'Puzzle Solver',
        description: 'Complete 50 puzzles',
        icon: '',
        xp: 400,
        category: 'modes'
    },
    PUZZLE_ALL: {
        id: 'puzzle_all',
        name: 'Puzzle Master',
        description: 'Complete all 150 puzzles',
        icon: '',
        xp: 2000,
        category: 'modes'
    },
    BATTLE_WIN_10: {
        id: 'battle_win_10',
        name: 'Battle Veteran',
        description: 'Win 10 Battle mode games',
        icon: '',
        xp: 300,
        category: 'modes'
    },
    
    // Daily Challenge Achievements
    DAILY_STREAK_3: {
        id: 'daily_streak_3',
        name: 'Consistent',
        description: '3-day daily challenge streak',
        icon: '',
        xp: 100,
        category: 'daily'
    },
    DAILY_STREAK_7: {
        id: 'daily_streak_7',
        name: 'Dedicated',
        description: '7-day daily challenge streak',
        icon: '',
        xp: 300,
        category: 'daily'
    },
    DAILY_STREAK_30: {
        id: 'daily_streak_30',
        name: 'Devotee',
        description: '30-day daily challenge streak',
        icon: '',
        xp: 1000,
        category: 'daily'
    },
    
    // Secret Achievements
    ONLY_I_PIECES: {
        id: 'only_i_pieces',
        name: 'Straight Shooter',
        description: 'Score 10,000 points using only I-pieces',
        icon: '',
        xp: 500,
        category: 'secret',
        hidden: true
    },
    NO_ROTATION: {
        id: 'no_rotation',
        name: 'No Spin Zone',
        description: 'Clear 20 lines without rotating any piece',
        icon: '',
        xp: 400,
        category: 'secret',
        hidden: true
    },
    SPEED_DEMON: {
        id: 'speed_demon',
        name: 'Lightning Fast',
        description: 'Place 100 pieces in 60 seconds',
        icon: '',
        xp: 300,
        category: 'secret',
        hidden: true
    }
};

window.TROPHIES = const TROPHIES = {
    // Bronze Trophies
    BEGINNER: {
        id: 'beginner',
        name: 'Tetris Beginner',
        description: 'Unlock 5 achievements',
        tier: 'bronze',
        icon: '',
        xp: 200,
        requirement: { type: 'achievements', count: 5 }
    },
    LEVEL_10: {
        id: 'level_10',
        name: 'Rising Star',
        description: 'Reach level 10',
        tier: 'bronze',
        icon: '',
        xp: 300,
        requirement: { type: 'level', value: 10 }
    },
    
    // Silver Trophies
    INTERMEDIATE: {
        id: 'intermediate',
        name: 'Tetris Intermediate',
        description: 'Unlock 20 achievements',
        tier: 'silver',
        icon: '',
        xp: 500,
        requirement: { type: 'achievements', count: 20 }
    },
    LEVEL_25: {
        id: 'level_25',
        name: 'Experienced Player',
        description: 'Reach level 25',
        tier: 'silver',
        icon: '',
        xp: 750,
        requirement: { type: 'level', value: 25 }
    },
    ALL_MODES: {
        id: 'all_modes',
        name: 'Mode Master',
        description: 'Play all game modes at least once',
        tier: 'silver',
        icon: '',
        xp: 600,
        requirement: { type: 'modes', all: true }
    },
    
    // Gold Trophies
    EXPERT: {
        id: 'expert',
        name: 'Tetris Expert',
        description: 'Unlock 50 achievements',
        tier: 'gold',
        icon: '',
        xp: 1000,
        requirement: { type: 'achievements', count: 50 }
    },
    LEVEL_50: {
        id: 'level_50',
        name: 'Tetris Champion',
        description: 'Reach level 50',
        tier: 'gold',
        icon: '',
        xp: 1500,
        requirement: { type: 'level', value: 50 }
    },
    PERFECT_PUZZLES: {
        id: 'perfect_puzzles',
        name: 'Puzzle Perfectionist',
        description: '3-star all puzzles',
        tier: 'gold',
        icon: '',
        xp: 2000,
        requirement: { type: 'puzzles', perfect: true }
    },
    
    // Platinum Trophies
    COMPLETIONIST: {
        id: 'completionist',
        name: 'Completionist',
        description: 'Unlock all achievements',
        tier: 'platinum',
        icon: '',
        xp: 5000,
        requirement: { type: 'achievements', all: true }
    },
    LEVEL_100: {
        id: 'level_100',
        name: 'Tetris Legend',
        description: 'Reach level 100',
        tier: 'platinum',
        icon: '',
        xp: 10000,
        requirement: { type: 'level', value: 100 }
    }
};

window.AchievementSystem = class AchievementSystem {
    constructor() {
        this.unlockedAchievements = [];
        this.unlockedTrophies = [];
        this.progress = {};
        this.notifications = [];
        this.loadProgress();
    }
    
    async loadProgress() {
        const saved = await storage.load('achievements');
        if (saved) {
            this.unlockedAchievements = saved.achievements || [];
            this.unlockedTrophies = saved.trophies || [];
            this.progress = saved.progress || {};
        }
    }
    
    async saveProgress() {
        await storage.save('achievements', {
            achievements: this.unlockedAchievements,
            trophies: this.unlockedTrophies,
            progress: this.progress
        });
    }
    
    checkAchievement(achievementId, condition) {
        const achievement = ACHIEVEMENTS[achievementId];
        if (!achievement) return false;
        
        // Check if already unlocked
        if (this.unlockedAchievements.includes(achievementId)) {
            return false;
        }
        
        // Check condition
        if (condition) {
            this.unlockAchievement(achievementId);
            return true;
        }
        
        return false;
    }
    
    unlockAchievement(achievementId) {
        const achievement = ACHIEVEMENTS[achievementId];
        if (!achievement || this.unlockedAchievements.includes(achievementId)) {
            return false;
        }
        
        // Add to unlocked list
        this.unlockedAchievements.push(achievementId);
        
        // Award XP
        if (playerProgression) {
            playerProgression.addXP(achievement.xp, 'achievement');
        }
        
        // Create notification
        this.createNotification({
            type: 'achievement',
            title: 'Achievement Unlocked!',
            name: achievement.name,
            description: achievement.description,
            icon: achievement.icon,
            xp: achievement.xp
        });
        
        // Check for trophy unlocks
        this.checkTrophies();
        
        // Save progress
        this.saveProgress();
        
        return true;
    }
    
    checkTrophies() {
        for (const [trophyId, trophy] of Object.entries(TROPHIES)) {
            if (this.unlockedTrophies.includes(trophyId)) continue;
            
            let unlocked = false;
            
            switch (trophy.requirement.type) {
                case 'achievements':
                    if (trophy.requirement.all) {
                        unlocked = this.unlockedAchievements.length === Object.keys(ACHIEVEMENTS).length;
                    } else {
                        unlocked = this.unlockedAchievements.length >= trophy.requirement.count;
                    }
                    break;
                    
                case 'level':
                    unlocked = playerProgression.level >= trophy.requirement.value;
                    break;
                    
                case 'modes':
                    if (trophy.requirement.all) {
                        const modes = ['classic', 'sprint', 'marathon', 'puzzle', 'battle', 'zen', 'powerup'];
                        unlocked = modes.every(mode => 
                            playerProgression.stats.modeCount && 
                            playerProgression.stats.modeCount[mode] > 0
                        );
                    }
                    break;
                    
                case 'puzzles':
                    if (trophy.requirement.perfect) {
                        // Check if all puzzles completed with 3 stars
                        // This would need puzzle completion data
                        unlocked = false; // Implement based on puzzle data
                    }
                    break;
            }
            
            if (unlocked) {
                this.unlockTrophy(trophyId);
            }
        }
    }
    
    unlockTrophy(trophyId) {
        const trophy = TROPHIES[trophyId];
        if (!trophy || this.unlockedTrophies.includes(trophyId)) {
            return false;
        }
        
        // Add to unlocked list
        this.unlockedTrophies.push(trophyId);
        
        // Award XP
        if (playerProgression) {
            playerProgression.addXP(trophy.xp, 'trophy');
        }
        
        // Create notification
        this.createNotification({
            type: 'trophy',
            title: 'Trophy Earned!',
            name: trophy.name,
            description: trophy.description,
            icon: trophy.icon,
            tier: trophy.tier,
            xp: trophy.xp
        });
        
        // Save progress
        this.saveProgress();
        
        return true;
    }
    
    updateProgress(key, value, increment = false) {
        if (increment) {
            this.progress[key] = (this.progress[key] || 0) + value;
        } else {
            this.progress[key] = value;
        }
        
        // Check related achievements
        this.checkProgressAchievements(key);
    }
    
    checkProgressAchievements(key) {
        const value = this.progress[key];
        
        switch (key) {
            case 'totalLines':
                this.checkAchievement('LINES_100', value >= 100);
                this.checkAchievement('LINES_1000', value >= 1000);
                this.checkAchievement('LINES_10000', value >= 10000);
                break;
                
            case 'highScore':
                this.checkAchievement('SCORE_10K', value >= 10000);
                this.checkAchievement('SCORE_100K', value >= 100000);
                this.checkAchievement('SCORE_1M', value >= 1000000);
                break;
                
            case 'maxCombo':
                this.checkAchievement('COMBO_5', value >= 5);
                this.checkAchievement('COMBO_10', value >= 10);
                this.checkAchievement('COMBO_20', value >= 20);
                break;
                
            case 'tspins':
                this.checkAchievement('FIRST_TSPIN', value >= 1);
                this.checkAchievement('TSPIN_MASTER', value >= 100);
                break;
                
            case 'perfectClears':
                this.checkAchievement('PERFECT_CLEAR', value >= 1);
                this.checkAchievement('PERFECT_CLEAR_5', value >= 5);
                break;
                
            case 'puzzlesCompleted':
                this.checkAchievement('PUZZLE_50', value >= 50);
                this.checkAchievement('PUZZLE_ALL', value >= 150);
                break;
                
            case 'dailyStreak':
                this.checkAchievement('DAILY_STREAK_3', value >= 3);
                this.checkAchievement('DAILY_STREAK_7', value >= 7);
                this.checkAchievement('DAILY_STREAK_30', value >= 30);
                break;
        }
    }
    
    createNotification(data) {
        const notification = {
            ...data,
            id: Date.now(),
            timestamp: Date.now()
        };
        
        this.notifications.push(notification);
        
        // Dispatch event for UI
        window.dispatchEvent(new CustomEvent('achievementUnlocked', { 
            detail: notification 
        }));
        
        // Show UI notification if available
        if (window.game && window.game.uiManager) {
            window.game.uiManager.showAchievement(notification);
        }
    }
    
    getProgress() {
        const totalAchievements = Object.keys(ACHIEVEMENTS).length;
        const totalTrophies = Object.keys(TROPHIES).length;
        
        return {
            achievements: {
                unlocked: this.unlockedAchievements.length,
                total: totalAchievements,
                percentage: Math.floor((this.unlockedAchievements.length / totalAchievements) * 100)
            },
            trophies: {
                unlocked: this.unlockedTrophies.length,
                total: totalTrophies,
                percentage: Math.floor((this.unlockedTrophies.length / totalTrophies) * 100)
            },
            recentUnlocks: this.notifications.slice(-5)
        };
    }
    
    getUnlockedDetails() {
        return {
            achievements: this.unlockedAchievements.map(id => ({
                ...ACHIEVEMENTS[id],
                unlockedAt: this.progress[`${id}_time`] || null
            })),
            trophies: this.unlockedTrophies.map(id => ({
                ...TROPHIES[id],
                unlockedAt: this.progress[`${id}_time`] || null
            }))
        };
    }
    
    reset() {
        this.unlockedAchievements = [];
        this.unlockedTrophies = [];
        this.progress = {};
        this.notifications = [];
        this.saveProgress();
    }
}

window.achievementSystem = const achievementSystem = new AchievementSystem();
})();

/* scripts/challenges/dailyChallenge.js */
(function() {
// Daily Challenge System


window.DailyChallenge = class DailyChallenge {
    constructor() {
        this.currentChallenge = null;
        this.challengeHistory = [];
        this.streak = 0;
        this.lastPlayedDate = null;
        this.todaysSeed = null;
        this.loadProgress();
    }
    
    async loadProgress() {
        const saved = await storage.load('daily_challenge_progress');
        if (saved) {
            this.challengeHistory = saved.history || [];
            this.streak = saved.streak || 0;
            this.lastPlayedDate = saved.lastPlayedDate;
        }
    }
    
    async saveProgress() {
        await storage.save('daily_challenge_progress', {
            history: this.challengeHistory,
            streak: this.streak,
            lastPlayedDate: this.lastPlayedDate
        });
    }
    
    getDailySeed() {
        // Generate consistent seed for the day
        const today = new Date();
        const dateString = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;
        return this.hashCode(dateString);
    }
    
    hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
    }
    
    getTodaysChallenge() {
        const seed = this.getDailySeed();
        
        // Check if we already have today's challenge
        if (this.todaysSeed === seed && this.currentChallenge) {
            return this.currentChallenge;
        }
        
        this.todaysSeed = seed;
        
        // Generate challenge based on seed
        const rng = this.seededRandom(seed);
        
        // Pick a random puzzle as base
        const basePuzzle = PUZZLES[Math.floor(rng() * PUZZLES.length)];
        
        // Generate modifiers
        const modifiers = this.generateModifiers(rng);
        
        // Create challenge configuration
        this.currentChallenge = {
            id: `daily_${seed}`,
            name: this.generateChallengeName(rng),
            basePuzzle: basePuzzle.id,
            date: new Date().toISOString().split('T')[0],
            seed: seed,
            
            // Challenge parameters
            objective: this.selectObjective(rng),
            difficulty: this.calculateDifficulty(rng),
            modifiers: modifiers,
            
            // Rewards
            baseXP: 500,
            bonusXP: modifiers.length * 100,
            streakBonus: this.streak * 50,
            
            // Constraints
            timeLimit: this.generateTimeLimit(rng),
            maxPieces: this.generatePieceLimit(rng),
            
            // Special rules
            specialRules: this.generateSpecialRules(rng),
            
            // Leaderboard
            leaderboardEnabled: true,
            globalStats: {
                attempts: 0,
                completions: 0,
                averageTime: 0,
                bestTime: null,
                topPlayers: []
            }
        };
        
        return this.currentChallenge;
    }
    
    seededRandom(seed) {
        // Seeded random number generator
        let s = seed;
        return function() {
            s = (s * 9301 + 49297) % 233280;
            return s / 233280;
        };
    }
    
    generateModifiers(rng) {
        const allModifiers = [
            {
                id: 'invisible',
                name: 'Invisible Pieces',
                description: 'Pieces become invisible after placement',
                effect: 'invisible_grid',
                difficulty: 3
            },
            {
                id: 'speed_increase',
                name: 'Accelerating Speed',
                description: 'Speed increases every 10 seconds',
                effect: 'speed_ramp',
                difficulty: 2
            },
            {
                id: 'limited_hold',
                name: 'No Hold',
                description: 'Hold feature is disabled',
                effect: 'no_hold',
                difficulty: 2
            },
            {
                id: 'mirror',
                name: 'Mirror Mode',
                description: 'Controls are reversed',
                effect: 'mirror_controls',
                difficulty: 3
            },
            {
                id: 'earthquake',
                name: 'Earthquake',
                description: 'Grid shakes periodically',
                effect: 'shake',
                difficulty: 2
            },
            {
                id: 'fog',
                name: 'Fog of War',
                description: 'Only see bottom 10 rows',
                effect: 'fog',
                difficulty: 2
            },
            {
                id: 'giant',
                name: 'Giant Pieces',
                description: 'All pieces are 2x size',
                effect: 'giant_pieces',
                difficulty: 3
            },
            {
                id: 'tiny',
                name: 'Tiny Grid',
                description: 'Grid is only 6 columns wide',
                effect: 'tiny_grid',
                difficulty: 2
            },
            {
                id: 'rotation_lock',
                name: 'Rotation Lock',
                description: 'Can only rotate clockwise',
                effect: 'clockwise_only',
                difficulty: 1
            },
            {
                id: 'color_blind',
                name: 'Monochrome',
                description: 'All pieces are the same color',
                effect: 'monochrome',
                difficulty: 2
            }
        ];
        
        // Select 1-3 modifiers based on day
        const numModifiers = Math.floor(rng() * 3) + 1;
        const selected = [];
        const available = [...allModifiers];
        
        for (let i = 0; i < numModifiers && available.length > 0; i++) {
            const index = Math.floor(rng() * available.length);
            selected.push(available[index]);
            available.splice(index, 1);
        }
        
        return selected;
    }
    
    selectObjective(rng) {
        const objectives = [
            { type: 'lines', target: 10 + Math.floor(rng() * 20) },
            { type: 'score', target: 5000 + Math.floor(rng() * 10000) },
            { type: 'combo', target: 5 + Math.floor(rng() * 5) },
            { type: 'tetris', target: 2 + Math.floor(rng() * 3) },
            { type: 'tspin', target: 1 + Math.floor(rng() * 2) },
            { type: 'perfect', target: 1 },
            { type: 'cascade', target: 3 + Math.floor(rng() * 2) },
            { type: 'speed', timeLimit: 60 + Math.floor(rng() * 60) },
            { type: 'survival', duration: 120 + Math.floor(rng() * 60) },
            { type: 'pattern', pattern: ['pyramid', 'checkerboard', 'stairs'][Math.floor(rng() * 3)] }
        ];
        
        return objectives[Math.floor(rng() * objectives.length)];
    }
    
    generateTimeLimit(rng) {
        // 0 means no limit, otherwise 1-5 minutes
        const hasLimit = rng() > 0.5;
        return hasLimit ? (60 + Math.floor(rng() * 240)) : 0;
    }
    
    generatePieceLimit(rng) {
        // 0 means no limit, otherwise 20-100 pieces
        const hasLimit = rng() > 0.6;
        return hasLimit ? (20 + Math.floor(rng() * 80)) : 0;
    }
    
    generateSpecialRules(rng) {
        const rules = [];
        
        if (rng() > 0.8) {
            rules.push({
                id: 'no_line_clear',
                name: 'Pacifist',
                description: 'Complete without clearing lines'
            });
        }
        
        if (rng() > 0.9) {
            rules.push({
                id: 'all_pieces_once',
                name: 'One of Each',
                description: 'Use each piece type exactly once'
            });
        }
        
        if (rng() > 0.7) {
            rules.push({
                id: 'increasing_speed',
                name: 'Escalation',
                description: 'Speed increases with each piece'
            });
        }
        
        return rules;
    }
    
    calculateDifficulty(rng) {
        // Calculate overall difficulty based on modifiers and objectives
        let difficulty = 1;
        
        // Add base randomness
        difficulty += Math.floor(rng() * 3);
        
        // Cap at 5
        return Math.min(5, Math.max(1, difficulty));
    }
    
    generateChallengeName(rng) {
        const adjectives = [
            'Extreme', 'Ultimate', 'Legendary', 'Epic', 'Mystical',
            'Quantum', 'Cosmic', 'Stellar', 'Infernal', 'Celestial',
            'Ancient', 'Forbidden', 'Sacred', 'Chaotic', 'Harmonious'
        ];
        
        const nouns = [
            'Challenge', 'Trial', 'Gauntlet', 'Ordeal', 'Quest',
            'Mission', 'Journey', 'Expedition', 'Crusade', 'Odyssey'
        ];
        
        const adj = adjectives[Math.floor(rng() * adjectives.length)];
        const noun = nouns[Math.floor(rng() * nouns.length)];
        
        return `${adj} ${noun}`;
    }
    
    async completeChallenge(stats) {
        const today = new Date().toISOString().split('T')[0];
        
        // Check if already completed today
        if (this.lastPlayedDate === today) {
            return {
                alreadyCompleted: true,
                message: 'Daily challenge already completed!'
            };
        }
        
        // Update streak
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayString = yesterday.toISOString().split('T')[0];
        
        if (this.lastPlayedDate === yesterdayString) {
            this.streak++;
        } else {
            this.streak = 1;
        }
        
        // Calculate rewards
        const challenge = this.currentChallenge;
        let totalXP = challenge.baseXP;
        
        // Add bonus XP for modifiers
        totalXP += challenge.bonusXP;
        
        // Add streak bonus
        totalXP += challenge.streakBonus;
        
        // Add performance bonus
        if (stats.time < challenge.timeLimit / 2) {
            totalXP += 200; // Speed bonus
        }
        if (stats.perfectClear) {
            totalXP += 300; // Perfect clear bonus
        }
        
        // Record completion
        const completion = {
            date: today,
            challengeId: challenge.id,
            challengeName: challenge.name,
            stats: stats,
            xpEarned: totalXP,
            streak: this.streak,
            time: stats.time,
            score: stats.score
        };
        
        this.challengeHistory.push(completion);
        this.lastPlayedDate = today;
        
        // Save progress
        await this.saveProgress();
        
        // Submit to global leaderboard
        await this.submitToLeaderboard(completion);
        
        return {
            success: true,
            xpEarned: totalXP,
            streak: this.streak,
            rank: await this.getPlayerRank(stats.score),
            nextChallenge: this.getTimeUntilNextChallenge()
        };
    }
    
    async submitToLeaderboard(completion) {
        // Submit score to global daily leaderboard
        try {
            const response = await fetch('/api/daily-challenge.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'submit',
                    challengeId: completion.challengeId,
                    score: completion.score,
                    time: completion.time,
                    stats: completion.stats
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                return data.rank;
            }
        } catch (error) {
            console.error('Failed to submit to leaderboard:', error);
        }
        return null;
    }
    
    async getPlayerRank(score) {
        // Get player's rank in today's challenge
        try {
            const response = await fetch('/api/daily-challenge.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'getRank',
                    challengeId: this.currentChallenge.id,
                    score: score
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                return data.rank;
            }
        } catch (error) {
            console.error('Failed to get rank:', error);
        }
        return null;
    }
    
    getTimeUntilNextChallenge() {
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);
        
        const msUntilTomorrow = tomorrow - now;
        const hours = Math.floor(msUntilTomorrow / (1000 * 60 * 60));
        const minutes = Math.floor((msUntilTomorrow % (1000 * 60 * 60)) / (1000 * 60));
        
        return { hours, minutes };
    }
    
    async getGlobalStats() {
        // Fetch global statistics for today's challenge
        try {
            const response = await fetch('/api/daily-challenge.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'getStats',
                    challengeId: this.currentChallenge.id
                })
            });
            
            if (response.ok) {
                return await response.json();
            }
        } catch (error) {
            console.error('Failed to get global stats:', error);
        }
        return null;
    }
    
    getStreakRewards() {
        // Define streak milestone rewards
        const milestones = [
            { streak: 3, reward: 'Bronze Badge', xp: 500 },
            { streak: 7, reward: 'Silver Badge', xp: 1000 },
            { streak: 14, reward: 'Gold Badge', xp: 2000 },
            { streak: 30, reward: 'Platinum Badge', xp: 5000 },
            { streak: 60, reward: 'Diamond Badge', xp: 10000 },
            { streak: 100, reward: 'Master Badge', xp: 20000 }
        ];
        
        return milestones.filter(m => m.streak === this.streak);
    }
    
    isAvailable() {
        const today = new Date().toISOString().split('T')[0];
        return this.lastPlayedDate !== today;
    }
}

window.dailyChallenge = const dailyChallenge = new DailyChallenge();
})();

/* scripts/modes/gameMode.js */
(function() {
// Abstract base class for all game modes
window.GameMode = class GameMode {
    constructor(game) {
        this.game = game;
        this.name = 'Base Mode';
        this.description = 'Base game mode';
        this.objectives = [];
        this.modeSpecificStats = {};
        this.isComplete = false;
        this.isPaused = false;
        this.startTime = null;
        this.endTime = null;
    }

    // Abstract methods that must be implemented by subclasses
    initialize() {
        throw new Error('initialize() must be implemented by subclass');
    }

    update(deltaTime) {
        throw new Error('update() must be implemented by subclass');
    }

    handleLineClears(linesCleared, specialClear) {
        throw new Error('handleLineClears() must be implemented by subclass');
    }

    getObjective() {
        throw new Error('getObjective() must be implemented by subclass');
    }

    getModeUI() {
        throw new Error('getModeUI() must be implemented by subclass');
    }

    // Common methods that can be overridden if needed
    start() {
        this.startTime = Date.now();
        this.isComplete = false;
        this.isPaused = false;
        this.initialize();
    }

    pause() {
        this.isPaused = true;
    }

    resume() {
        this.isPaused = false;
    }

    end(won = false) {
        this.endTime = Date.now();
        this.isComplete = true;
        const duration = this.endTime - this.startTime;
        return {
            mode: this.name,
            won: won,
            duration: duration,
            stats: this.getModeStats()
        };
    }

    getModeStats() {
        return {
            ...this.modeSpecificStats,
            duration: this.endTime ? this.endTime - this.startTime : Date.now() - this.startTime
        };
    }

    // Save and load state for offline support
    saveState() {
        return {
            name: this.name,
            startTime: this.startTime,
            modeSpecificStats: this.modeSpecificStats,
            isComplete: this.isComplete,
            isPaused: this.isPaused
        };
    }

    loadState(state) {
        this.startTime = state.startTime;
        this.modeSpecificStats = state.modeSpecificStats;
        this.isComplete = state.isComplete;
        this.isPaused = state.isPaused;
    }

    // Check if mode has special rules
    hasSpecialRules() {
        return false;
    }

    getSpecialRules() {
        return {};
    }

    // Handle mode-specific input
    handleInput(action) {
        // Override in subclasses if needed
        return false;
    }

    // Get current progress percentage
    getProgress() {
        return 0;
    }

    // Check if the mode should end
    shouldEnd() {
        return false;
    }

    // Get mode-specific scoring multiplier
    getScoreMultiplier() {
        return 1;
    }

    // Get mode-specific speed level
    getSpeedLevel() {
        return this.game.level;
    }

    // Check if hold piece is allowed
    isHoldAllowed() {
        return true;
    }

    // Check if ghost piece should be shown
    showGhostPiece() {
        return true;
    }

    // Get mode-specific background music tempo
    getMusicTempo() {
        return 1;
    }

    // Handle game over condition
    handleGameOver() {
        return this.end(false);
    }

    // Handle victory condition
    handleVictory() {
        return this.end(true);
    }

    // Render mode-specific UI elements
    renderModeSpecificUI(ctx, canvas) {
        // Override in subclasses to render custom UI
    }

    // Get leaderboard category for this mode
    getLeaderboardCategory() {
        return this.name.toLowerCase().replace(/\s+/g, '_');
    }

    // Check if mode supports saving mid-game
    supportsSaving() {
        return false;
    }

    // Get mode icon for UI
    getIcon() {
        return '';
    }

    // Get mode color theme
    getThemeColor() {
        return 'var(--neon-blue)';
    }
}
})();

/* scripts/modes/classicMode.js */
(function() {
// Classic Tetris Mode - The original endless gameplay

window.ClassicMode = class ClassicMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Classic';
        this.description = 'The original endless Tetris experience';
        this.icon = '';
        this.themeColor = 'var(--neon-blue)';
    }

    initialize() {
        // Classic mode starts at level 1
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Reset special achievements
        this.game.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        this.modeSpecificStats = {
            highestLevel: 1,
            maxCombo: 0,
            totalTSpins: 0,
            totalTetris: 0
        };
    }

    update(deltaTime) {
        // Classic mode has no special update logic
        // Game continues until game over
        return true;
    }

    handlePiecePlaced() {
        // Classic mode doesn't need special piece tracking
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines cleared
        this.game.lines += linesCleared;
        
        // Calculate score based on classic scoring
        let baseScore = 0;
        switch (linesCleared) {
            case 1:
                baseScore = 100;
                break;
            case 2:
                baseScore = 300;
                break;
            case 3:
                baseScore = 500;
                break;
            case 4:
                baseScore = 800;
                this.game.specialAchievements.tetris++;
                this.modeSpecificStats.totalTetris++;
                break;
        }
        
        // Apply level multiplier
        let score = baseScore * this.game.level;
        
        // Add combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo * this.game.level;
            this.game.specialAchievements.combos++;
        }
        
        // Add T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            score += 400 * this.game.level;
            this.game.specialAchievements.tspins++;
            this.modeSpecificStats.totalTSpins++;
        }
        
        // Add perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            score += 1000 * this.game.level;
            this.game.specialAchievements.perfectClears++;
        }
        
        this.game.score += score;
        
        // Update combo
        this.game.combo++;
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // Level progression - every 10 lines
        const newLevel = Math.floor(this.game.lines / 10) + 1;
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            if (newLevel > this.modeSpecificStats.highestLevel) {
                this.modeSpecificStats.highestLevel = newLevel;
            }
            
            // Increase game speed
            this.updateGameSpeed();
            
            // Update music tempo
            if (this.game.audioManager) {
                this.game.audioManager.setGameLevel(this.game.level);
            }
        }
    }

    updateGameSpeed() {
        // Classic speed curve
        const baseInterval = 1000;
        const speedMultiplier = Math.pow(0.9, this.game.level - 1);
        this.game.dropInterval = Math.max(50, baseInterval * speedMultiplier);
    }

    getObjective() {
        return 'Survive as long as possible!';
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: false,
            customDisplay: null
        };
    }

    getProgress() {
        // Classic mode has no completion, return level progress
        return ((this.game.lines % 10) / 10) * 100;
    }

    shouldEnd() {
        // Classic mode only ends on game over
        return false;
    }

    getScoreMultiplier() {
        // Classic mode uses standard scoring
        return 1;
    }

    getSpeedLevel() {
        return this.game.level;
    }

    isHoldAllowed() {
        return true;
    }

    showGhostPiece() {
        return true;
    }

    getMusicTempo() {
        // Tempo increases with level
        return 1 + (this.game.level - 1) * 0.02;
    }

    handleGameOver() {
        const result = super.handleGameOver();
        
        // Add final stats
        result.finalScore = this.game.score;
        result.finalLines = this.game.lines;
        result.finalLevel = this.game.level;
        result.achievements = this.game.specialAchievements;
        
        return result;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            score: this.game.score,
            lines: this.game.lines,
            level: this.game.level,
            combo: this.game.combo,
            specialAchievements: this.game.specialAchievements,
            dropInterval: this.game.dropInterval
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.score = state.score;
        this.game.lines = state.lines;
        this.game.level = state.level;
        this.game.combo = state.combo;
        this.game.specialAchievements = state.specialAchievements;
        this.game.dropInterval = state.dropInterval;
    }

    getLeaderboardCategory() {
        return 'classic';
    }

    supportsSaving() {
        return false; // Classic mode doesn't support mid-game saving
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return 'var(--neon-blue)';
    }
}
})();

/* scripts/modes/sprintMode.js */
(function() {
// Sprint Mode - Clear 40 lines as fast as possible

window.SprintMode = class SprintMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Sprint';
        this.description = 'Clear 40 lines as fast as possible!';
        this.icon = '';
        this.themeColor = '#ff00ff';
        
        this.targetLines = 40;
        this.timerInterval = null;
        this.elapsedTime = 0;
        this.bestTime = this.loadBestTime();
    }

    initialize() {
        // Sprint mode configuration
        this.game.level = 1; // Fixed level for fair competition
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Fixed speed for sprint mode
        this.game.dropInterval = 500; // Medium speed
        
        this.modeSpecificStats = {
            targetLines: this.targetLines,
            linesRemaining: this.targetLines,
            elapsedTime: 0,
            piecesUsed: 0,
            efficiency: 0,
            maxCombo: 0
        };
        
        // Start the timer
        this.startTimer();
    }

    startTimer() {
        this.elapsedTime = 0;
        this.timerInterval = setInterval(() => {
            if (!this.isPaused && !this.isComplete) {
                this.elapsedTime += 10; // Update every 10ms for precision
                this.modeSpecificStats.elapsedTime = this.elapsedTime;
            }
        }, 10);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    update(deltaTime) {
        // Check if target reached
        if (this.game.lines >= this.targetLines && !this.isComplete) {
            this.handleVictory();
            return false; // End the game
        }
        
        // Update remaining lines
        this.modeSpecificStats.linesRemaining = Math.max(0, this.targetLines - this.game.lines);
        
        // Update efficiency (lines per piece)
        if (this.modeSpecificStats.piecesUsed > 0) {
            this.modeSpecificStats.efficiency = 
                (this.game.lines / this.modeSpecificStats.piecesUsed * 100).toFixed(1);
        }
        
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines
        this.game.lines += linesCleared;
        
        // Update combo
        this.game.combo++;
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // Calculate score (minimal in sprint, focus is on time)
        let score = linesCleared * 100;
        if (specialClear && specialClear.type === 'tspin') {
            score += 200;
        }
        this.game.score += score;
        
        // Play sound effect
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('lineClear');
            
            // Special sound for getting close to goal
            if (this.game.lines >= this.targetLines - 5) {
                this.game.audioManager.playSFX('combo');
            }
        }
    }

    handlePiecePlaced() {
        this.modeSpecificStats.piecesUsed++;
    }

    getObjective() {
        const remaining = this.targetLines - this.game.lines;
        if (remaining > 0) {
            return `Clear ${remaining} more lines!`;
        }
        return 'Sprint Complete!';
    }

    getModeUI() {
        return {
            showScore: false, // Score not important in sprint
            showLines: true,
            showLevel: false, // Fixed level
            showHold: true,
            showNext: true,
            showTimer: true,
            showObjective: true,
            customDisplay: {
                timer: this.formatTime(this.elapsedTime),
                bestTime: this.bestTime ? this.formatTime(this.bestTime) : '--:--:--',
                linesRemaining: this.modeSpecificStats.linesRemaining,
                efficiency: `${this.modeSpecificStats.efficiency}%`
            }
        };
    }

    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const ms = Math.floor((milliseconds % 1000) / 10);
        
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }

    pause() {
        super.pause();
        // Timer is paused through isPaused flag
    }

    resume() {
        super.resume();
        // Timer resumes automatically
    }

    getProgress() {
        return (this.game.lines / this.targetLines) * 100;
    }

    shouldEnd() {
        return this.game.lines >= this.targetLines;
    }

    getMusicTempo() {
        // Faster tempo as approaching goal
        const progress = this.game.lines / this.targetLines;
        return 1 + progress * 0.3; // Up to 30% faster near the end
    }

    handleVictory() {
        this.stopTimer();
        this.isComplete = true;
        
        // Check if new record
        const isNewRecord = !this.bestTime || this.elapsedTime < this.bestTime;
        if (isNewRecord) {
            this.saveBestTime(this.elapsedTime);
        }
        
        // Prepare result data
        const result = {
            mode: 'Sprint',
            won: true,
            time: this.elapsedTime,
            formattedTime: this.formatTime(this.elapsedTime),
            isNewRecord: isNewRecord,
            piecesUsed: this.modeSpecificStats.piecesUsed,
            efficiency: this.modeSpecificStats.efficiency,
            maxCombo: this.modeSpecificStats.maxCombo,
            score: this.game.score,
            lines: this.game.lines
        };
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('levelUp');
            this.game.audioManager.stopBackgroundMusic();
        }
        
        // Show victory message with time
        if (this.game.uiManager) {
            const message = isNewRecord ? 
                ` NEW RECORD! \nTime: ${this.formatTime(this.elapsedTime)}\nPieces: ${this.modeSpecificStats.piecesUsed}` :
                `Sprint Complete!\nTime: ${this.formatTime(this.elapsedTime)}\nPieces: ${this.modeSpecificStats.piecesUsed}\nBest: ${this.formatTime(this.bestTime)}`;
            
            this.game.uiManager.showOverlay('Sprint Victory!', message, true);
        }
        
        // Trigger game over to stop the game
        this.game.triggerGameOver(true, result);
        
        return result;
    }

    handleGameOver() {
        this.stopTimer();
        const result = super.handleGameOver();
        
        result.time = this.elapsedTime;
        result.formattedTime = this.formatTime(this.elapsedTime);
        result.linesCleared = this.game.lines;
        result.linesRemaining = this.targetLines - this.game.lines;
        
        return result;
    }

    loadBestTime() {
        const saved = localStorage.getItem('tetris_sprint_best_time');
        return saved ? parseInt(saved) : null;
    }

    saveBestTime(time) {
        this.bestTime = time;
        localStorage.setItem('tetris_sprint_best_time', time.toString());
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            elapsedTime: this.elapsedTime,
            piecesUsed: this.modeSpecificStats.piecesUsed
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.elapsedTime = state.elapsedTime;
        this.modeSpecificStats.piecesUsed = state.piecesUsed;
        this.modeSpecificStats.linesRemaining = this.targetLines - this.game.lines;
        
        // Restart timer from saved time
        this.startTimer();
    }

    cleanup() {
        this.stopTimer();
    }

    getLeaderboardCategory() {
        return 'sprint';
    }

    supportsSaving() {
        return false; // Sprint is a time attack, no mid-game saving
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return '#ff00ff';
    }
}
})();

/* scripts/modes/marathonMode.js */
(function() {
// Marathon Mode - Survive 150 lines with increasing difficulty

window.MarathonMode = class MarathonMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Marathon';
        this.description = 'Survive 150 lines with increasing difficulty!';
        this.icon = '';
        this.themeColor = '#ffff00';
        
        this.targetLines = 150;
        this.checkpoints = [50, 100, 150]; // Checkpoint levels
        this.lastCheckpoint = 0;
        this.savedState = null;
    }

    initialize() {
        // Marathon mode configuration
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Start with moderate speed
        this.game.dropInterval = 800;
        
        this.modeSpecificStats = {
            targetLines: this.targetLines,
            linesRemaining: this.targetLines,
            checkpointsReached: 0,
            nextCheckpoint: this.checkpoints[0],
            maxLevel: 1,
            totalScore: 0,
            maxCombo: 0,
            tspins: 0,
            tetris: 0
        };
        
        // Check for saved game
        this.loadSavedGame();
    }

    update(deltaTime) {
        // Check if target reached
        if (this.game.lines >= this.targetLines && !this.isComplete) {
            this.handleVictory();
            return false;
        }
        
        // Update remaining lines
        this.modeSpecificStats.linesRemaining = Math.max(0, this.targetLines - this.game.lines);
        
        // Check for checkpoint
        this.checkCheckpoint();
        
        // Auto-save at checkpoints
        if (this.shouldAutoSave()) {
            this.autoSave();
        }
        
        return true;
    }

    handlePiecePlaced() {
        // Marathon mode doesn't need special piece tracking
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) return;
        
        // Update lines
        this.game.lines += linesCleared;
        
        // Calculate score with level multiplier
        let baseScore = 0;
        switch (linesCleared) {
            case 1:
                baseScore = 100;
                break;
            case 2:
                baseScore = 300;
                break;
            case 3:
                baseScore = 500;
                break;
            case 4:
                baseScore = 800;
                this.modeSpecificStats.tetris++;
                break;
        }
        
        let score = baseScore * this.game.level;
        
        // Combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo * this.game.level;
        }
        this.game.combo++;
        
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        // T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            score += 400 * this.game.level;
            this.modeSpecificStats.tspins++;
        }
        
        // Perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            score += 1000 * this.game.level;
        }
        
        this.game.score += score;
        this.modeSpecificStats.totalScore = this.game.score;
        
        // Level progression - every 10 lines
        const newLevel = Math.floor(this.game.lines / 10) + 1;
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            if (newLevel > this.modeSpecificStats.maxLevel) {
                this.modeSpecificStats.maxLevel = newLevel;
            }
            this.updateGameSpeed();
            
            // Update music tempo
            if (this.game.audioManager) {
                this.game.audioManager.setGameLevel(this.game.level);
            }
        }
    }

    updateGameSpeed() {
        // Progressive speed increase
        const baseInterval = 800;
        const speedMultiplier = Math.pow(0.92, this.game.level - 1);
        this.game.dropInterval = Math.max(50, baseInterval * speedMultiplier);
    }

    checkCheckpoint() {
        for (let i = 0; i < this.checkpoints.length; i++) {
            const checkpoint = this.checkpoints[i];
            if (this.game.lines >= checkpoint && this.lastCheckpoint < checkpoint) {
                this.lastCheckpoint = checkpoint;
                this.modeSpecificStats.checkpointsReached++;
                this.modeSpecificStats.nextCheckpoint = 
                    i < this.checkpoints.length - 1 ? this.checkpoints[i + 1] : this.targetLines;
                
                // Show checkpoint message
                if (this.game.uiManager) {
                    this.game.uiManager.showMessage(`Checkpoint ${checkpoint} lines reached!`);
                }
                
                // Play checkpoint sound
                if (this.game.audioManager) {
                    this.game.audioManager.playSFX('levelUp');
                }
                
                return true;
            }
        }
        return false;
    }

    shouldAutoSave() {
        // Auto-save every 10 lines
        return this.game.lines > 0 && this.game.lines % 10 === 0;
    }

    autoSave() {
        this.savedState = this.saveState();
        localStorage.setItem('tetris_marathon_saved', JSON.stringify(this.savedState));
    }

    loadSavedGame() {
        const saved = localStorage.getItem('tetris_marathon_saved');
        if (saved) {
            try {
                const state = JSON.parse(saved);
                // Ask user if they want to continue
                if (this.game.uiManager) {
                    this.game.uiManager.showContinuePrompt(state, (continueGame) => {
                        if (continueGame) {
                            this.loadState(state);
                        } else {
                            localStorage.removeItem('tetris_marathon_saved');
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load saved game:', e);
            }
        }
    }

    getObjective() {
        const checkpoint = this.modeSpecificStats.nextCheckpoint;
        const linesToCheckpoint = checkpoint - this.game.lines;
        
        if (this.game.lines >= this.targetLines) {
            return 'Marathon Complete!';
        } else if (linesToCheckpoint > 0) {
            return `${linesToCheckpoint} lines to checkpoint ${checkpoint}`;
        }
        return `Clear ${this.modeSpecificStats.linesRemaining} more lines!`;
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: true,
            customDisplay: {
                checkpoint: `${this.lastCheckpoint}/${this.targetLines}`,
                progress: `${Math.floor(this.getProgress())}%`
            }
        };
    }

    getProgress() {
        return (this.game.lines / this.targetLines) * 100;
    }

    shouldEnd() {
        return this.game.lines >= this.targetLines;
    }

    getMusicTempo() {
        // Tempo increases with level
        return 1 + (this.game.level - 1) * 0.03;
    }

    handleVictory() {
        this.isComplete = true;
        
        const result = {
            mode: 'Marathon',
            won: true,
            finalScore: this.game.score,
            finalLevel: this.game.level,
            checkpointsReached: this.modeSpecificStats.checkpointsReached,
            maxCombo: this.modeSpecificStats.maxCombo,
            tspins: this.modeSpecificStats.tspins,
            tetris: this.modeSpecificStats.tetris,
            lines: this.game.lines
        };
        
        // Clear saved game
        localStorage.removeItem('tetris_marathon_saved');
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('levelUp');
            this.game.audioManager.stopBackgroundMusic();
        }
        
        // Show victory message
        if (this.game.uiManager) {
            const message = ` Marathon Complete! \nScore: ${this.game.score.toLocaleString()}\nLevel: ${this.game.level}\nCheckpoints: ${this.modeSpecificStats.checkpointsReached}/3`;
            this.game.uiManager.showOverlay('Marathon Victory!', message, true);
        }
        
        // Trigger game over to stop the game
        this.game.triggerGameOver(true, result);
        
        return result;
    }

    handleGameOver() {
        const result = super.handleGameOver();
        
        result.linesCleared = this.game.lines;
        result.linesRemaining = this.targetLines - this.game.lines;
        result.checkpointsReached = this.modeSpecificStats.checkpointsReached;
        result.finalScore = this.game.score;
        result.finalLevel = this.game.level;
        
        // Clear saved game
        localStorage.removeItem('tetris_marathon_saved');
        
        return result;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            score: this.game.score,
            level: this.game.level,
            combo: this.game.combo,
            lastCheckpoint: this.lastCheckpoint,
            dropInterval: this.game.dropInterval,
            grid: this.game.grid ? this.game.grid.saveState() : null,
            currentPiece: this.game.currentPiece ? this.game.currentPiece.saveState() : null,
            heldPiece: this.game.heldPiece ? this.game.heldPiece.saveState() : null,
            nextPieces: this.game.nextPieces
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.game.score = state.score;
        this.game.level = state.level;
        this.game.combo = state.combo;
        this.lastCheckpoint = state.lastCheckpoint;
        this.game.dropInterval = state.dropInterval;
        
        // Restore grid state
        if (state.grid && this.game.grid) {
            this.game.grid.loadState(state.grid);
        }
        
        // Restore pieces
        if (state.currentPiece && this.game.currentPiece) {
            this.game.currentPiece.loadState(state.currentPiece);
        }
        if (state.heldPiece && this.game.heldPiece) {
            this.game.heldPiece.loadState(state.heldPiece);
        }
        if (state.nextPieces) {
            this.game.nextPieces = state.nextPieces;
        }
        
        // Update stats
        this.modeSpecificStats.linesRemaining = this.targetLines - this.game.lines;
        for (let i = 0; i < this.checkpoints.length; i++) {
            if (this.checkpoints[i] > this.game.lines) {
                this.modeSpecificStats.nextCheckpoint = this.checkpoints[i];
                break;
            }
        }
    }

    pause() {
        super.pause();
        // Auto-save when pausing
        this.autoSave();
    }

    getLeaderboardCategory() {
        return 'marathon';
    }

    supportsSaving() {
        return true; // Marathon supports mid-game saving
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return '#ffff00';
    }
}
})();

/* scripts/modes/zenMode.js */
(function() {
// Zen Mode - Relaxing endless mode with no pressure

window.ZenMode = class ZenMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Zen';
        this.description = 'Relax and play without pressure. No game over!';
        this.icon = '';
        this.themeColor = '#00ff00';
        
        // Zen mode settings
        this.customSpeed = this.loadCustomSpeed();
        this.autoSaveInterval = 30000; // Auto-save every 30 seconds
        this.lastAutoSave = Date.now();
        this.sessionStats = null;
        this.savedGames = [];
    }

    initialize() {
        // Zen mode configuration
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Use custom speed or default
        this.game.dropInterval = this.customSpeed || 1000;
        
        this.modeSpecificStats = {
            sessionTime: 0,
            totalPieces: 0,
            totalLines: 0,
            totalScore: 0,
            averageLinesPerMinute: 0,
            maxCombo: 0,
            tspins: 0,
            tetris: 0,
            perfectClears: 0,
            efficiency: 0,
            bestStreak: 0,
            currentStreak: 0
        };
        
        // Initialize session tracking
        this.sessionStats = {
            startTime: Date.now(),
            pieces: [],
            lineClears: [],
            scores: []
        };
        
        // Load any saved game
        this.checkForSavedGames();
    }

    update(deltaTime) {
        // Update session time
        this.modeSpecificStats.sessionTime = Date.now() - this.sessionStats.startTime;
        
        // Calculate statistics
        this.updateStatistics();
        
        // Auto-save periodically
        if (Date.now() - this.lastAutoSave > this.autoSaveInterval) {
            this.autoSave();
            this.lastAutoSave = Date.now();
        }
        
        // Zen mode never ends
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) {
            // Break streak
            if (this.modeSpecificStats.currentStreak > this.modeSpecificStats.bestStreak) {
                this.modeSpecificStats.bestStreak = this.modeSpecificStats.currentStreak;
            }
            this.modeSpecificStats.currentStreak = 0;
            return;
        }
        
        // Update lines
        this.game.lines += linesCleared;
        this.modeSpecificStats.totalLines = this.game.lines;
        
        // Track line clears
        this.sessionStats.lineClears.push({
            lines: linesCleared,
            time: Date.now() - this.sessionStats.startTime,
            special: specialClear
        });
        
        // Update streak
        this.modeSpecificStats.currentStreak++;
        
        // Calculate score (relaxed scoring)
        let score = linesCleared * 100;
        
        // Special clear bonuses
        if (specialClear) {
            if (specialClear.type === 'tspin') {
                score += 200;
                this.modeSpecificStats.tspins++;
            } else if (specialClear.type === 'perfectClear') {
                score += 500;
                this.modeSpecificStats.perfectClears++;
            }
        }
        
        // Tetris bonus
        if (linesCleared === 4) {
            score += 300;
            this.modeSpecificStats.tetris++;
        }
        
        // Combo bonus
        if (this.game.combo > 0) {
            score += 50 * this.game.combo;
        }
        this.game.combo++;
        
        if (this.game.combo > this.modeSpecificStats.maxCombo) {
            this.modeSpecificStats.maxCombo = this.game.combo;
        }
        
        this.game.score += score;
        this.modeSpecificStats.totalScore = this.game.score;
        
        // Track score
        this.sessionStats.scores.push({
            score: score,
            total: this.game.score,
            time: Date.now() - this.sessionStats.startTime
        });
        
        // Gentle level progression (optional)
        const newLevel = Math.floor(this.game.lines / 20) + 1; // Slower progression
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            // Don't change speed in Zen mode unless user wants
            if (!this.customSpeed) {
                this.updateGameSpeed();
            }
        }
    }

    handlePiecePlaced() {
        this.modeSpecificStats.totalPieces++;
        this.sessionStats.pieces.push(Date.now() - this.sessionStats.startTime);
    }

    updateGameSpeed() {
        // Very gentle speed increase in Zen mode
        const baseInterval = 1000;
        const speedMultiplier = Math.pow(0.98, this.game.level - 1);
        this.game.dropInterval = Math.max(200, baseInterval * speedMultiplier);
    }

    updateStatistics() {
        // Calculate lines per minute
        const minutesPlayed = this.modeSpecificStats.sessionTime / 60000;
        if (minutesPlayed > 0) {
            this.modeSpecificStats.averageLinesPerMinute = 
                (this.game.lines / minutesPlayed).toFixed(1);
        }
        
        // Calculate efficiency
        if (this.modeSpecificStats.totalPieces > 0) {
            this.modeSpecificStats.efficiency = 
                (this.game.lines / this.modeSpecificStats.totalPieces * 100).toFixed(1);
        }
    }

    // Special Zen mode features
    clearGrid() {
        // Allow clearing the grid in Zen mode
        if (this.game.grid) {
            this.game.grid.reset();
        }
    }

    setCustomSpeed(speed) {
        this.customSpeed = speed;
        this.game.dropInterval = speed;
        localStorage.setItem('tetris_zen_speed', speed.toString());
    }

    loadCustomSpeed() {
        const saved = localStorage.getItem('tetris_zen_speed');
        return saved ? parseInt(saved) : null;
    }

    exportStatistics() {
        // Export session statistics as JSON
        const exportData = {
            mode: 'zen',
            date: new Date().toISOString(),
            sessionTime: this.modeSpecificStats.sessionTime,
            stats: this.modeSpecificStats,
            sessionDetails: this.sessionStats
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], 
            { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `tetris_zen_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    autoSave() {
        const saveData = this.saveState();
        const saveId = `zen_${Date.now()}`;
        
        // Keep only last 5 saves
        this.savedGames.push({ id: saveId, data: saveData, time: Date.now() });
        if (this.savedGames.length > 5) {
            this.savedGames.shift();
        }
        
        localStorage.setItem('tetris_zen_saves', JSON.stringify(this.savedGames));
        
        // Show save indicator
        if (this.game.uiManager) {
            this.game.uiManager.showMessage('Game saved', 'success', 1000);
        }
    }

    checkForSavedGames() {
        const saved = localStorage.getItem('tetris_zen_saves');
        if (saved) {
            try {
                this.savedGames = JSON.parse(saved);
                if (this.savedGames.length > 0 && this.game.uiManager) {
                    // Show load game prompt
                    this.game.uiManager.showLoadGamePrompt(this.savedGames, (saveId) => {
                        const save = this.savedGames.find(s => s.id === saveId);
                        if (save) {
                            this.loadState(save.data);
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load saved games:', e);
            }
        }
    }

    getObjective() {
        return 'Relax and enjoy! No pressure.';
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: true,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: false,
            customDisplay: {
                time: this.formatTime(this.modeSpecificStats.sessionTime),
                lpm: `${this.modeSpecificStats.averageLinesPerMinute} LPM`,
                efficiency: `${this.modeSpecificStats.efficiency}%`,
                pieces: this.modeSpecificStats.totalPieces,
                streak: this.modeSpecificStats.currentStreak
            }
        };
    }

    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    getProgress() {
        // Zen mode has no completion
        return 0;
    }

    shouldEnd() {
        // Zen mode never ends
        return false;
    }

    getMusicTempo() {
        // Calm, consistent tempo for Zen mode
        return 0.8; // Slower than normal
    }

    handleGameOver() {
        // In Zen mode, there's no real game over
        // Just clear the grid and continue
        this.clearGrid();
        
        // Reset combo
        this.game.combo = 0;
        
        // Show message
        if (this.game.uiManager) {
            this.game.uiManager.showMessage('Grid cleared! Keep playing.', 'info', 2000);
        }
        
        // Don't actually end the game
        return null;
    }

    saveState() {
        const baseState = super.saveState();
        return {
            ...baseState,
            lines: this.game.lines,
            score: this.game.score,
            level: this.game.level,
            customSpeed: this.customSpeed,
            sessionStats: this.sessionStats,
            grid: this.game.grid ? this.game.grid.saveState() : null,
            currentPiece: this.game.currentPiece ? this.game.currentPiece.saveState() : null,
            heldPiece: this.game.heldPiece ? this.game.heldPiece.saveState() : null,
            nextPieces: this.game.nextPieces
        };
    }

    loadState(state) {
        super.loadState(state);
        this.game.lines = state.lines;
        this.game.score = state.score;
        this.game.level = state.level;
        this.customSpeed = state.customSpeed;
        this.sessionStats = state.sessionStats;
        
        // Restore grid and pieces
        if (state.grid && this.game.grid) {
            this.game.grid.loadState(state.grid);
        }
        if (state.currentPiece && this.game.currentPiece) {
            this.game.currentPiece.loadState(state.currentPiece);
        }
        if (state.heldPiece && this.game.heldPiece) {
            this.game.heldPiece.loadState(state.heldPiece);
        }
        if (state.nextPieces) {
            this.game.nextPieces = state.nextPieces;
        }
        
        // Restore custom speed
        if (this.customSpeed) {
            this.game.dropInterval = this.customSpeed;
        }
    }

    handleInput(action) {
        // Special Zen mode inputs
        if (action === 'clearGrid') {
            this.clearGrid();
            return true;
        } else if (action === 'exportStats') {
            this.exportStatistics();
            return true;
        } else if (action === 'quickSave') {
            this.autoSave();
            return true;
        }
        return false;
    }

    getLeaderboardCategory() {
        return 'zen';
    }

    supportsSaving() {
        return true; // Zen mode fully supports saving
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return '#00ff00';
    }
}
})();

/* scripts/modes/puzzleMode.js */
(function() {
// Puzzle Mode - Solve 150 unique challenges





window.PuzzleMode = class PuzzleMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Puzzle';
        this.description = 'Solve 150 unique Tetris challenges!';
        this.icon = '';
        this.themeColor = '#ff8800';
        
        this.currentPuzzle = null;
        this.puzzleId = 1;
        this.completedPuzzles = [];
        this.puzzleStats = {};
        // Load async data after initialization
        this.loadCompletedPuzzles().then(data => {
            this.completedPuzzles = data;
        });
        this.availablePieces = [];
        this.usedPieces = 0;
        this.timeElapsed = 0;
        this.timerInterval = null;
        this.pendingCompletion = false;
        this.hintsUsed = 0;
        this.hintSystem = new HintSystem(game);
    }

    async initialize() {
        // Wait for completed puzzles to load
        this.completedPuzzles = await this.loadCompletedPuzzles();
        
        // Try to load saved progress first
        const progress = await this.loadCurrentProgress();
        if (progress && progress.currentPuzzleId) {
            this.puzzleId = progress.currentPuzzleId;
        } else {
            // Load first puzzle or continue from last
            this.puzzleId = this.getLastUncompletedPuzzle();
        }
        this.loadPuzzle(this.puzzleId);
        await this.saveCurrentProgress(); // Save current puzzle being played
    }

    loadPuzzle(puzzleId) {
        let puzzle = getPuzzleById(puzzleId);
        if (!puzzle) {
            console.error(`Puzzle ${puzzleId} not found`);
            return;
        }
        
        // Validate and auto-fix puzzle before loading
        puzzle = this.validateAndFixPuzzle(puzzle);
        this.currentPuzzle = puzzle;
        
        // Reset game state
        this.game.lines = 0;
        this.game.score = 0;
        this.game.level = 1;
        this.game.combo = 0;
        
        // Load puzzle grid
        if (this.game.grid && this.currentPuzzle.initialGrid) {
            this.game.grid.loadFromArray(this.currentPuzzle.initialGrid);
        }
        
        // Set available pieces
        if (this.currentPuzzle.pieces === 'random') {
            this.availablePieces = [];
        } else {
            this.availablePieces = [...this.currentPuzzle.pieces];
        }
        
        // Initialize puzzle stats
        this.puzzleStats = {
            puzzleId: puzzleId,
            objective: this.currentPuzzle.objective,
            targetLines: this.currentPuzzle.targetLines || 0,
            targetTSpins: this.currentPuzzle.targetTSpins || 0,
            targetTetris: this.currentPuzzle.targetTetris || 0,
            targetCombo: this.currentPuzzle.targetCombo || 0,
            minScore: this.currentPuzzle.minScore || 0,
            linesCleared: 0,
            tspinsPerformed: 0,
            tetrisPerformed: 0,
            maxCombo: 0,
            piecesUsed: 0,
            timeElapsed: 0
        };
        
        this.usedPieces = 0;
        this.timeElapsed = 0;
        this.pendingCompletion = false;
        this.isComplete = false;
        this.hintsUsed = 0;
        
        // Initialize hint system for this puzzle
        this.hintSystem.initialize(this.currentPuzzle);
        
        // Start timer if puzzle has time limit
        if (this.currentPuzzle.timeLimit > 0) {
            this.startTimer();
        }
        
        // Show puzzle info with validation status
        if (this.game.uiManager) {
            const validationMsg = this.currentPuzzle._wasFixed ? ' (Auto-adjusted)' : '';
            this.game.uiManager.showMessage(
                `Puzzle ${puzzleId}: ${this.currentPuzzle.name}${validationMsg}`,
                'info',
                3000
            );
        }
    }

    startTimer() {
        this.timeElapsed = 0;
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }
        
        this.timerInterval = setInterval(() => {
            if (!this.isPaused && !this.isComplete) {
                this.timeElapsed++;
                this.puzzleStats.timeElapsed = this.timeElapsed;
                
                // Check time limit
                if (this.currentPuzzle.timeLimit > 0 && 
                    this.timeElapsed >= this.currentPuzzle.timeLimit) {
                    this.handlePuzzleFailed('Time limit exceeded');
                }
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    update(deltaTime) {
        // If puzzle is already complete, don't process further
        if (this.isComplete) {
            return false;
        }
        
        if (!this.currentPuzzle) return false;
        
        // Handle pending completion from line clear
        if (this.pendingCompletion) {
            this.pendingCompletion = false;
            this.handlePuzzleComplete();
            return false;
        }
        
        // Check objective completion
        if (this.checkObjectiveComplete()) {
            this.handlePuzzleComplete();
            return false;
        }
        
        // Don't check failure conditions if objective is met
        if (!this.checkObjectiveComplete() && this.checkFailureConditions()) {
            this.handlePuzzleFailed('Objective failed');
            return false;
        }
        
        return true;
    }

    handleLineClears(linesCleared, specialClear) {
        // Don't process if puzzle is already complete
        if (this.isComplete) return;
        
        if (!linesCleared || linesCleared === 0) {
            // Reset combo
            if (this.game.combo > this.puzzleStats.maxCombo) {
                this.puzzleStats.maxCombo = this.game.combo;
            }
            this.game.combo = 0;
            return;
        }
        
        // Update stats BEFORE checking completion
        this.puzzleStats.linesCleared += linesCleared;
        this.game.lines += linesCleared;
        this.game.combo++;
        
        if (this.game.combo > this.puzzleStats.maxCombo) {
            this.puzzleStats.maxCombo = this.game.combo;
        }
        
        // Check for special clears
        if (specialClear) {
            if (specialClear.type === 'tspin') {
                this.puzzleStats.tspinsPerformed++;
            }
        }
        
        if (linesCleared === 4) {
            this.puzzleStats.tetrisPerformed++;
        }
        
        // Calculate score
        let score = linesCleared * 100;
        if (specialClear && specialClear.type === 'tspin') {
            score += 400;
        }
        if (linesCleared === 4) {
            score += 400;
        }
        this.game.score += score;
        
        // Check if objective is completed IMMEDIATELY
        if (this.checkObjectiveComplete()) {
            // Mark as complete immediately to prevent game over
            this.isComplete = true;
            this.pendingCompletion = true;
            
            // Call handlePuzzleComplete directly with a small delay
            setTimeout(() => {
                this.handlePuzzleComplete();
            }, 100);
        }
    }

    handlePiecePlaced() {
        // Don't process if puzzle is already complete
        if (this.isComplete) return;
        
        this.usedPieces++;
        this.puzzleStats.piecesUsed = this.usedPieces;
        
        // Check piece limit only if objective is not complete
        if (this.currentPuzzle.maxPieces > 0 && 
            this.usedPieces >= this.currentPuzzle.maxPieces) {
            // Give time for line clears to process
            setTimeout(() => {
                if (!this.isComplete && !this.checkObjectiveComplete()) {
                    this.handlePuzzleFailed('Piece limit exceeded');
                }
            }, 100);
        }
    }

    checkObjectiveComplete() {
        const stats = this.puzzleStats;
        const puzzle = this.currentPuzzle;
        
        switch (puzzle.objective) {
            case 'clear':
                return stats.linesCleared >= (puzzle.targetLines || 1);
                
            case 'tspin':
                return stats.tspinsPerformed >= (puzzle.targetTSpins || 1);
                
            case 'tetris':
                return stats.tetrisPerformed >= (puzzle.targetTetris || 1);
                
            case 'perfectclear':
                return this.game.grid && this.game.grid.isEmpty();
                
            case 'combo':
                return stats.maxCombo >= (puzzle.targetCombo || 3);
                
            case 'mixed':
                return (
                    stats.linesCleared >= (puzzle.targetLines || 0) &&
                    stats.tspinsPerformed >= (puzzle.targetTSpins || 0) &&
                    stats.maxCombo >= (puzzle.targetCombo || 0)
                );
                
            case 'survival':
                return (
                    stats.linesCleared >= (puzzle.targetLines || 0) &&
                    this.game.score >= (puzzle.minScore || 0)
                );
                
            default:
                return false;
        }
    }

    checkFailureConditions() {
        // Check if pieces exhausted without completing objective
        if (this.currentPuzzle.maxPieces > 0 && 
            this.usedPieces >= this.currentPuzzle.maxPieces) {
            return !this.checkObjectiveComplete();
        }
        
        // Check if specific pieces are exhausted
        if (this.availablePieces.length > 0 && 
            this.usedPieces >= this.availablePieces.length) {
            return !this.checkObjectiveComplete();
        }
        
        return false;
    }

    handlePuzzleComplete() {
        // Prevent multiple calls
        if (this.isComplete && this.game.state === 'victory') {
            return;
        }
        
        this.stopTimer();
        this.isComplete = true;
        
        // Calculate stars (1-3 based on performance)
        const stars = this.calculateStars();
        
        // Save completion
        this.savePuzzleCompletion(this.puzzleId, stars);
        
        // Show completion message
        if (this.game.uiManager) {
            this.game.uiManager.showPuzzleComplete(
                this.currentPuzzle,
                stars,
                this.puzzleStats
            );
            
            // Show success message
            this.game.uiManager.showMessage(
                ` Puzzle Complete! ${'\u2b50'.repeat(stars)}`,
                'success',
                3000
            );
        }
        
        // Play victory sound
        if (this.game.audioManager) {
            this.game.audioManager.playSFX('victory');
        }
        
        // Store results but don't end game immediately
        if (this.game) {
            // Store puzzle results for the game over screen
            this.game.puzzleResults = {
                puzzleId: this.puzzleId,
                puzzleName: this.currentPuzzle.name,
                stars: stars,
                stats: this.puzzleStats,
                nextPuzzle: getNextPuzzle(this.puzzleId, this.completedPuzzles),
                isVictory: true
            };
            
            // Set game state to prevent further input
            this.game.state = 'victory';
            
            // The UI will handle the next action (next puzzle or retry)
            // Don't call gameOver here
        }
        
        return {
            puzzleId: this.puzzleId,
            puzzleName: this.currentPuzzle.name,
            stars: stars,
            stats: this.puzzleStats,
            nextPuzzle: getNextPuzzle(this.puzzleId, this.completedPuzzles)
        };
    }

    handlePuzzleFailed(reason) {
        this.stopTimer();
        this.isComplete = true;
        
        // Show failure message
        if (this.game.uiManager) {
            this.game.uiManager.showPuzzleFailed(
                this.currentPuzzle,
                reason,
                this.puzzleStats
            );
        }
        
        // End the game with failure
        if (this.game) {
            // Store puzzle results for the game over screen
            this.game.puzzleResults = {
                puzzleId: this.puzzleId,
                puzzleName: this.currentPuzzle.name,
                failed: true,
                reason: reason,
                stats: this.puzzleStats
            };
            this.game.gameOver();
        }
        
        return {
            puzzleId: this.puzzleId,
            puzzleName: this.currentPuzzle.name,
            failed: true,
            reason: reason,
            stats: this.puzzleStats
        };
    }

    calculateStars() {
        // Start with base star for completion
        let stars = 1;
        let bonusEarned = [];
        
        // Calculate efficiency score (pieces used vs max allowed)
        if (this.currentPuzzle.maxPieces > 0) {
            const efficiency = this.usedPieces / this.currentPuzzle.maxPieces;
            
            if (efficiency <= 0.6) {
                stars = 3; // Perfect efficiency - 60% or less pieces used
                bonusEarned.push('Perfect Efficiency');
            } else if (efficiency <= 0.8) {
                stars = 2; // Good efficiency - 80% or less pieces used
                bonusEarned.push('Good Efficiency');
            }
        }
        
        // Time bonus (if applicable)
        if (this.currentPuzzle.timeLimit > 0 && stars < 3) {
            const timeRatio = this.timeElapsed / (this.currentPuzzle.timeLimit * 1000);
            if (timeRatio <= 0.5) {
                stars = Math.min(3, stars + 1);
                bonusEarned.push('Speed Bonus');
            }
        }
        
        // Perfect clear automatic 3 stars
        if (this.currentPuzzle.objective === 'perfectclear' && 
            this.game.grid && this.game.grid.isEmpty()) {
            stars = 3;
            bonusEarned.push('Perfect Clear');
        }
        
        // Get hints used from hint system
        this.hintsUsed = this.hintSystem.getHintsUsed();
        
        // Deduct stars for hints used
        if (this.hintsUsed > 0) {
            stars = Math.max(1, stars - this.hintsUsed);
            bonusEarned.push(`Hints Used: -${this.hintsUsed}`);
        }
        
        // Store bonus info for display
        this.starsInfo = {
            stars: stars,
            maxStars: 3,
            bonuses: bonusEarned,
            hintsUsed: this.hintsUsed || 0,
            efficiency: this.currentPuzzle.maxPieces > 0 
                ? Math.round((this.usedPieces / this.currentPuzzle.maxPieces) * 100) 
                : 100,
            timePercent: this.currentPuzzle.timeLimit > 0
                ? Math.round((this.timeElapsed / (this.currentPuzzle.timeLimit * 1000)) * 100)
                : 0
        };
        
        return Math.min(3, Math.max(1, stars));
    }

    getNextPiece() {
        if (this.currentPuzzle.pieces === 'random') {
            // Random pieces
            return null; // Let game generate random piece
        } else if (this.availablePieces.length > 0) {
            // Specific piece sequence
            if (this.usedPieces < this.availablePieces.length) {
                return this.availablePieces[this.usedPieces];
            }
            // After using all specified pieces, generate random ones
            return null; // Let game generate random piece
        }
        return null;
    }

    async loadCompletedPuzzles() {
        const saved = await storage.load('puzzle_completed');
        if (saved) {
            return saved;
        }
        // Try legacy localStorage fallback
        const legacySaved = localStorage.getItem('tetris_puzzle_completed');
        if (legacySaved) {
            try {
                const data = JSON.parse(legacySaved);
                // Migrate to new storage
                await storage.save('puzzle_completed', data);
                return data;
            } catch (e) {
                console.error('Failed to load completed puzzles:', e);
            }
        }
        return [];
    }

    savePuzzleCompletion(puzzleId, stars) {
        const completion = {
            puzzleId: puzzleId,
            stars: stars,
            timestamp: Date.now()
        };
        
        // Update completed list
        const existing = this.completedPuzzles.findIndex(p => p.puzzleId === puzzleId);
        if (existing >= 0) {
            // Update if better stars
            if (stars > this.completedPuzzles[existing].stars) {
                this.completedPuzzles[existing] = completion;
            }
        } else {
            this.completedPuzzles.push(completion);
        }
        
        storage.save('puzzle_completed', this.completedPuzzles);
        
        // Also save current progress
        this.saveCurrentProgress();
    }
    
    async saveCurrentProgress() {
        const progress = {
            currentPuzzleId: this.puzzleId,
            highestUnlocked: Math.max(...this.completedPuzzles.map(p => p.puzzleId), this.puzzleId),
            lastPlayed: Date.now()
        };
        await storage.save('puzzle_progress', progress);
    }
    
    async loadCurrentProgress() {
        const saved = await storage.load('puzzle_progress');
        if (saved) {
            return saved;
        }
        // Try legacy localStorage fallback
        const legacySaved = localStorage.getItem('tetris_puzzle_progress');
        if (legacySaved) {
            try {
                const data = JSON.parse(legacySaved);
                // Migrate to new storage
                await storage.save('puzzle_progress', data);
                return data;
            } catch (e) {
                console.error('Failed to load puzzle progress:', e);
            }
        }
        return null;
    }

    getLastUncompletedPuzzle() {
        const unlocked = getUnlockedPuzzles(this.completedPuzzles.map(p => p.puzzleId));
        for (let puzzle of unlocked) {
            if (!this.completedPuzzles.find(p => p.puzzleId === puzzle.id)) {
                return puzzle.id;
            }
        }
        return 1; // Default to first puzzle
    }

    selectPuzzle(puzzleId) {
        const unlocked = getUnlockedPuzzles(this.completedPuzzles.map(p => p.puzzleId));
        if (unlocked.find(p => p.id === puzzleId)) {
            this.loadPuzzle(puzzleId);
            return true;
        }
        return false;
    }

    getObjective() {
        if (!this.currentPuzzle) return 'Select a puzzle';
        
        // Return the current objective with progress
        return this.getObjectiveProgress();
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: false,
            showHold: true,
            showNext: true,
            showTimer: this.currentPuzzle && this.currentPuzzle.timeLimit > 0,
            showObjective: true,
            customDisplay: this.currentPuzzle ? {
                puzzle: `#${this.currentPuzzle.id}: ${this.currentPuzzle.name}`,
                pieces: this.currentPuzzle.maxPieces > 0 && this.currentPuzzle.maxPieces < 999 ? 
                    `Pieces: ${this.usedPieces}/${this.currentPuzzle.maxPieces}` : 
                    `Pieces: ${this.usedPieces}`,
                objective: this.getObjectiveProgress(),
                hint: this.currentPuzzle.hint || null
            } : {}
        };
    }

    getObjectiveProgress() {
        if (!this.currentPuzzle) return '';
        
        switch (this.currentPuzzle.objective) {
            case 'lines':
            case 'clearLines':
            case 'clear':
                const targetLines = this.currentPuzzle.targetLines || 1;
                return ` Clear: ${this.puzzleStats.linesCleared}/${targetLines} line${targetLines > 1 ? 's' : ''}`;
            
            case 'clearAll':
            case 'clearBoard':
                const totalBlocks = this.countRemainingBlocks();
                return ` Clear all blocks (${totalBlocks} left)`;
            
            case 'score':
            case 'minScore':
                const targetScore = this.currentPuzzle.minScore || 1000;
                return ` Score: ${this.game.score}/${targetScore}`;
            
            case 'tspin':
                const targetTSpins = this.currentPuzzle.targetTSpins || 1;
                return ` T-Spins: ${this.puzzleStats.tspinsPerformed}/${targetTSpins}`;
            
            case 'tetris':
                const targetTetris = this.currentPuzzle.targetTetris || 1;
                return ` Tetris: ${this.puzzleStats.tetrisPerformed}/${targetTetris}`;
            
            case 'combo':
                const targetCombo = this.currentPuzzle.targetCombo || 5;
                return ` Combo: ${this.puzzleStats.maxCombo}/${targetCombo}`;
            
            case 'perfect':
                return ` Perfect Clear required`;
            
            case 'survive':
                const timeLimit = this.currentPuzzle.timeLimit || 60;
                const elapsed = Math.floor(this.timeElapsed / 1000);
                return ` Time: ${elapsed}/${timeLimit}s`;
            
            default:
                return this.currentPuzzle.description || 'Complete objective';
        }
    }
    
    countRemainingBlocks() {
        if (!this.game.grid || !this.game.grid.cells) return 0;
        let count = 0;
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (this.game.grid.cells[row][col] !== 0) {
                    count++;
                }
            }
        }
        return count;
    }

    pause() {
        super.pause();
    }

    resume() {
        super.resume();
    }

    cleanup() {
        this.stopTimer();
        // Cleanup hint system
        if (this.hintSystem) {
            this.hintSystem.cleanup();
        }
    }
    
    validateAndFixPuzzle(puzzle) {
        // Convert puzzle to validator format
        const puzzleConfig = {
            name: puzzle.name,
            grid: puzzle.initialGrid || Array(20).fill(null).map(() => Array(10).fill(0)),
            pieces: puzzle.pieces === 'random' ? ['I', 'O', 'T', 'S', 'Z', 'J', 'L'] : puzzle.pieces,
            maxPieces: puzzle.maxPieces || 999,
            objective: this.convertObjective(puzzle),
            hint: puzzle.hint
        };
        
        // Validate the puzzle
        const validation = puzzleValidator.validatePuzzle(puzzleConfig);
        
        if (!validation.valid) {
            console.warn(`Puzzle ${puzzle.id} "${puzzle.name}" has issues:`, validation.issues);
            
            // Auto-fix the puzzle
            const fixed = this.autoFixPuzzle(puzzle, validation);
            fixed._wasFixed = true;
            fixed._validationIssues = validation.issues;
            
            console.log(`Auto-fixed puzzle ${puzzle.id}:`, validation.suggestions);
            return fixed;
        }
        
        return puzzle;
    }
    
    convertObjective(puzzle) {
        const objective = { type: puzzle.objective };
        
        switch (puzzle.objective) {
            case 'lines':
            case 'clearLines':
                objective.type = 'lines';
                objective.count = puzzle.targetLines || 1;
                break;
            case 'score':
            case 'minScore':
                objective.type = 'score';
                objective.target = puzzle.minScore || 1000;
                break;
            case 'clearAll':
            case 'clearBoard':
                objective.type = 'clear';
                break;
            case 'tspin':
                objective.type = 'lines';
                objective.count = puzzle.targetTSpins || 1;
                break;
            case 'tetris':
                objective.type = 'lines';
                objective.count = (puzzle.targetTetris || 1) * 4;
                break;
            case 'combo':
                objective.type = 'lines';
                objective.count = puzzle.targetCombo || 3;
                break;
            default:
                objective.type = 'lines';
                objective.count = 1;
        }
        
        return objective;
    }
    
    autoFixPuzzle(puzzle, validation) {
        const fixed = { ...puzzle };
        
        // Fix piece count if needed
        if (validation.minPiecesRequired > 0) {
            if (!fixed.pieces || fixed.pieces === 'random') {
                fixed.pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            }
            
            // Ensure we have enough pieces
            while (fixed.pieces.length < validation.minPiecesRequired) {
                const allPieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
                const randomPiece = allPieces[Math.floor(Math.random() * allPieces.length)];
                fixed.pieces.push(randomPiece);
            }
            
            // Adjust maxPieces if too restrictive
            if (fixed.maxPieces < validation.minPiecesRequired + 2) {
                fixed.maxPieces = validation.minPiecesRequired + 5;
            }
        }
        
        // Fix objectives that are impossible
        if (validation.issues.some(issue => issue.includes('Objective requires'))) {
            switch (puzzle.objective) {
                case 'lines':
                case 'clearLines':
                    // Reduce line requirement
                    fixed.targetLines = Math.max(1, Math.floor((fixed.targetLines || 1) * 0.75));
                    break;
                case 'score':
                case 'minScore':
                    // Reduce score requirement
                    fixed.minScore = Math.max(100, Math.floor((fixed.minScore || 1000) * 0.5));
                    break;
                case 'tetris':
                    // Reduce tetris requirement or add I pieces
                    if (!fixed.pieces.includes('I')) {
                        fixed.pieces.push('I', 'I', 'I', 'I');
                    }
                    fixed.targetTetris = Math.max(1, Math.floor((fixed.targetTetris || 1) * 0.75));
                    break;
                case 'tspin':
                    // Add T pieces for T-spins
                    if (!fixed.pieces.includes('T')) {
                        fixed.pieces.push('T', 'T', 'T');
                    }
                    fixed.targetTSpins = Math.max(1, Math.floor((fixed.targetTSpins || 1) * 0.75));
                    break;
            }
        }
        
        // Fix grid issues (holes, impossible clears)
        if (validation.issues.some(issue => issue.includes('grid'))) {
            // Simplify the grid if it's too complex
            if (fixed.initialGrid) {
                fixed.initialGrid = this.simplifyGrid(fixed.initialGrid);
            }
        }
        
        return fixed;
    }
    
    simplifyGrid(grid) {
        const simplified = grid.map(row => [...row]);
        
        // Remove isolated blocks that create impossible situations
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (simplified[row][col] !== 0) {
                    // Check if this block is isolated (no neighbors)
                    let hasNeighbor = false;
                    
                    // Check adjacent cells
                    const neighbors = [
                        [row - 1, col], [row + 1, col],
                        [row, col - 1], [row, col + 1]
                    ];
                    
                    for (const [r, c] of neighbors) {
                        if (r >= 0 && r < 20 && c >= 0 && c < 10 && simplified[r][c] !== 0) {
                            hasNeighbor = true;
                            break;
                        }
                    }
                    
                    // Remove isolated blocks in upper rows (they're problematic)
                    if (!hasNeighbor && row < 10) {
                        simplified[row][col] = 0;
                    }
                }
            }
        }
        
        return simplified;
    }

    getLeaderboardCategory() {
        return 'puzzle';
    }

    supportsSaving() {
        return false; // Puzzles are quick challenges
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return '#ff8800';
    }
}
})();

/* scripts/modes/battleMode.js */
(function() {
// Battle Mode - Face off against intelligent AI opponents



window.BattleMode = class BattleMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Battle';
        this.description = 'Face off against intelligent AI opponents!';
        this.icon = '';
        this.themeColor = '#ff0000';
        
        // Battle settings
        this.aiDifficulty = 3; // Default to Hard
        this.roundsToWin = 2; // Best of 3
        this.currentRound = 1;
        this.playerWins = 0;
        this.aiWins = 0;
        
        // AI opponent
        this.ai = null;
        this.aiGrid = null;
        
        // Garbage lines system
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        
        // Power-ups
        this.powerUps = {
            freeze: { duration: 3000, cooldown: 20000 },
            bomb: { lines: 3, cooldown: 30000 },
            shield: { duration: 5000, cooldown: 25000 },
            speed: { multiplier: 2, duration: 5000, cooldown: 15000 }
        };
        this.activePowerUps = [];
        this.powerUpCooldowns = {};
        
        // Battle stats
        this.battleStats = {
            roundsPlayed: 0,
            totalDamageDealt: 0,
            totalDamageReceived: 0,
            powerUpsUsed: 0,
            maxCombo: 0
        };
    }

    initialize() {
        // Get selected difficulty from localStorage
        const savedDifficulty = localStorage.getItem('battle_ai_difficulty');
        if (savedDifficulty) {
            this.aiDifficulty = parseInt(savedDifficulty);
        }
        
        // Initialize AI opponent with selected difficulty
        this.ai = new TetrisAI(this.aiDifficulty);
        this.aiGrid = new Grid();
        
        // Reset battle state
        this.currentRound = 1;
        this.playerWins = 0;
        this.aiWins = 0;
        
        // Reset game state
        this.game.level = 1;
        this.game.lines = 0;
        this.game.score = 0;
        this.game.combo = 0;
        
        // Clear queues
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        this.activePowerUps = [];
        
        // Initialize power-up cooldowns
        Object.keys(this.powerUps).forEach(powerUp => {
            this.powerUpCooldowns[powerUp] = 0;
        });
        
        // Start round
        this.startRound();
    }

    startRound() {
        // Reset grids
        if (this.game.grid) {
            this.game.grid.reset();
        }
        this.aiGrid.reset();
        this.ai.reset();
        
        // Reset tracking
        this.lastAILines = 0;
        
        // Clear garbage
        this.playerGarbageQueue = [];
        this.aiGarbageQueue = [];
        
        // Show round message
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(
                `Round ${this.currentRound} - FIGHT!`,
                'battle',
                2000
            );
        }
        
        // Play battle music
        if (this.game.audioManager) {
            this.game.audioManager.startBackgroundMusic();
        }
    }

    update(deltaTime) {
        // Update AI with current game state
        if (this.ai) {
            // Give AI the current piece if needed
            if (this.game.currentPiece && !this.ai.currentPiece) {
                // Mirror player's piece sequence for fairness
                this.ai.setPiece(this.game.currentPiece);
            }
            
            this.ai.update(deltaTime);
            
            // Process AI moves
            const aiMove = this.ai.executeNextMove();
            if (aiMove) {
                this.processAIMove(aiMove);
            }
        }
        
        // Update power-ups
        this.updatePowerUps(deltaTime);
        
        // Update cooldowns
        this.updateCooldowns(deltaTime);
        
        // Process garbage lines
        this.processGarbageLines();
        
        // Check round end conditions
        if (this.checkRoundEnd()) {
            return false;
        }
        
        return true;
    }

    handlePiecePlaced() {
        // Battle mode tracks pieces for AI simulation
        this.battleStats.piecesPlaced = (this.battleStats.piecesPlaced || 0) + 1;
    }

    handleLineClears(linesCleared, specialClear) {
        if (!linesCleared || linesCleared === 0) {
            this.game.combo = 0;
            return;
        }
        
        // Update stats
        this.game.lines += linesCleared;
        this.game.combo++;
        
        if (this.game.combo > this.battleStats.maxCombo) {
            this.battleStats.maxCombo = this.game.combo;
        }
        
        // Calculate garbage to send
        let garbageLines = 0;
        switch (linesCleared) {
            case 1:
                garbageLines = 0;
                break;
            case 2:
                garbageLines = 1;
                break;
            case 3:
                garbageLines = 2;
                break;
            case 4:
                garbageLines = 4; // Tetris sends 4 lines
                break;
        }
        
        // Combo bonus
        if (this.game.combo > 2) {
            garbageLines += Math.floor(this.game.combo / 2);
        }
        
        // T-spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            garbageLines += 2;
        }
        
        // Perfect clear bonus
        if (specialClear && specialClear.type === 'perfectClear') {
            garbageLines += 6;
        }
        
        // Send garbage to AI
        if (garbageLines > 0) {
            this.sendGarbageToAI(garbageLines);
        }
        
        // Calculate score
        let score = linesCleared * 100 * this.game.level;
        if (specialClear) {
            score *= 2;
        }
        this.game.score += score;
    }

    sendGarbageToAI(lines) {
        // Check if shield is active
        const hasShield = this.activePowerUps.find(p => p.type === 'shield' && p.target === 'ai');
        if (hasShield) {
            lines = Math.floor(lines / 2);
        }
        
        if (lines > 0) {
            this.aiGarbageQueue.push(lines);
            this.ai.addGarbageLines(lines);
            this.battleStats.totalDamageDealt += lines;
            
            // Visual feedback
            if (this.game.uiManager) {
                this.game.uiManager.showDamage('ai', lines);
            }
        }
    }

    receiveGarbageFromAI(lines) {
        // Check if player has shield
        const hasShield = this.activePowerUps.find(p => p.type === 'shield' && p.target === 'player');
        if (hasShield) {
            lines = Math.floor(lines / 2);
        }
        
        if (lines > 0) {
            this.playerGarbageQueue.push(lines);
            this.battleStats.totalDamageReceived += lines;
            
            // Visual feedback
            if (this.game.uiManager) {
                this.game.uiManager.showDamage('player', lines);
            }
        }
    }

    processGarbageLines() {
        // Process player garbage
        if (this.playerGarbageQueue.length > 0 && this.game.grid) {
            const lines = this.playerGarbageQueue.shift();
            this.addGarbageLinesToGrid(this.game.grid, lines);
        }
        
        // Process AI garbage
        if (this.aiGarbageQueue.length > 0 && this.ai) {
            const lines = this.aiGarbageQueue.shift();
            // Let AI handle garbage intelligently
            this.ai.addGarbageLines(lines);
            this.ai.processGarbage();
        }
    }

    addGarbageLinesToGrid(grid, count) {
        for (let i = 0; i < count; i++) {
            // Remove top row
            grid.cells.shift();
            
            // Create garbage line with one hole
            const garbageLine = Array(grid.width).fill(8); // Gray blocks
            const hole = Math.floor(Math.random() * grid.width);
            garbageLine[hole] = 0;
            
            // Add to bottom
            grid.cells.push(garbageLine);
        }
    }

    processAIMove(move) {
        // Simulate AI playing
        switch (move) {
            case 'left':
            case 'right':
            case 'rotate':
                break;
            case 'drop':
                // AI placed a piece, update score
                if (this.ai) {
                    this.ai.score += 10; // Base points for piece placement
                }
                // Update AI grid visualization
                if (this.game.uiManager) {
                    this.game.uiManager.updateAIGrid(this.aiGrid);
                }
                break;
        }
        
        // Check if AI cleared lines
        const aiLines = this.checkAILineClears();
        if (aiLines > 0) {
            // Update AI score for line clears
            if (this.ai) {
                const baseScore = aiLines * 100;
                const levelMultiplier = Math.max(1, Math.floor(this.ai.lines / 10) + 1);
                this.ai.score += baseScore * levelMultiplier;
                
                // Bonus for special clears
                if (aiLines === 4) {
                    this.ai.score += 800; // Tetris bonus
                }
            }
            this.receiveGarbageFromAI(this.calculateGarbageFromLines(aiLines));
        }
    }

    checkAILineClears() {
        // Check actual AI line clears from AI state
        if (!this.ai) return 0;
        
        // The AI should track its own line clears
        const aiLines = this.ai.lines;
        const clearedThisTurn = aiLines - (this.lastAILines || 0);
        this.lastAILines = aiLines;
        
        return clearedThisTurn;
    }

    calculateGarbageFromLines(lines) {
        let garbage = 0;
        
        switch (lines) {
            case 1: 
                garbage = 0;
                break;
            case 2: 
                garbage = 1;
                break;
            case 3: 
                garbage = 2;
                break;
            case 4: 
                garbage = 4; // Tetris sends more
                break;
            default: 
                garbage = 0;
        }
        
        // Add combo multiplier if AI has combos
        if (this.ai && this.ai.combo > 1) {
            garbage += Math.floor(this.ai.combo / 2);
        }
        
        return garbage;
    }

    usePowerUp(type) {
        // Check cooldown
        if (this.powerUpCooldowns[type] > 0) {
            return false;
        }
        
        const powerUp = this.powerUps[type];
        if (!powerUp) return false;
        
        // Apply power-up effect
        switch (type) {
            case 'freeze':
                this.activateFreeze(powerUp.duration);
                break;
            case 'bomb':
                this.activateBomb(powerUp.lines);
                break;
            case 'shield':
                this.activateShield(powerUp.duration);
                break;
            case 'speed':
                this.activateSpeed(powerUp.multiplier, powerUp.duration);
                break;
        }
        
        // Set cooldown
        this.powerUpCooldowns[type] = powerUp.cooldown;
        this.battleStats.powerUpsUsed++;
        
        return true;
    }

    activateFreeze(duration) {
        this.activePowerUps.push({
            type: 'freeze',
            target: 'ai',
            duration: duration,
            remaining: duration
        });
        
        // Freeze AI
        this.ai.params.thinkingDelay *= 3;
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('freeze', 'ai');
        }
    }

    activateBomb(lines) {
        // Clear random lines from AI grid
        for (let i = 0; i < lines && i < this.aiGrid.cells.length; i++) {
            const row = Math.floor(Math.random() * this.aiGrid.cells.length);
            this.aiGrid.cells[row] = Array(this.aiGrid.width).fill(0);
        }
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('bomb', 'ai');
        }
    }

    activateShield(duration) {
        this.activePowerUps.push({
            type: 'shield',
            target: 'player',
            duration: duration,
            remaining: duration
        });
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('shield', 'player');
        }
    }

    activateSpeed(multiplier, duration) {
        this.activePowerUps.push({
            type: 'speed',
            target: 'player',
            duration: duration,
            remaining: duration,
            multiplier: multiplier
        });
        
        // Speed up player drop rate
        this.game.dropInterval /= multiplier;
        
        if (this.game.uiManager) {
            this.game.uiManager.showPowerUp('speed', 'player');
        }
    }

    updatePowerUps(deltaTime) {
        this.activePowerUps = this.activePowerUps.filter(powerUp => {
            powerUp.remaining -= deltaTime;
            
            if (powerUp.remaining <= 0) {
                // Remove power-up effect
                this.removePowerUpEffect(powerUp);
                return false;
            }
            return true;
        });
    }

    removePowerUpEffect(powerUp) {
        switch (powerUp.type) {
            case 'freeze':
                // Restore AI speed
                if (this.ai) {
                    this.ai.setupDifficultyParams();
                }
                break;
            case 'speed':
                // Restore player speed
                this.game.dropInterval *= powerUp.multiplier;
                break;
        }
    }

    updateCooldowns(deltaTime) {
        Object.keys(this.powerUpCooldowns).forEach(key => {
            if (this.powerUpCooldowns[key] > 0) {
                this.powerUpCooldowns[key] = Math.max(0, this.powerUpCooldowns[key] - deltaTime);
            }
        });
    }

    checkRoundEnd() {
        // Check if player lost
        if (this.game.grid && this.game.grid.checkGameOver()) {
            this.aiWins++;
            this.endRound(false);
            return true;
        }
        
        // Check if AI lost (simplified)
        if (this.aiGrid && this.aiGrid.checkGameOver()) {
            this.playerWins++;
            this.endRound(true);
            return true;
        }
        
        return false;
    }

    endRound(playerWon) {
        this.battleStats.roundsPlayed++;
        
        // Show round result
        if (this.game.uiManager) {
            this.game.uiManager.showRoundResult(
                playerWon,
                this.currentRound,
                this.playerWins,
                this.aiWins
            );
        }
        
        // Check if match is over
        if (this.playerWins >= this.roundsToWin) {
            this.endMatch(true);
        } else if (this.aiWins >= this.roundsToWin) {
            this.endMatch(false);
        } else {
            // Start next round
            this.currentRound++;
            setTimeout(() => this.startRound(), 3000);
        }
    }

    endMatch(playerWon) {
        this.isComplete = true;
        
        const result = {
            won: playerWon,
            rounds: this.battleStats.roundsPlayed,
            playerWins: this.playerWins,
            aiWins: this.aiWins,
            totalDamageDealt: this.battleStats.totalDamageDealt,
            totalDamageReceived: this.battleStats.totalDamageReceived,
            powerUpsUsed: this.battleStats.powerUpsUsed,
            aiDifficulty: this.aiDifficulty
        };
        
        // Save battle stats
        this.saveBattleStats(result);
        
        // Show match result
        if (this.game.uiManager) {
            this.game.uiManager.showMatchResult(result);
        }
        
        return result;
    }

    saveBattleStats(stats) {
        const key = 'tetris_battle_stats';
        let allStats = [];
        
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                allStats = JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load battle stats:', e);
            }
        }
        
        allStats.push({
            ...stats,
            timestamp: Date.now()
        });
        
        // Keep only last 50 battles
        if (allStats.length > 50) {
            allStats = allStats.slice(-50);
        }
        
        localStorage.setItem(key, JSON.stringify(allStats));
    }

    setDifficulty(difficulty) {
        this.aiDifficulty = Math.max(1, Math.min(5, difficulty));
        if (this.ai) {
            this.ai.difficulty = this.aiDifficulty;
            this.ai.setupDifficultyParams();
        }
    }

    getObjective() {
        return `Win ${this.roundsToWin} rounds! (${this.playerWins}-${this.aiWins})`;
    }

    getModeUI() {
        return {
            showScore: true,
            showLines: true,
            showLevel: false,
            showHold: true,
            showNext: true,
            showTimer: false,
            showObjective: true,
            showBattleGrid: true, // Special flag for battle mode
            customDisplay: {
                round: `Round ${this.currentRound}`,
                playerWins: this.playerWins,
                aiWins: this.aiWins,
                playerScore: this.game.score,
                aiScore: this.ai ? this.ai.score : 0,
                aiLines: this.ai ? this.ai.lines : 0,
                aiDifficulty: ['Easy', 'Normal', 'Hard', 'Expert', 'Grandmaster'][this.aiDifficulty - 1],
                powerUps: this.getAvailablePowerUps()
            }
        };
    }

    getAvailablePowerUps() {
        const available = [];
        Object.keys(this.powerUps).forEach(key => {
            available.push({
                type: key,
                ready: this.powerUpCooldowns[key] === 0,
                cooldown: Math.ceil(this.powerUpCooldowns[key] / 1000)
            });
        });
        return available;
    }

    handleInput(action) {
        // Handle power-up inputs
        switch (action) {
            case 'powerUp1':
                return this.usePowerUp('freeze');
            case 'powerUp2':
                return this.usePowerUp('bomb');
            case 'powerUp3':
                return this.usePowerUp('shield');
            case 'powerUp4':
                return this.usePowerUp('speed');
        }
        return false;
    }

    getLeaderboardCategory() {
        return `battle_${this.aiDifficulty}`;
    }

    supportsSaving() {
        return false; // Battle mode is match-based
    }

    getIcon() {
        return '';
    }

    getThemeColor() {
        return '#ff0000';
    }
}
})();

/* scripts/modes/battle2PMode.js */
(function() {
// Local 2-Player Battle Mode



window.Battle2PMode = class Battle2PMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Battle 2P';
        this.description = 'Local 2-player competitive Tetris!';
        this.icon = '';
        this.themeColor = '#ff00ff';
        
        // Player states
        this.players = {
            p1: {
                grid: null,
                score: 0,
                lines: 0,
                level: 1,
                currentPiece: null,
                nextPieces: [],
                holdPiece: null,
                canHold: true,
                dropTimer: 0,
                dropInterval: 1000,
                combo: 0,
                garbage: [],
                attacks: [],
                defenses: [],
                ko: false,
                wins: 0,
                stats: {
                    piecesPlaced: 0,
                    linesCleared: 0,
                    attacks: 0,
                    defenses: 0,
                    tspins: 0,
                    tetris: 0
                }
            },
            p2: {
                grid: null,
                score: 0,
                lines: 0,
                level: 1,
                currentPiece: null,
                nextPieces: [],
                holdPiece: null,
                canHold: true,
                dropTimer: 0,
                dropInterval: 1000,
                combo: 0,
                garbage: [],
                attacks: [],
                defenses: [],
                ko: false,
                wins: 0,
                stats: {
                    piecesPlaced: 0,
                    linesCleared: 0,
                    attacks: 0,
                    defenses: 0,
                    tspins: 0,
                    tetris: 0
                }
            }
        };
        
        // Battle settings
        this.roundNumber = 1;
        this.maxRounds = 3; // First to 2 wins
        this.roundTimer = 120; // 2 minutes per round
        this.roundStartTime = null;
        this.battleOver = false;
        
        // Garbage settings
        this.garbageMultiplier = 1.0;
        this.attackDelay = 500; // ms delay before garbage appears
        
        // Controls mapping
        this.controls = {
            p1: {
                left: 'ArrowLeft',
                right: 'ArrowRight',
                down: 'ArrowDown',
                rotate: 'ArrowUp',
                rotateCC: 'z',
                hardDrop: ' ',
                hold: 'Shift'
            },
            p2: {
                left: 'a',
                right: 'd',
                down: 's',
                rotate: 'w',
                rotateCC: 'q',
                hardDrop: 'e',
                hold: 'r'
            }
        };
        
        // Visual separation
        this.splitScreen = true;
        this.centerDivider = true;
    }
    
    async initialize() {
        // Create grids for both players
        this.players.p1.grid = new Grid(10, 20);
        this.players.p2.grid = new Grid(10, 20);
        
        // Initialize pieces for both players
        this.initializePlayer('p1');
        this.initializePlayer('p2');
        
        // Start round
        this.startRound();
        
        // Show instructions
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(
                'Battle Mode - First to 2 wins! P1: Arrows | P2: WASD',
                'info',
                3000
            );
        }
    }
    
    initializePlayer(playerId) {
        const player = this.players[playerId];
        
        // Reset player state
        player.score = 0;
        player.lines = 0;
        player.level = 1;
        player.combo = 0;
        player.garbage = [];
        player.attacks = [];
        player.defenses = [];
        player.ko = false;
        
        // Generate piece bag
        player.nextPieces = this.generatePieceBag();
        player.currentPiece = this.getNextPiece(playerId);
        
        // Position piece
        if (player.currentPiece) {
            player.currentPiece.x = Math.floor((10 - player.currentPiece.shape[0].length) / 2);
            player.currentPiece.y = 0;
        }
    }
    
    startRound() {
        this.roundStartTime = Date.now();
        
        // Clear grids
        this.players.p1.grid.clear();
        this.players.p2.grid.clear();
        
        // Reset round-specific stats
        ['p1', 'p2'].forEach(playerId => {
            const player = this.players[playerId];
            player.stats.piecesPlaced = 0;
            player.stats.linesCleared = 0;
            player.stats.attacks = 0;
            player.stats.defenses = 0;
        });
        
        // Announce round
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(
                `Round ${this.roundNumber} - FIGHT!`,
                'battle',
                2000
            );
        }
    }
    
    update(deltaTime) {
        if (this.battleOver) return false;
        
        // Update both players
        this.updatePlayer('p1', deltaTime);
        this.updatePlayer('p2', deltaTime);
        
        // Process garbage queue
        this.processGarbage('p1');
        this.processGarbage('p2');
        
        // Check round timer
        if (this.roundTimer > 0) {
            const elapsed = (Date.now() - this.roundStartTime) / 1000;
            if (elapsed >= this.roundTimer) {
                this.endRoundByTimeout();
            }
        }
        
        // Check for KO
        if (this.players.p1.ko || this.players.p2.ko) {
            this.endRound();
        }
        
        return true;
    }
    
    updatePlayer(playerId, deltaTime) {
        const player = this.players[playerId];
        
        if (player.ko) return;
        
        // Update drop timer
        player.dropTimer += deltaTime;
        
        // Auto drop
        if (player.dropTimer >= player.dropInterval) {
            player.dropTimer = 0;
            this.movePlayerPiece(playerId, 0, 1);
        }
        
        // Check for topped out
        if (this.isPlayerToppedOut(playerId)) {
            player.ko = true;
        }
    }
    
    handleInput(event) {
        // Handle P1 controls
        if (this.handlePlayerInput('p1', event.key)) {
            event.preventDefault();
            return true;
        }
        
        // Handle P2 controls
        if (this.handlePlayerInput('p2', event.key)) {
            event.preventDefault();
            return true;
        }
        
        return false;
    }
    
    handlePlayerInput(playerId, key) {
        const player = this.players[playerId];
        const controls = this.controls[playerId];
        
        if (player.ko) return false;
        
        switch(key) {
            case controls.left:
                this.movePlayerPiece(playerId, -1, 0);
                return true;
                
            case controls.right:
                this.movePlayerPiece(playerId, 1, 0);
                return true;
                
            case controls.down:
                this.movePlayerPiece(playerId, 0, 1);
                player.score += 1; // Soft drop points
                return true;
                
            case controls.rotate:
                this.rotatePlayerPiece(playerId, 1);
                return true;
                
            case controls.rotateCC:
                this.rotatePlayerPiece(playerId, -1);
                return true;
                
            case controls.hardDrop:
                this.hardDropPlayerPiece(playerId);
                return true;
                
            case controls.hold:
                this.holdPlayerPiece(playerId);
                return true;
        }
        
        return false;
    }
    
    movePlayerPiece(playerId, dx, dy) {
        const player = this.players[playerId];
        if (!player.currentPiece) return false;
        
        // Check if move is valid
        const newX = player.currentPiece.x + dx;
        const newY = player.currentPiece.y + dy;
        
        if (this.isValidPosition(playerId, player.currentPiece.shape, newX, newY)) {
            player.currentPiece.x = newX;
            player.currentPiece.y = newY;
            return true;
        } else if (dy > 0) {
            // Piece can't move down, lock it
            this.lockPlayerPiece(playerId);
        }
        
        return false;
    }
    
    rotatePlayerPiece(playerId, direction) {
        const player = this.players[playerId];
        if (!player.currentPiece) return false;
        
        // Rotate shape
        const rotated = this.rotateMatrix(player.currentPiece.shape, direction);
        
        // Try wall kicks
        const kicks = this.getWallKicks(player.currentPiece.type, direction);
        
        for (const [dx, dy] of kicks) {
            const newX = player.currentPiece.x + dx;
            const newY = player.currentPiece.y + dy;
            
            if (this.isValidPosition(playerId, rotated, newX, newY)) {
                player.currentPiece.shape = rotated;
                player.currentPiece.x = newX;
                player.currentPiece.y = newY;
                return true;
            }
        }
        
        return false;
    }
    
    hardDropPlayerPiece(playerId) {
        const player = this.players[playerId];
        if (!player.currentPiece) return;
        
        let dropDistance = 0;
        while (this.movePlayerPiece(playerId, 0, 1)) {
            dropDistance++;
        }
        
        // Award hard drop points
        player.score += dropDistance * 2;
    }
    
    holdPlayerPiece(playerId) {
        const player = this.players[playerId];
        if (!player.canHold || !player.currentPiece) return false;
        
        const held = player.currentPiece;
        
        if (player.holdPiece) {
            // Swap with hold
            player.currentPiece = player.holdPiece;
            player.holdPiece = held;
        } else {
            // Put in hold and get next
            player.holdPiece = held;
            player.currentPiece = this.getNextPiece(playerId);
        }
        
        // Reset position
        if (player.currentPiece) {
            player.currentPiece.x = Math.floor((10 - player.currentPiece.shape[0].length) / 2);
            player.currentPiece.y = 0;
        }
        
        player.canHold = false;
        return true;
    }
    
    lockPlayerPiece(playerId) {
        const player = this.players[playerId];
        if (!player.currentPiece) return;
        
        // Place piece on grid
        this.placePieceOnGrid(
            player.grid,
            player.currentPiece.shape,
            player.currentPiece.x,
            player.currentPiece.y,
            player.currentPiece.type
        );
        
        // Update stats
        player.stats.piecesPlaced++;
        
        // Check for line clears
        const clearedLines = this.checkLineClears(playerId);
        
        // Get next piece
        player.currentPiece = this.getNextPiece(playerId);
        player.canHold = true;
        
        // Reset drop timer
        player.dropTimer = 0;
    }
    
    checkLineClears(playerId) {
        const player = this.players[playerId];
        const clearedLines = [];
        
        // Check each row
        for (let y = player.grid.height - 1; y >= 0; y--) {
            let complete = true;
            for (let x = 0; x < player.grid.width; x++) {
                if (player.grid.cells[y][x] === 0) {
                    complete = false;
                    break;
                }
            }
            
            if (complete) {
                clearedLines.push(y);
            }
        }
        
        if (clearedLines.length > 0) {
            // Clear the lines
            clearedLines.forEach(y => {
                player.grid.cells.splice(y, 1);
                player.grid.cells.unshift(new Array(player.grid.width).fill(0));
            });
            
            // Update stats
            player.lines += clearedLines.length;
            player.stats.linesCleared += clearedLines.length;
            
            // Calculate attack
            const attack = this.calculateAttack(playerId, clearedLines.length);
            
            // Send garbage to opponent
            const opponentId = playerId === 'p1' ? 'p2' : 'p1';
            this.sendGarbage(opponentId, attack);
            
            // Update combo
            player.combo++;
            
            // Score calculation
            const baseScore = [0, 100, 300, 500, 800][clearedLines.length];
            player.score += baseScore * player.level * (1 + player.combo * 0.1);
            
            // Check for special clears
            if (clearedLines.length === 4) {
                player.stats.tetris++;
                this.showPlayerMessage(playerId, 'TETRIS!');
            }
        } else {
            // Reset combo
            player.combo = 0;
        }
        
        return clearedLines;
    }
    
    calculateAttack(playerId, linesCleared) {
        const player = this.players[playerId];
        let attack = 0;
        
        // Base attack values
        const attackTable = [0, 0, 1, 2, 4]; // 0, 1, 2, 3, 4 lines
        attack = attackTable[Math.min(linesCleared, 4)];
        
        // Combo multiplier
        if (player.combo > 1) {
            attack += Math.floor(player.combo / 2);
        }
        
        // T-Spin bonus
        // Would need T-spin detection here
        
        // Perfect clear bonus
        if (this.isGridEmpty(player.grid)) {
            attack += 10;
            this.showPlayerMessage(playerId, 'PERFECT CLEAR!');
        }
        
        player.stats.attacks += attack;
        
        return attack;
    }
    
    sendGarbage(playerId, amount) {
        if (amount <= 0) return;
        
        const player = this.players[playerId];
        
        // Add to garbage queue with delay
        player.garbage.push({
            amount: amount,
            timestamp: Date.now() + this.attackDelay
        });
    }
    
    processGarbage(playerId) {
        const player = this.players[playerId];
        const now = Date.now();
        
        // Process ready garbage
        player.garbage = player.garbage.filter(g => {
            if (g.timestamp <= now) {
                this.addGarbageLines(playerId, g.amount);
                return false;
            }
            return true;
        });
    }
    
    addGarbageLines(playerId, amount) {
        const player = this.players[playerId];
        
        // Remove top lines
        for (let i = 0; i < amount; i++) {
            player.grid.cells.shift();
        }
        
        // Add garbage lines at bottom
        for (let i = 0; i < amount; i++) {
            const garbageLine = new Array(player.grid.width).fill(8); // Gray blocks
            
            // Add one random hole
            const holePosition = Math.floor(Math.random() * player.grid.width);
            garbageLine[holePosition] = 0;
            
            player.grid.cells.push(garbageLine);
        }
        
        // Show warning
        this.showPlayerMessage(playerId, `+${amount} GARBAGE!`);
    }
    
    isValidPosition(playerId, shape, x, y) {
        const player = this.players[playerId];
        
        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col] !== 0) {
                    const gridX = x + col;
                    const gridY = y + row;
                    
                    // Check boundaries
                    if (gridX < 0 || gridX >= player.grid.width ||
                        gridY < 0 || gridY >= player.grid.height) {
                        return false;
                    }
                    
                    // Check collision
                    if (player.grid.cells[gridY][gridX] !== 0) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    isPlayerToppedOut(playerId) {
        const player = this.players[playerId];
        
        // Check if any blocks in top 2 rows
        for (let y = 0; y < 2; y++) {
            for (let x = 0; x < player.grid.width; x++) {
                if (player.grid.cells[y][x] !== 0) {
                    return true;
                }
            }
        }
        return false;
    }
    
    isGridEmpty(grid) {
        for (let y = 0; y < grid.height; y++) {
            for (let x = 0; x < grid.width; x++) {
                if (grid.cells[y][x] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    
    endRound() {
        // Determine winner
        let winnerId = null;
        if (this.players.p1.ko && !this.players.p2.ko) {
            winnerId = 'p2';
        } else if (this.players.p2.ko && !this.players.p1.ko) {
            winnerId = 'p1';
        } else {
            // Both KO or timeout - highest score wins
            winnerId = this.players.p1.score > this.players.p2.score ? 'p1' : 'p2';
        }
        
        // Award round win
        this.players[winnerId].wins++;
        
        // Show round result
        if (this.game.uiManager) {
            const winnerName = winnerId === 'p1' ? 'Player 1' : 'Player 2';
            this.game.uiManager.showMessage(
                `${winnerName} wins Round ${this.roundNumber}!`,
                'success',
                3000
            );
        }
        
        // Check for match winner
        if (this.players[winnerId].wins >= 2) {
            this.endBattle(winnerId);
        } else {
            // Start next round
            this.roundNumber++;
            setTimeout(() => {
                this.initializePlayer('p1');
                this.initializePlayer('p2');
                this.startRound();
            }, 3000);
        }
    }
    
    endRoundByTimeout() {
        // Highest score wins
        const winnerId = this.players.p1.score > this.players.p2.score ? 'p1' : 'p2';
        this.players[winnerId].wins++;
        this.endRound();
    }
    
    endBattle(winnerId) {
        this.battleOver = true;
        
        const winnerName = winnerId === 'p1' ? 'Player 1' : 'Player 2';
        const loserName = winnerId === 'p1' ? 'Player 2' : 'Player 1';
        
        // Calculate final stats
        const results = {
            winner: winnerName,
            loser: loserName,
            rounds: this.roundNumber,
            p1Stats: this.players.p1.stats,
            p2Stats: this.players.p2.stats,
            p1Score: this.players.p1.score,
            p2Score: this.players.p2.score
        };
        
        // Show victory screen
        if (this.game.uiManager) {
            this.game.uiManager.showBattleVictory(results);
        }
        
        // Trigger game over
        if (this.game) {
            this.game.battleResults = results;
            this.game.gameOver();
        }
    }
    
    showPlayerMessage(playerId, message) {
        // Show message above player's grid
        if (this.game.uiManager) {
            const side = playerId === 'p1' ? 'left' : 'right';
            this.game.uiManager.showSideMessage(message, side, 1000);
        }
    }
    
    getNextPiece(playerId) {
        const player = this.players[playerId];
        
        if (player.nextPieces.length < 7) {
            player.nextPieces.push(...this.generatePieceBag());
        }
        
        const pieceType = player.nextPieces.shift();
        return new Piece(pieceType);
    }
    
    generatePieceBag() {
        const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        const shuffled = [...pieces];
        
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        
        return shuffled;
    }
    
    rotateMatrix(matrix, direction) {
        const n = matrix.length;
        const rotated = Array(n).fill(null).map(() => Array(n).fill(0));
        
        if (direction > 0) {
            // Clockwise
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    rotated[j][n - 1 - i] = matrix[i][j];
                }
            }
        } else {
            // Counter-clockwise
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    rotated[n - 1 - j][i] = matrix[i][j];
                }
            }
        }
        
        return rotated;
    }
    
    getWallKicks(pieceType, direction) {
        // Basic wall kick data
        if (pieceType === 'I') {
            return [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]];
        } else if (pieceType === 'O') {
            return [[0, 0]]; // O piece doesn't kick
        } else {
            return [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]];
        }
    }
    
    placePieceOnGrid(grid, shape, x, y, type) {
        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col] !== 0) {
                    const gridY = y + row;
                    const gridX = x + col;
                    
                    if (gridY >= 0 && gridY < grid.height &&
                        gridX >= 0 && gridX < grid.width) {
                        grid.cells[gridY][gridX] = shape[row][col];
                    }
                }
            }
        }
    }
    
    render(ctx) {
        // This would need custom rendering for split-screen
        // The main game.js render would need to be modified to support this
        
        // For now, return render instructions
        return {
            mode: 'split-screen',
            players: {
                p1: {
                    grid: this.players.p1.grid,
                    currentPiece: this.players.p1.currentPiece,
                    score: this.players.p1.score,
                    lines: this.players.p1.lines,
                    wins: this.players.p1.wins
                },
                p2: {
                    grid: this.players.p2.grid,
                    currentPiece: this.players.p2.currentPiece,
                    score: this.players.p2.score,
                    lines: this.players.p2.lines,
                    wins: this.players.p2.wins
                }
            }
        };
    }
    
    getObjective() {
        return `Round ${this.roundNumber} - First to 2 wins!`;
    }
    
    getModeUI() {
        return {
            showScore: false, // Custom score display
            showLines: false, // Custom lines display
            showLevel: false,
            showHold: false, // Custom hold display
            showNext: false, // Custom next display
            showTimer: true,
            showObjective: true,
            customDisplay: {
                mode: 'battle-2p',
                p1Wins: this.players.p1.wins,
                p2Wins: this.players.p2.wins,
                round: this.roundNumber
            }
        };
    }
    
    pause() {
        super.pause();
    }
    
    resume() {
        super.resume();
    }
    
    cleanup() {
        // Clean up any mode-specific resources
    }
    
    getLeaderboardCategory() {
        return 'battle2p';
    }
    
    supportsSaving() {
        return false; // Multiplayer can't be saved
    }
}
})();

/* scripts/modes/powerUpMode.js */
(function() {
// Power-Up Mode - Classic gameplay with power-ups


window.PowerUpMode = class PowerUpMode extends GameMode {
    constructor(game) {
        super(game);
        this.name = 'Power-Up';
        this.description = 'Classic Tetris with exciting power-ups!';
        this.icon = '';
        this.themeColor = '#ff00ff';
        
        // Power-up manager
        this.powerUpManager = new PowerUpManager(game);
        
        // Track accomplishments
        this.linesSinceLastPowerUp = 0;
        this.lastCombo = 0;
        this.consecutiveTSpins = 0;
    }
    
    initialize() {
        // Reset game state
        this.game.score = 0;
        this.game.lines = 0;
        this.game.level = 1;
        this.game.combo = 0;
        
        // Initialize power-up manager
        this.powerUpManager.initialize();
        
        // Reset tracking
        this.linesSinceLastPowerUp = 0;
        this.lastCombo = 0;
        this.consecutiveTSpins = 0;
        
        // Set initial drop speed
        this.updateDropSpeed();
        
        // Show instructions
        if (this.game.uiManager) {
            this.game.uiManager.showMessage(
                'Power-Up Mode! Press Q/E to use power-ups',
                'powerup',
                3000
            );
        }
    }
    
    update(deltaTime) {
        // Update power-up manager
        this.powerUpManager.update(deltaTime);
        
        // Update active power-ups display
        this.powerUpManager.updateActivePowerUpsDisplay();
        
        // Check for level progression
        const newLevel = Math.floor(this.game.lines / 10) + 1;
        if (newLevel > this.game.level) {
            this.game.level = newLevel;
            this.updateDropSpeed();
            
            // Bonus power-up every 5 levels
            if (this.game.level % 5 === 0) {
                this.powerUpManager.generatePowerUp();
                this.powerUpManager.generatePowerUp();
            }
        }
        
        return true; // Continue game
    }
    
    handleLineClears(linesCleared, specialClear) {
        if (linesCleared === 0) return;
        
        // Track lines
        this.linesSinceLastPowerUp += linesCleared;
        
        // Check for Tetris
        if (linesCleared === 4) {
            this.powerUpManager.checkAccomplishments('lines_cleared', { count: 4, total: this.game.lines });
        }
        
        // Check for T-Spin
        if (specialClear && specialClear.type === 'tspin') {
            this.consecutiveTSpins++;
            this.powerUpManager.checkAccomplishments('tspin', this.consecutiveTSpins);
        } else {
            this.consecutiveTSpins = 0;
        }
        
        // Check for perfect clear
        if (this.game.grid && this.game.grid.isEmpty()) {
            this.powerUpManager.checkAccomplishments('perfect_clear', true);
        }
        
        // Check lines milestones
        this.powerUpManager.checkAccomplishments('lines_cleared', { 
            count: linesCleared, 
            total: this.game.lines 
        });
        
        // Calculate score with multiplier
        let baseScore = this.calculateLineScore(linesCleared, specialClear);
        const multiplier = this.game.scoreMultiplier || 1;
        const score = Math.floor(baseScore * multiplier);
        
        this.game.score += score;
        
        // Check score milestones
        this.powerUpManager.checkAccomplishments('score', this.game.score);
        
        // Update combo
        if (linesCleared > 0) {
            this.game.combo++;
            
            // Check combo milestones
            if (this.game.combo >= 5) {
                this.powerUpManager.checkAccomplishments('combo', this.game.combo);
            }
        } else {
            this.game.combo = 0;
        }
    }
    
    calculateLineScore(lines, specialClear) {
        const baseScores = [0, 100, 300, 500, 800];
        let score = baseScores[Math.min(lines, 4)] * this.game.level;
        
        // T-Spin bonus
        if (specialClear && specialClear.type === 'tspin') {
            score += specialClear.mini ? 200 : 400;
        }
        
        // Combo bonus
        if (this.game.combo > 1) {
            score += 50 * this.game.combo * this.game.level;
        }
        
        return score;
    }
    
    updateDropSpeed() {
        // Base speed increases with level
        const baseInterval = 1000;
        const speedIncrease = 50;
        this.game.dropInterval = Math.max(50, baseInterval - (this.game.level - 1) * speedIncrease);
    }
    
    getObjective() {
        return `Score as many points as possible with power-ups!`;
    }
    
    getModeUI() {
        return `
            <div class="powerup-slots" id="powerup-slots">
                <div class="powerup-slot" id="powerup-slot-0" data-slot="0">
                    <div class="powerup-key">Q</div>
                    <div class="powerup-empty">Empty</div>
                </div>
                <div class="powerup-slot" id="powerup-slot-1" data-slot="1">
                    <div class="powerup-key">E</div>
                    <div class="powerup-empty">Empty</div>
                </div>
            </div>
            <div class="active-powerups" id="active-powerups"></div>
        `;
    }
    
    handleKeyPress(key) {
        // Handle power-up activation
        switch(key.toUpperCase()) {
            case 'Q':
                this.powerUpManager.activatePowerUp(0);
                return true;
            case 'E':
                this.powerUpManager.activatePowerUp(1);
                return true;
        }
        return false;
    }
    
    handlePiecePlaced() {
        // Standard piece placement handling
        // Power-ups are checked in handleLineClears
    }
    
    checkGameOver() {
        // Check if any pieces are above row 0
        if (this.game.grid) {
            for (let x = 0; x < this.game.grid.width; x++) {
                if (this.game.grid.cells[0][x] !== 0) {
                    return true;
                }
            }
        }
        return false;
    }
    
    onGameOver() {
        // Save high score
        const stats = {
            mode: 'powerup',
            score: this.game.score,
            lines: this.game.lines,
            level: this.game.level,
            powerUpsUsed: this.powerUpManager.activePowerUps.length,
            maxCombo: this.game.combo
        };
        
        return {
            title: 'Game Over!',
            stats: stats,
            showLeaderboard: true
        };
    }
    
    // Save/Load state for offline support
    getState() {
        return {
            score: this.game.score,
            lines: this.game.lines,
            level: this.game.level,
            combo: this.game.combo,
            powerUpState: this.powerUpManager.getState(),
            linesSinceLastPowerUp: this.linesSinceLastPowerUp,
            consecutiveTSpins: this.consecutiveTSpins
        };
    }
    
    loadState(state) {
        if (state) {
            this.game.score = state.score || 0;
            this.game.lines = state.lines || 0;
            this.game.level = state.level || 1;
            this.game.combo = state.combo || 0;
            this.linesSinceLastPowerUp = state.linesSinceLastPowerUp || 0;
            this.consecutiveTSpins = state.consecutiveTSpins || 0;
            
            if (state.powerUpState) {
                this.powerUpManager.loadState(state.powerUpState);
            }
            
            this.updateDropSpeed();
        }
    }
}
})();

/* scripts/ai/tetrisAI.js */
(function() {
// Tetris AI - Intelligent opponent for Battle Mode

window.TetrisAI = class TetrisAI {
    constructor(difficulty = 3) {
        this.difficulty = difficulty; // 1-5 (Easy to Grandmaster)
        this.grid = this.createEmptyGrid();
        this.currentPiece = null;
        this.nextPieces = [];
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.garbageQueue = [];
        this.combo = 0;
        this.lastClearWasLine = false;
        this.recentMoves = [];
        
        // AI parameters based on difficulty
        this.setupDifficultyParams();
        
        // Decision making
        this.thinkingTime = 0;
        this.currentMove = null;
        this.moveQueue = [];
    }
    
    setupDifficultyParams() {
        switch (this.difficulty) {
            case 1: // Easy
                this.params = {
                    thinkingDelay: 800,
                    mistakeRate: 0.3,
                    lookAhead: 0,
                    evaluationWeights: {
                        height: -0.5,
                        holes: -3,
                        bumpiness: -0.2,
                        lines: 10,
                        wells: 0,
                        tspinSetup: 0,
                        tetrisWell: 0,
                        perfectClear: 0,
                        combo: 2
                    },
                    dropSpeed: 1000,
                    garbageDefenseSkill: 0.3
                };
                break;
                
            case 2: // Normal
                this.params = {
                    thinkingDelay: 500,
                    mistakeRate: 0.15,
                    lookAhead: 1,
                    evaluationWeights: {
                        height: -0.8,
                        holes: -5,
                        bumpiness: -0.5,
                        lines: 15,
                        wells: 0.5,
                        tspinSetup: 2,
                        tetrisWell: 1,
                        perfectClear: 10,
                        combo: 5
                    },
                    dropSpeed: 700,
                    garbageDefenseSkill: 0.5
                };
                break;
                
            case 3: // Hard
                this.params = {
                    thinkingDelay: 300,
                    mistakeRate: 0.08,
                    lookAhead: 1,
                    evaluationWeights: {
                        height: -1,
                        holes: -8,
                        bumpiness: -0.8,
                        lines: 20,
                        wells: 1,
                        tspinSetup: 5,
                        tetrisWell: 2,
                        perfectClear: 25,
                        combo: 8
                    },
                    dropSpeed: 400,
                    garbageDefenseSkill: 0.7
                };
                break;
                
            case 4: // Expert
                this.params = {
                    thinkingDelay: 150,
                    mistakeRate: 0.03,
                    lookAhead: 2,
                    evaluationWeights: {
                        height: -1.2,
                        holes: -10,
                        bumpiness: -1,
                        lines: 25,
                        wells: 2,
                        tspinSetup: 8,
                        tetrisWell: 3,
                        perfectClear: 40,
                        combo: 12
                    },
                    dropSpeed: 200,
                    garbageDefenseSkill: 0.85
                };
                break;
                
            case 5: // Grandmaster
                this.params = {
                    thinkingDelay: 50,
                    mistakeRate: 0.01,
                    lookAhead: 3,
                    evaluationWeights: {
                        height: -1.5,
                        holes: -15,
                        bumpiness: -1.2,
                        lines: 30,
                        wells: 3,
                        tspinSetup: 10,
                        tetrisWell: 5,
                        perfectClear: 50,
                        combo: 15
                    },
                    dropSpeed: 100,
                    garbageDefenseSkill: 0.95
                };
                break;
        }
    }
    
    createEmptyGrid() {
        return Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
    }
    
    update(deltaTime) {
        // Ensure grid is initialized
        if (!this.grid || !Array.isArray(this.grid) || this.grid.length === 0) {
            this.grid = this.createEmptyGrid();
        }
        
        this.thinkingTime += deltaTime;
        
        // Process garbage lines
        if (this.garbageQueue.length > 0 && Math.random() < this.params.garbageDefenseSkill) {
            this.processGarbage();
        }
        
        // Make decision if enough thinking time has passed
        if (this.thinkingTime >= this.params.thinkingDelay) {
            this.thinkingTime = 0;
            
            if (!this.currentMove && this.currentPiece) {
                this.decideBestMove();
            }
            
            if (this.currentMove) {
                this.executeNextMove();
            }
        }
    }
    
    setPiece(piece) {
        this.currentPiece = piece;
        this.currentMove = null;
        this.moveQueue = [];
    }
    
    decideBestMove() {
        if (!this.currentPiece) return;
        
        const moves = this.getAllPossibleMoves(this.currentPiece);
        let bestMove = null;
        let bestScore = -Infinity;
        
        for (let move of moves) {
            const score = this.evaluateMove(move);
            
            // Add randomness based on difficulty
            const randomFactor = (Math.random() - 0.5) * (5 - this.difficulty) * 10;
            const finalScore = score + randomFactor;
            
            if (finalScore > bestScore) {
                bestScore = finalScore;
                bestMove = move;
            }
        }
        
        // Chance to make a mistake
        if (Math.random() < this.params.mistakeRate) {
            bestMove = moves[Math.floor(Math.random() * moves.length)];
        }
        
        this.currentMove = bestMove;
        if (bestMove) {
            this.generateMoveSequence(bestMove);
        }
    }
    
    getAllPossibleMoves(piece) {
        const moves = [];
        const rotations = 4; // All possible rotations
        
        for (let rotation = 0; rotation < rotations; rotation++) {
            const rotatedPiece = this.rotatePiece(piece, rotation);
            
            for (let x = -2; x < GRID_WIDTH + 2; x++) {
                const move = {
                    x: x,
                    rotation: rotation,
                    piece: rotatedPiece
                };
                
                if (this.isValidPosition(rotatedPiece, x)) {
                    // Find drop position
                    move.y = this.getDropPosition(rotatedPiece, x);
                    moves.push(move);
                }
            }
        }
        
        return moves;
    }
    
    rotatePiece(piece, times) {
        let rotated = { ...piece };
        for (let i = 0; i < times; i++) {
            rotated = this.rotateMatrix(rotated);
        }
        return rotated;
    }
    
    rotateMatrix(piece) {
        // Simple rotation logic
        const matrix = piece.shape;
        const n = matrix.length;
        const rotated = Array(n).fill(null).map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                rotated[j][n - 1 - i] = matrix[i][j];
            }
        }
        
        return { ...piece, shape: rotated };
    }
    
    isValidPosition(piece, x, y = 0) {
        // Check if piece fits at position
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    const gridX = x + col;
                    const gridY = y + row;
                    
                    if (gridX < 0 || gridX >= GRID_WIDTH || 
                        gridY >= GRID_HEIGHT ||
                        (gridY >= 0 && this.grid[gridY][gridX])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    getDropPosition(piece, x) {
        let y = 0;
        while (this.isValidPosition(piece, x, y + 1)) {
            y++;
        }
        return y;
    }
    
    evaluateMove(move) {
        // Add y position if not set
        if (!move.y) {
            move.y = this.getDropPosition(move.piece, move.x);
        }
        
        // Simulate placing the piece
        const testGrid = this.cloneGrid();
        this.placePieceOnGrid(testGrid, move.piece, move.x, move.y);
        
        // Clear lines and track combos
        const linesCleared = this.clearLines(testGrid);
        
        // Calculate evaluation metrics - IMPROVED
        const height = this.calculateHeight(testGrid);
        const holes = this.calculateHoles(testGrid);
        const bumpiness = this.calculateBumpiness(testGrid);
        const wells = this.calculateWells(testGrid);
        
        // NEW: Calculate additional advanced metrics
        const deepHoles = this.calculateDeepHoles(testGrid);  // Holes covered by 3+ blocks
        const columnTransitions = this.calculateColumnTransitions(testGrid);  // Roughness
        const rowTransitions = this.calculateRowTransitions(testGrid);  // Horizontal gaps
        const landingHeight = move.y;  // Penalize high placements
        
        // Calculate base score with improved weights
        let score = 0;
        score += this.params.evaluationWeights.height * height;
        score += this.params.evaluationWeights.holes * holes * 1.5;  // Increased hole penalty
        score += this.params.evaluationWeights.bumpiness * bumpiness;
        score += this.params.evaluationWeights.lines * linesCleared * linesCleared;  // Quadratic bonus for multi-lines
        score += this.params.evaluationWeights.wells * wells;
        
        // Add advanced metrics
        score -= deepHoles * 20;  // Heavy penalty for deep holes
        score -= columnTransitions * 2;  // Penalty for roughness
        score -= rowTransitions * 2;  // Penalty for gaps
        score -= landingHeight * 0.5;  // Slight penalty for high placement
        
        // Combo tracking and bonus
        if (linesCleared > 0) {
            if (this.lastClearWasLine) {
                this.combo++;
                score += this.params.evaluationWeights.combo * this.combo * 10;
            } else {
                this.combo = 1;
            }
        } else {
            this.combo = 0;
        }
        
        // Advanced scoring for higher difficulties
        if (this.difficulty >= 3) {
            // T-Spin detection
            if (this.params.evaluationWeights.tspinSetup && move.piece.type === 'T') {
                const tSpinScore = this.detectTSpinSetup(testGrid, move);
                score += this.params.evaluationWeights.tspinSetup * tSpinScore;
            }
            
            // Tetris setup detection
            if (this.params.evaluationWeights.tetrisWell) {
                const tetrisScore = this.detectTetrisWell(testGrid);
                if (move.piece.type === 'I' && linesCleared === 4) {
                    score += this.params.evaluationWeights.tetrisWell * 100; // Big bonus for Tetris
                } else if (move.piece.type === 'I' && tetrisScore > 0) {
                    score -= 20; // Penalty for wasting I piece
                } else {
                    score += this.params.evaluationWeights.tetrisWell * tetrisScore * 10;
                }
            }
            
            // Perfect clear detection
            if (this.params.evaluationWeights.perfectClear && this.isPerfectClear(testGrid)) {
                score += this.params.evaluationWeights.perfectClear * 100;
            }
        }
        
        if (this.difficulty >= 5 && this.params.evaluationWeights.perfectClear) {
            if (this.isPerfectClear(testGrid)) {
                score += this.params.evaluationWeights.perfectClear;
            }
        }
        
        // Look ahead evaluation
        if (this.params.lookAhead > 0 && this.nextPieces.length > 0) {
            score += this.lookAheadEvaluation(testGrid, 0) * 0.5;
        }
        
        return score;
    }
    
    cloneGrid() {
        return this.grid.map(row => [...row]);
    }
    
    placePieceOnGrid(grid, piece, x, y) {
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    const gridY = y + row;
                    const gridX = x + col;
                    if (gridY >= 0 && gridY < GRID_HEIGHT && 
                        gridX >= 0 && gridX < GRID_WIDTH) {
                        grid[gridY][gridX] = piece.shape[row][col];
                    }
                }
            }
        }
    }
    
    clearLines(grid) {
        let linesCleared = 0;
        for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
            if (grid[row].every(cell => cell !== 0)) {
                grid.splice(row, 1);
                grid.unshift(Array(GRID_WIDTH).fill(0));
                linesCleared++;
                row++; // Check same row again
            }
        }
        return linesCleared;
    }
    
    calculateHeight(grid) {
        for (let row = 0; row < GRID_HEIGHT; row++) {
            if (grid[row].some(cell => cell !== 0)) {
                return GRID_HEIGHT - row;
            }
        }
        return 0;
    }
    
    calculateHoles(grid) {
        let holes = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            let blockFound = false;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        return holes;
    }
    
    calculateBumpiness(grid) {
        const heights = [];
        for (let col = 0; col < GRID_WIDTH; col++) {
            let height = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    height = GRID_HEIGHT - row;
                    break;
                }
            }
            heights.push(height);
        }
        
        let bumpiness = 0;
        for (let i = 0; i < heights.length - 1; i++) {
            bumpiness += Math.abs(heights[i] - heights[i + 1]);
        }
        return bumpiness;
    }
    
    calculateWells(grid) {
        let wells = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] === 0) {
                    const leftFilled = col === 0 || grid[row][col - 1] !== 0;
                    const rightFilled = col === GRID_WIDTH - 1 || grid[row][col + 1] !== 0;
                    if (leftFilled && rightFilled) {
                        wells++;
                    }
                }
            }
        }
        return wells;
    }
    
    // NEW: Calculate deep holes (holes covered by 3+ blocks)
    calculateDeepHoles(grid) {
        let deepHoles = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            let blocksAbove = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (grid[row][col] !== 0) {
                    blocksAbove++;
                } else if (blocksAbove > 0) {
                    // Found a hole
                    if (blocksAbove >= 3) {
                        deepHoles++;
                    }
                }
            }
        }
        return deepHoles;
    }
    
    // NEW: Calculate column transitions (changes from filled to empty)
    calculateColumnTransitions(grid) {
        let transitions = 0;
        for (let col = 0; col < GRID_WIDTH; col++) {
            for (let row = 1; row < GRID_HEIGHT; row++) {
                if ((grid[row][col] === 0) !== (grid[row - 1][col] === 0)) {
                    transitions++;
                }
            }
        }
        return transitions;
    }
    
    // NEW: Calculate row transitions (horizontal roughness)
    calculateRowTransitions(grid) {
        let transitions = 0;
        for (let row = 0; row < GRID_HEIGHT; row++) {
            for (let col = 1; col < GRID_WIDTH; col++) {
                if ((grid[row][col] === 0) !== (grid[row][col - 1] === 0)) {
                    transitions++;
                }
            }
        }
        return transitions;
    }
    
    detectTSpinSetup(grid, move) {
        if (!move.piece || move.piece.type !== 'T') return 0;
        
        const x = move.x;
        const y = move.y;
        
        // Check for T-spin setup patterns
        let tSpinScore = 0;
        
        // Check the four corners around the T piece center
        const corners = [
            { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
            { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
        ];
        
        let filledCorners = 0;
        const centerX = x + 1; // T piece center
        const centerY = y + 1;
        
        for (const corner of corners) {
            const cx = centerX + corner.dx;
            const cy = centerY + corner.dy;
            
            // Check bounds and filled cells
            if (cx < 0 || cx >= GRID_WIDTH || cy >= GRID_HEIGHT) {
                filledCorners++;
            } else if (cy >= 0 && grid[cy] && grid[cy][cx] !== 0) {
                filledCorners++;
            }
        }
        
        // T-spin requires at least 3 corners filled
        if (filledCorners >= 3) {
            tSpinScore = 20;
            
            // Check if this would clear lines (T-spin clear bonus)
            const testGrid = this.copyGrid(grid);
            this.placePieceOnGrid(testGrid, move.piece, move.x, move.y);
            const clearedLines = this.clearLines(testGrid);
            
            if (clearedLines > 0) {
                // T-spin single/double/triple bonus
                tSpinScore += clearedLines * 50;
            }
        }
        
        return tSpinScore;
    }
    
    copyGrid(grid) {
        return grid.map(row => [...row]);
    }
    
    detectTetrisWell(grid) {
        // Check for Tetris well setup (one deep column for I piece)
        let bestWellScore = 0;
        
        for (let col = 0; col < GRID_WIDTH; col++) {
            let emptyDepth = 0;
            
            // Count consecutive empty cells from top
            for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
                if (grid[row][col] === 0) {
                    emptyDepth++;
                } else {
                    break;
                }
            }
            
            // Check if this forms a well (adjacent columns are higher)
            if (emptyDepth >= 4) {
                let isWell = true;
                const checkHeight = GRID_HEIGHT - emptyDepth;
                
                // Check left side
                if (col > 0) {
                    for (let row = checkHeight; row < checkHeight + 3 && row < GRID_HEIGHT; row++) {
                        if (grid[row][col - 1] === 0) {
                            isWell = false;
                            break;
                        }
                    }
                }
                
                // Check right side
                if (col < GRID_WIDTH - 1 && isWell) {
                    for (let row = checkHeight; row < checkHeight + 3 && row < GRID_HEIGHT; row++) {
                        if (grid[row][col + 1] === 0) {
                            isWell = false;
                            break;
                        }
                    }
                }
                
                if (isWell) {
                    // Score based on well depth (deeper = better for Tetris)
                    bestWellScore = Math.max(bestWellScore, Math.floor(emptyDepth / 4));
                }
            }
        }
        
        return bestWellScore;
    }
    
    isPerfectClear(grid) {
        return grid.every(row => row.every(cell => cell === 0));
    }
    
    lookAheadEvaluation(grid, depth) {
        if (depth >= this.params.lookAhead || depth >= this.nextPieces.length) {
            return 0;
        }
        // Simplified lookahead
        return 0;
    }
    
    generateMoveSequence(move) {
        this.moveQueue = [];
        
        // Optimize move sequence for faster execution
        const currentX = Math.floor(GRID_WIDTH / 2) - 1; // Starting position
        const targetX = move.x;
        const rotation = move.rotation;
        
        // For higher difficulties, use optimal pathfinding
        if (this.difficulty >= 4) {
            // Try different move orders to find the most efficient path
            const sequences = [];
            
            // Sequence 1: Rotate first, then move
            const seq1 = [];
            for (let i = 0; i < rotation; i++) seq1.push('rotate');
            const dir1 = targetX > currentX ? 'right' : 'left';
            for (let i = 0; i < Math.abs(targetX - currentX); i++) seq1.push(dir1);
            seq1.push('drop');
            sequences.push(seq1);
            
            // Sequence 2: Move partially, rotate, move rest (for wall kicks)
            if (rotation > 0) {
                const seq2 = [];
                const halfMove = Math.floor(Math.abs(targetX - currentX) / 2);
                const dir2 = targetX > currentX ? 'right' : 'left';
                for (let i = 0; i < halfMove; i++) seq2.push(dir2);
                for (let i = 0; i < rotation; i++) seq2.push('rotate');
                for (let i = halfMove; i < Math.abs(targetX - currentX); i++) seq2.push(dir2);
                seq2.push('drop');
                sequences.push(seq2);
            }
            
            // Choose shortest valid sequence
            this.moveQueue = sequences.reduce((best, seq) => 
                seq.length < best.length ? seq : best
            );
        } else {
            // Simple sequence for lower difficulties
            for (let i = 0; i < rotation; i++) {
                this.moveQueue.push('rotate');
            }
            
            const direction = targetX > currentX ? 'right' : 'left';
            const distance = Math.abs(targetX - currentX);
            
            for (let i = 0; i < distance; i++) {
                this.moveQueue.push(direction);
            }
            
            this.moveQueue.push('drop');
        }
        
        // Add finesse optimization for Grandmaster level
        if (this.difficulty === 5) {
            this.optimizeMoveFinesse();
        }
    }
    
    optimizeMoveFinesse() {
        // Remove redundant moves and optimize sequence
        const optimized = [];
        let consecutiveSame = 0;
        let lastMove = null;
        
        for (const move of this.moveQueue) {
            if (move === lastMove && move !== 'drop') {
                consecutiveSame++;
                if (consecutiveSame < 3) { // Limit consecutive same moves
                    optimized.push(move);
                }
            } else {
                consecutiveSame = 0;
                optimized.push(move);
                lastMove = move;
            }
        }
        
        this.moveQueue = optimized;
    }
    
    executeNextMove() {
        if (this.moveQueue.length === 0) {
            this.currentMove = null;
            return null;
        }
        
        return this.moveQueue.shift();
    }
    
    addGarbageLines(count) {
        this.garbageQueue.push(count);
    }
    
    processGarbage() {
        if (this.garbageQueue.length === 0) return;
        
        // Ensure grid is initialized
        if (!this.grid || !Array.isArray(this.grid)) {
            this.grid = this.createEmptyGrid();
        }
        
        const lines = this.garbageQueue.shift();
        
        // Smart garbage handling based on difficulty
        if (this.difficulty >= 3 && this.grid && this.grid.length > 0) {
            // Try to clear garbage efficiently
            const garbageRows = [];
            for (let row = GRID_HEIGHT - 1; row >= GRID_HEIGHT - lines && row >= 0; row--) {
                if (this.grid[row] && this.grid[row].some(cell => cell !== 0)) {
                    garbageRows.push(row);
                }
            }
            
            // If we can clear some garbage with current piece, prioritize it
            if (garbageRows.length > 0 && this.currentPiece) {
                // Re-evaluate move with garbage consideration
                this.currentMove = null;
                this.moveQueue = [];
            }
        }
        
        // Add garbage lines to grid
        for (let i = 0; i < lines; i++) {
            if (this.grid.length > 0) {
                this.grid.shift(); // Remove top row
            }
            const garbageLine = Array(GRID_WIDTH).fill(8); // Gray blocks
            
            // Smart hole placement for counter-attack potential
            let hole;
            if (this.difficulty >= 4) {
                // Place hole strategically for easier clearing
                const columnHeights = this.getColumnHeights();
                const lowestCol = columnHeights.indexOf(Math.min(...columnHeights));
                hole = lowestCol >= 0 ? lowestCol : Math.floor(Math.random() * GRID_WIDTH);
            } else {
                hole = Math.floor(Math.random() * GRID_WIDTH);
            }
            
            garbageLine[hole] = 0;
            this.grid.push(garbageLine);
        }
    }
    
    getColumnHeights() {
        const heights = [];
        // Check if grid exists and is properly initialized
        if (!this.grid || !Array.isArray(this.grid) || this.grid.length === 0) {
            // Return default heights array if grid is not ready
            return Array(GRID_WIDTH).fill(0);
        }
        
        for (let col = 0; col < GRID_WIDTH; col++) {
            let height = 0;
            for (let row = 0; row < GRID_HEIGHT; row++) {
                if (this.grid[row] && this.grid[row][col] !== 0) {
                    height = GRID_HEIGHT - row;
                    break;
                }
            }
            heights.push(height);
        }
        return heights;
    }
    
    getStats() {
        return {
            score: this.score,
            lines: this.lines,
            level: this.level,
            difficulty: this.difficulty
        };
    }
    
    reset() {
        this.grid = this.createEmptyGrid();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.currentPiece = null;
        this.currentMove = null;
        this.moveQueue = [];
        this.garbageQueue = [];
        this.thinkingTime = 0;
        this.combo = 0;
        this.lastClearWasLine = false;
        this.recentMoves = [];
    }
}
})();

/* scripts/modeSelector.js */
(function() {
// Mode Selector - Manages game mode selection and initialization








window.ModeSelector = class ModeSelector {
    constructor() {
        this.availableModes = {
            classic: {
                name: 'Classic',
                class: ClassicMode,
                icon: '',
                color: '#00ffff',
                description: 'The original endless Tetris experience',
                unlocked: true
            },
            powerup: {
                name: 'Power-Up',
                class: PowerUpMode,
                icon: '',
                color: '#ff00ff',
                description: 'Classic with exciting power-ups!',
                unlocked: true
            },
            sprint: {
                name: 'Sprint',
                class: SprintMode,
                icon: '',
                color: '#ff00ff',
                description: 'Clear 40 lines as fast as possible',
                unlocked: true
            },
            marathon: {
                name: 'Marathon',
                class: MarathonMode,
                icon: '',
                color: '#ffff00',
                description: 'Survive 150 lines with increasing difficulty',
                unlocked: true
            },
            zen: {
                name: 'Zen',
                class: ZenMode,
                icon: '',
                color: '#00ff00',
                description: 'Relaxing endless mode with no pressure',
                unlocked: true
            },
            puzzle: {
                name: 'Puzzle',
                class: PuzzleMode,
                icon: '',
                color: '#ff8800',
                description: 'Solve 150 unique challenges',
                unlocked: true
            },
            battle: {
                name: 'Battle',
                class: BattleMode,
                icon: '',
                color: '#ff0000',
                description: 'Face off against intelligent AI opponents',
                unlocked: true
            },
            battle2p: {
                name: 'Battle 2P',
                class: Battle2PMode,
                icon: '',
                color: '#ff00ff',
                description: 'Local 2-player split-screen battle',
                unlocked: true,
                desktopOnly: true // Flag for desktop-only mode
            }
        };
        
        this.currentMode = 'classic';
        this.modeInstance = null;
    }

    // Get all available modes
    getModes() {
        // Check if we're on mobile/tablet
        const isMobile = window.innerWidth < 768 || 'ontouchstart' in window;
        
        return Object.entries(this.availableModes)
            .filter(([key, mode]) => {
                // Filter out desktop-only modes on mobile
                if (isMobile && mode.desktopOnly) {
                    return false;
                }
                return true;
            })
            .map(([key, mode]) => ({
                id: key,
                ...mode
            }));
    }

    // Get unlocked modes only
    getUnlockedModes() {
        return this.getModes().filter(mode => mode.unlocked);
    }

    // Select a game mode
    selectMode(modeId) {
        if (!this.availableModes[modeId]) {
            console.error(`Mode ${modeId} not found`);
            return null;
        }
        
        if (!this.availableModes[modeId].unlocked) {
            console.warn(`Mode ${modeId} is locked`);
            return null;
        }
        
        this.currentMode = modeId;
        return this.availableModes[modeId];
    }

    // Create mode instance
    createModeInstance(modeId, game) {
        const mode = this.selectMode(modeId);
        if (!mode) {
            // Default to classic if mode not found
            modeId = 'classic';
        }
        
        const ModeClass = this.availableModes[modeId].class;
        this.modeInstance = new ModeClass(game);
        return this.modeInstance;
    }

    // Get current mode instance
    getCurrentMode() {
        return this.modeInstance;
    }

    // Get mode info
    getModeInfo(modeId) {
        return this.availableModes[modeId] || null;
    }

    // Check if mode is unlocked
    isModeUnlocked(modeId) {
        return this.availableModes[modeId] && this.availableModes[modeId].unlocked;
    }

    // Unlock a mode
    unlockMode(modeId) {
        if (this.availableModes[modeId]) {
            this.availableModes[modeId].unlocked = true;
            this.saveModeProgress();
        }
    }

    // Save mode progress to localStorage
    saveModeProgress() {
        const progress = {};
        Object.keys(this.availableModes).forEach(key => {
            progress[key] = this.availableModes[key].unlocked;
        });
        localStorage.setItem('tetris_mode_progress', JSON.stringify(progress));
    }

    // Load mode progress from localStorage
    loadModeProgress() {
        const saved = localStorage.getItem('tetris_mode_progress');
        if (saved) {
            try {
                const progress = JSON.parse(saved);
                Object.keys(progress).forEach(key => {
                    if (this.availableModes[key]) {
                        this.availableModes[key].unlocked = progress[key];
                    }
                });
            } catch (e) {
                console.error('Failed to load mode progress:', e);
            }
        }
    }

    // Get mode statistics
    getModeStatistics(modeId) {
        const key = `tetris_stats_${modeId}`;
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load mode statistics:', e);
            }
        }
        return null;
    }

    // Save mode statistics
    saveModeStatistics(modeId, stats) {
        const key = `tetris_stats_${modeId}`;
        localStorage.setItem(key, JSON.stringify(stats));
    }

    // Get best scores for a mode
    getBestScores(modeId, limit = 10) {
        const key = `tetris_scores_${modeId}`;
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                const scores = JSON.parse(saved);
                return scores.slice(0, limit);
            } catch (e) {
                console.error('Failed to load mode scores:', e);
            }
        }
        return [];
    }

    // Add score to mode leaderboard
    addScore(modeId, scoreData) {
        const key = `tetris_scores_${modeId}`;
        let scores = [];
        
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                scores = JSON.parse(saved);
            } catch (e) {
                console.error('Failed to load existing scores:', e);
            }
        }
        
        // Add new score with timestamp
        scores.push({
            ...scoreData,
            timestamp: Date.now()
        });
        
        // Sort by score (or time for sprint mode)
        if (modeId === 'sprint') {
            scores.sort((a, b) => a.time - b.time);
        } else {
            scores.sort((a, b) => b.score - a.score);
        }
        
        // Keep only top 100 scores
        scores = scores.slice(0, 100);
        
        localStorage.setItem(key, JSON.stringify(scores));
        return scores;
    }

    // Reset mode progress
    resetModeProgress(modeId) {
        if (modeId) {
            // Reset specific mode
            localStorage.removeItem(`tetris_stats_${modeId}`);
            localStorage.removeItem(`tetris_scores_${modeId}`);
        } else {
            // Reset all modes
            Object.keys(this.availableModes).forEach(key => {
                localStorage.removeItem(`tetris_stats_${key}`);
                localStorage.removeItem(`tetris_scores_${key}`);
            });
            localStorage.removeItem('tetris_mode_progress');
        }
    }

    // Get mode thumbnail for UI
    getModeThumbnail(modeId) {
        const mode = this.availableModes[modeId];
        if (!mode) return null;
        
        return {
            icon: mode.icon,
            color: mode.color,
            name: mode.name,
            description: mode.description,
            unlocked: mode.unlocked
        };
    }
}
})();

/* scripts/leaderboard.js */
(function() {
// Modern Tetris - Leaderboard Management System

window.LeaderboardManager = class LeaderboardManager {
    constructor() {
        this.apiBaseUrl = 'api/scores.php';
        this.currentTab = 'top-scores';
        this.currentMode = 'classic'; // Default to classic mode
        this.offlineStorage = offlineStorage;
        this.gameModes = [
            { id: 'classic', name: 'Classic', icon: '' },
            { id: 'sprint', name: 'Sprint', icon: '' },
            { id: 'marathon', name: 'Marathon', icon: '' },
            { id: 'zen', name: 'Zen', icon: '' },
            { id: 'puzzle', name: 'Puzzle', icon: '' },
            { id: 'battle', name: 'Battle', icon: '' }
        ];
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchTab(e.target.dataset.tab);
            });
        });

        // Close leaderboard
        const closeButton = document.getElementById('close-leaderboard');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                this.hideLeaderboard();
            });
        }

        // Close on overlay click
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    this.hideLeaderboard();
                }
            });
        }
    }

    // Show leaderboard modal with optional mode
    async showLeaderboard(mode = null) {
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            
            // Clear any active game inputs to prevent interference
            if (window.tetrisGame && window.tetrisGame.inputManager) {
                window.tetrisGame.inputManager.reset();
            }
            
            // Set mode if provided
            if (mode) {
                this.currentMode = mode;
            }
            
            this.currentTab = 'top-scores';
            this.createModeSelector();
            this.updateTabButtons();
            await this.loadLeaderboardData();
        }
    }

    // Hide leaderboard modal
    hideLeaderboard() {
        const overlay = document.getElementById('leaderboard-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    // Switch between tabs
    async switchTab(tab) {
        if (tab === this.currentTab) return;
        
        this.currentTab = tab;
        this.updateTabButtons();
        await this.loadLeaderboardData();
    }

    // Update tab button states
    updateTabButtons() {
        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === this.currentTab);
        });
    }

    // Load leaderboard data based on current tab
    async loadLeaderboardData() {
        const listContainer = document.getElementById('leaderboard-list');
        if (!listContainer) return;

        listContainer.innerHTML = '<div class="loading">Loading scores...</div>';

        try {
            let data;
            if (this.currentTab === 'top-scores') {
                data = await this.fetchTopScores();
            } else if (this.currentTab === 'recent') {
                data = await this.fetchRecentScores();
            }

            this.renderLeaderboard(data);
        } catch (error) {
            this.showError('Failed to load scores. Please try again later.');
        }
    }

    // Fetch top scores from API with offline fallback
    async fetchTopScores(limit = 50) {
        try {
            const response = await fetch(`${this.apiBaseUrl}?action=leaderboard&mode=${this.currentMode}&limit=${limit}`);
            const result = await response.json();
            
            if (!result.success) {
                // Check if offline response
                if (result.offline) {
                    throw new Error('offline');
                }
                throw new Error(result.error || 'Failed to fetch scores');
            }
            
            // Cache the data for offline use
            await this.offlineStorage.cacheLeaderboardData('top-scores', result.data);
            
            return result.data;
        } catch (error) {
            console.log('Failed to fetch from server, using offline mode:', error.message);
            
            // Try to get cached data
            const cached = await this.offlineStorage.getCachedLeaderboardData('top-scores');
            
            if (cached && cached.data) {
                console.log('Using cached leaderboard data');
                // Add local scores if offline
                if (!navigator.onLine) {
                    const localScores = await this.offlineStorage.getAllLocalScores();
                    return this.mergeScores(cached.data, localScores);
                }
                return cached.data;
            }
            
            // If no cache, return local scores only
            const localScores = await this.offlineStorage.getAllLocalScores();
            return localScores.map((score, index) => ({
                ...score,
                rank: index + 1,
                player_name: score.playerName,
                date_achieved: new Date(score.timestamp).toISOString(),
                special_achievements: score.specialAchievements || {}
            }));
        }
    }

    // Fetch recent scores from API with offline fallback
    async fetchRecentScores(limit = 20) {
        try {
            const response = await fetch(`${this.apiBaseUrl}?action=recent&mode=${this.currentMode}&limit=${limit}`);
            const result = await response.json();
            
            if (!result.success) {
                if (result.offline) {
                    throw new Error('offline');
                }
                throw new Error(result.error || 'Failed to fetch scores');
            }
            
            // Cache the data for offline use
            await this.offlineStorage.cacheLeaderboardData('recent', result.data);
            
            return result.data;
        } catch (error) {
            console.log('Failed to fetch recent scores, using offline mode');
            
            // Try to get cached data
            const cached = await this.offlineStorage.getCachedLeaderboardData('recent');
            
            if (cached && cached.data) {
                return cached.data;
            }
            
            // Return local scores sorted by timestamp
            const localScores = await this.offlineStorage.getAllLocalScores();
            return localScores
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, limit)
                .map(score => ({
                    ...score,
                    player_name: score.playerName,
                    date_achieved: new Date(score.timestamp).toISOString(),
                    special_achievements: score.specialAchievements || {}
                }));
        }
    }
    
    // Merge server scores with local unsynced scores
    mergeScores(serverScores, localScores) {
        const merged = [...serverScores];
        
        // Add unsynced local scores
        localScores.forEach(localScore => {
            if (!localScore.synced) {
                merged.push({
                    ...localScore,
                    rank: 0, // Will be recalculated
                    player_name: localScore.playerName,
                    date_achieved: new Date(localScore.timestamp).toISOString(),
                    special_achievements: localScore.specialAchievements || {},
                    isLocal: true // Mark as local
                });
            }
        });
        
        // Re-sort and re-rank
        merged.sort((a, b) => b.score - a.score);
        merged.forEach((score, index) => {
            score.rank = index + 1;
        });
        
        return merged;
    }

    // Render leaderboard entries based on mode
    renderLeaderboard(scores) {
        const listContainer = document.getElementById('leaderboard-list');
        if (!listContainer || !scores || scores.length === 0) {
            listContainer.innerHTML = '<div class="loading">No scores available yet.</div>';
            return;
        }

        const entriesHTML = scores.map((score, index) => {
            const rank = score.rank || (index + 1);
            const rankClass = this.getRankClass(rank);
            const date = new Date(score.date_achieved);
            const achievements = this.formatAchievements(score.special_achievements);
            
            // Mode-specific display
            let modeSpecificInfo = '';
            if (this.currentMode === 'sprint') {
                const time = score.time || score.game_duration || 0;
                modeSpecificInfo = `<div class="entry-time">Time: ${this.formatTime(time)}</div>`;
            } else if (this.currentMode === 'puzzle') {
                const puzzleId = score.puzzle_id || 1;
                const stars = score.stars || 0;
                modeSpecificInfo = `<div class="entry-puzzle">Puzzle #${puzzleId} ${''.repeat(stars)}</div>`;
            } else if (this.currentMode === 'marathon') {
                modeSpecificInfo = `<div class="entry-checkpoint">Lines: ${score.lines}/150</div>`;
            } else if (this.currentMode === 'zen') {
                const duration = score.game_duration || 0;
                modeSpecificInfo = `<div class="entry-duration">Duration: ${Math.floor(duration / 60)}m</div>`;
            } else if (this.currentMode === 'battle') {
                const wins = score.wins || 0;
                modeSpecificInfo = `<div class="entry-wins">Wins: ${wins}</div>`;
            }
            
            return `
                <div class="leaderboard-entry">
                    <div class="entry-rank ${rankClass}">${this.formatRank(rank)}</div>
                    <div class="entry-info">
                        <div class="entry-name">${this.escapeHtml(score.player_name)}</div>
                        <div class="entry-date">${date.toLocaleDateString()}</div>
                        ${modeSpecificInfo}
                        ${achievements ? `<div class="entry-achievements">${achievements}</div>` : ''}
                    </div>
                    <div class="entry-score">${score.score.toLocaleString()}</div>
                    <div class="entry-lines">${score.lines || 0}</div>
                    <div class="entry-level">${score.level || 1}</div>
                </div>
            `;
        }).join('');

        listContainer.innerHTML = entriesHTML;
    }

    // Get CSS class for rank styling
    getRankClass(rank) {
        if (rank === 1) return 'gold';
        if (rank === 2) return 'silver';
        if (rank === 3) return 'bronze';
        return '';
    }

    // Format rank number with trophy for top 3
    formatRank(rank) {
        if (rank === 1) return '';
        if (rank === 2) return '';
        if (rank === 3) return '';
        return rank;
    }

    // Format special achievements
    formatAchievements(achievements) {
        if (!achievements || typeof achievements !== 'object') return '';
        
        const parts = [];
        if (achievements.tspins > 0) parts.push(`${achievements.tspins} T-Spins`);
        if (achievements.tetris > 0) parts.push(`${achievements.tetris} Tetris`);
        if (achievements.combos > 0) parts.push(`${achievements.combos} Combos`);
        
        return parts.length > 0 ? parts.join('  ') : '';
    }

    // Show error message
    showError(message) {
        const listContainer = document.getElementById('leaderboard-list');
        if (listContainer) {
            listContainer.innerHTML = `<div class="error-message">${this.escapeHtml(message)}</div>`;
        }
    }

    // Create mode selector UI
    createModeSelector() {
        const selectorContainer = document.getElementById('mode-selector-container');
        
        if (selectorContainer) {
            const selectorHTML = `
                <div class="mode-selector">
                    ${this.gameModes.map(mode => `
                        <button class="mode-select-btn ${mode.id === this.currentMode ? 'active' : ''}" 
                                data-mode="${mode.id}"
                                title="${mode.name}">
                            <span class="mode-icon">${mode.icon}</span>
                            <span class="mode-name">${mode.name}</span>
                        </button>
                    `).join('')}
                </div>
            `;
            selectorContainer.innerHTML = selectorHTML;
            
            // Add event listeners
            selectorContainer.querySelectorAll('.mode-select-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    if (mode !== this.currentMode) {
                        this.currentMode = mode;
                        this.createModeSelector(); // Update UI
                        await this.loadLeaderboardData();
                    }
                });
            });
        }
    }
    
    // Format time for Sprint mode
    formatTime(seconds) {
        if (typeof seconds === 'string') {
            // If it's already formatted, return as is
            if (seconds.includes(':')) return seconds;
            seconds = parseInt(seconds);
        }
        
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Escape HTML to prevent XSS
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Score Saving System
window.ScoreSaver = class ScoreSaver {
    constructor() {
        this.apiBaseUrl = 'api/scores.php';
        this.gameStartTime = Date.now();
        this.offlineStorage = offlineStorage;
        this.currentMode = 'classic';
        this.modeSpecificData = {};
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Save score button
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.addEventListener('click', () => {
                this.saveCurrentScore();
            });
        }

        // Skip save button
        const skipButton = document.getElementById('skip-save-button');
        if (skipButton) {
            skipButton.addEventListener('click', () => {
                this.hideNameInput();
            });
        }

        // Enter key in name input
        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.saveCurrentScore();
                }
            });
        }

        // Close on overlay click
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    this.hideNameInput();
                }
            });
        }
    }

    // Show name input dialog with score data
    showNameInput(gameStats, specialAchievements = {}, mode = 'classic', modeData = {}) {
        this.currentGameStats = gameStats;
        this.currentAchievements = specialAchievements;
        this.currentMode = mode;
        this.modeSpecificData = modeData;
        
        // Update score display
        document.getElementById('final-score').textContent = gameStats.score.toLocaleString();
        document.getElementById('final-lines').textContent = gameStats.lines;
        document.getElementById('final-level').textContent = gameStats.level;
        
        // Add mode-specific display
        this.updateModeSpecificDisplay();
        
        // Load saved player name if available
        this.loadSavedPlayerName();
        
        // Show modal
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            
            // Clear any active game inputs to prevent interference
            if (window.tetrisGame && window.tetrisGame.inputManager) {
                window.tetrisGame.inputManager.reset();
            }
            
            // Focus name input and select existing text if any
            setTimeout(() => {
                const nameInput = document.getElementById('player-name-input');
                if (nameInput) {
                    nameInput.focus();
                    if (nameInput.value) {
                        nameInput.select();
                    }
                }
            }, 300);
        }
    }

    // Hide name input dialog
    hideNameInput() {
        const overlay = document.getElementById('name-input-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
        
        // Clear input
        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.value = '';
        }
    }

    // Save current score to database
    async saveCurrentScore() {
        const nameInput = document.getElementById('player-name-input');
        const playerName = nameInput ? nameInput.value.trim() : '';
        
        if (!playerName) {
            nameInput.focus();
            nameInput.style.borderColor = 'var(--neon-red)';
            setTimeout(() => {
                nameInput.style.borderColor = '';
            }, 2000);
            return;
        }

        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;
        }

        try {
            const gameDuration = Math.floor((Date.now() - this.gameStartTime) / 1000);
            
            const scoreData = {
                playerName: playerName,
                score: this.currentGameStats.score,
                lines: this.currentGameStats.lines,
                level: this.currentGameStats.level,
                gameDuration: gameDuration,
                specialAchievements: this.currentAchievements,
                mode: this.currentMode,
                ...this.modeSpecificData // Include mode-specific data
            };

            let result;
            
            try {
                const response = await fetch(this.apiBaseUrl + '?action=save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(scoreData)
                });

                result = await response.json();
                
                if (!result.success) {
                    // Check if offline
                    if (result.offline) {
                        // Save locally
                        await this.offlineStorage.saveScoreLocally(scoreData);
                        this.showOfflineSave();
                        
                        // Store player name for next time
                        localStorage.setItem('tetris_player_name', playerName);
                        
                        // Hide modal after delay
                        setTimeout(() => {
                            this.hideNameInput();
                        }, 2000);
                        return;
                    }
                    throw new Error(result.error || 'Failed to save score');
                }
            } catch (fetchError) {
                // Network error - save locally
                console.log('Network error, saving locally:', fetchError);
                await this.offlineStorage.saveScoreLocally(scoreData);
                await this.offlineStorage.registerBackgroundSync();
                this.showOfflineSave();
                
                // Store player name for next time
                localStorage.setItem('tetris_player_name', playerName);
                
                // Hide modal after delay
                setTimeout(() => {
                    this.hideNameInput();
                }, 2000);
                return;
            }

            if (result.success) {
                // Show success message
                this.showSaveSuccess(result.data.rank);
                
                // Store player name for next time
                localStorage.setItem('tetris_player_name', playerName);
                
                // Hide modal after delay
                setTimeout(() => {
                    this.hideNameInput();
                }, 2000);
            } else {
                throw new Error(result.error || 'Failed to save score');
            }
        } catch (error) {
            this.showSaveError(error.message);
        } finally {
            if (saveButton) {
                saveButton.textContent = 'Save Score';
                saveButton.disabled = false;
            }
        }
    }

    // Show save success message
    showSaveSuccess(rank) {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = `Saved! Rank #${rank}`;
            saveButton.style.background = 'var(--neon-green)';
        }
    }

    // Show save error message
    showSaveError(message) {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Error - Try Again';
            saveButton.style.background = 'var(--neon-red)';
            setTimeout(() => {
                saveButton.textContent = 'Save Score';
                saveButton.style.background = '';
            }, 3000);
        }
    }
    
    // Show offline save message
    showOfflineSave() {
        const saveButton = document.getElementById('save-score-button');
        if (saveButton) {
            saveButton.textContent = 'Saved Locally! ';
            saveButton.style.background = 'var(--neon-orange)';
        }
    }

    // Check if score qualifies for high score
    async isHighScore(score) {
        try {
            const scores = await this.fetchTopScores(50);
            return scores.length < 50 || score > scores[scores.length - 1].score;
        } catch (error) {
            // If we can't check, assume it's worth saving
            return true;
        }
    }

    async fetchTopScores(limit) {
        const response = await fetch(`${this.apiBaseUrl}?action=leaderboard&limit=${limit}`);
        const result = await response.json();
        return result.success ? result.data : [];
    }

    // Set game start time
    setGameStartTime(time = Date.now()) {
        this.gameStartTime = time;
    }

    // Load saved player name
    loadSavedPlayerName() {
        const savedName = localStorage.getItem('tetris_player_name');
        const nameInput = document.getElementById('player-name-input');
        if (savedName && nameInput) {
            nameInput.value = savedName;
        }
        return savedName;
    }
    
    // Update mode-specific display in the save dialog
    updateModeSpecificDisplay() {
        const modeDisplay = document.getElementById('mode-specific-display');
        if (!modeDisplay) return;
        
        let displayHTML = '';
        
        switch (this.currentMode) {
            case 'sprint':
                if (this.modeSpecificData.time) {
                    const minutes = Math.floor(this.modeSpecificData.time / 60000);
                    const seconds = Math.floor((this.modeSpecificData.time % 60000) / 1000);
                    const ms = Math.floor((this.modeSpecificData.time % 1000) / 10);
                    displayHTML = `<div class="mode-info">Time: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}</div>`;
                }
                break;
            case 'puzzle':
                if (this.modeSpecificData.puzzleId) {
                    displayHTML = `<div class="mode-info">Puzzle #${this.modeSpecificData.puzzleId} ${''.repeat(this.modeSpecificData.stars || 0)}</div>`;
                }
                break;
            case 'marathon':
                displayHTML = `<div class="mode-info">Progress: ${this.currentGameStats.lines}/150 lines</div>`;
                break;
            case 'zen':
                const duration = this.modeSpecificData.duration || this.gameDuration;
                displayHTML = `<div class="mode-info">Duration: ${Math.floor(duration / 60)}m ${duration % 60}s</div>`;
                break;
            case 'battle':
                if (this.modeSpecificData.wins !== undefined) {
                    displayHTML = `<div class="mode-info">Wins: ${this.modeSpecificData.wins}</div>`;
                }
                break;
        }
        
        modeDisplay.innerHTML = displayHTML;
    }
}
})();

/* scripts/ui.js */
(function() {
// Modern Tetris - UI Management and Effects


window.UIManager = class UIManager {
    constructor(game) {
        this.game = game;
        this.elements = this.getUIElements();
        this.particleSystem = new ParticleSystem();
        this.animations = new Map();
        
        // Initialize score and leaderboard systems
        this.scoreSaver = new ScoreSaver();
        this.leaderboardManager = new LeaderboardManager();
        
        // Mode-specific UI elements
        this.modeUI = null;
        this.currentModeDisplay = null;
        
        this.initializeUI();
    }

    getUIElements() {
        return {
            score: document.getElementById('score'),
            lines: document.getElementById('lines'),
            level: document.getElementById('level'),
            overlay: document.getElementById('game-overlay'),
            overlayTitle: document.getElementById('overlay-title'),
            overlayMessage: document.getElementById('overlay-message'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            leaderboardButton: document.getElementById('leaderboard-button'),
            holdPiece: document.querySelector('.hold-piece'),
            nextPieces: [
                document.getElementById('next-0'),
                document.getElementById('next-1'),
                document.getElementById('next-2')
            ],
            particlesContainer: document.getElementById('particles'),
            
            // Mobile elements for synchronization
            mobileHold: document.getElementById('mobile-hold-piece'),
            mobileScore: document.querySelectorAll('[data-sync="score"]'),
            mobileLines: document.querySelectorAll('[data-sync="lines"]'),
            mobileLevel: document.querySelectorAll('[data-sync="level"]'),
            mobileNext: [
                document.getElementById('mobile-next-0'),
                document.getElementById('mobile-next-1'),
                document.getElementById('mobile-next-2')
            ]
        };
    }

    initializeUI() {
        // Hide game overlay by default since we start on home screen
        this.hideOverlay();
        
        // Button event listeners for game over screen
        if (this.elements.restartButton) {
            this.elements.restartButton.addEventListener('click', () => {
                this.game.restart();
            });
        }
        
        if (this.elements.leaderboardButton) {
            this.elements.leaderboardButton.addEventListener('click', () => {
                this.leaderboardManager.showLeaderboard();
            });
        }
        
        // Initialize particle system
        this.particleSystem.init(this.elements.particlesContainer);
    }

    // Update game stats display
    updateStats(stats) {
        this.updateScore(stats.score);
        this.updateLines(stats.lines);
        this.updateLevel(stats.level);
    }

    updateScore(score) {
        if (this.elements.score) {
            const oldScore = parseInt(this.elements.score.textContent) || 0;
            this.elements.score.textContent = score.toLocaleString();
            
            // Update mobile elements
            this.elements.mobileScore.forEach(el => {
                if (el) el.textContent = score.toLocaleString();
            });
            
            // Animate score increase
            if (score > oldScore) {
                this.elements.score.classList.add('animate-score-pop');
                setTimeout(() => {
                    this.elements.score.classList.remove('animate-score-pop');
                }, 400);
            }
        }
    }

    updateLines(lines) {
        if (this.elements.lines) {
            this.elements.lines.textContent = lines;
        }
        
        // Update mobile elements
        this.elements.mobileLines.forEach(el => {
            if (el) el.textContent = lines;
        });
    }

    updateLevel(level) {
        if (this.elements.level) {
            const oldLevel = parseInt(this.elements.level.textContent) || 1;
            this.elements.level.textContent = level;
            
            // Update mobile elements
            this.elements.mobileLevel.forEach(el => {
                if (el) el.textContent = level;
            });
            
            // Animate level up
            if (level > oldLevel) {
                this.elements.level.classList.add('animate-level-up');
                setTimeout(() => {
                    this.elements.level.classList.remove('animate-level-up');
                }, 1000);
                
                // Create level up particles
                this.particleSystem.createLevelUpEffect();
            }
        }
    }

    // Update hold piece display
    updateHoldPiece(piece) {
        // Update desktop hold piece
        if (this.elements.holdPiece) {
            this.elements.holdPiece.innerHTML = '';
            
            if (piece) {
                const miniGrid = this.createMiniGrid(piece);
                this.elements.holdPiece.appendChild(miniGrid);
                
                // Animate swap
                this.elements.holdPiece.classList.add('animate-swap');
                setTimeout(() => {
                    this.elements.holdPiece.classList.remove('animate-swap');
                }, 600);
            }
        }
        
        // Update mobile hold piece
        if (this.elements.mobileHold) {
            this.elements.mobileHold.innerHTML = '';
            
            if (piece) {
                const mobileGrid = this.createMiniGrid(piece, true); // true for mobile size
                this.elements.mobileHold.appendChild(mobileGrid);
            }
        }
    }

    // Update next pieces display
    updateNextPieces(pieces) {
        // Update desktop next pieces
        pieces.forEach((pieceType, index) => {
            if (this.elements.nextPieces[index]) {
                this.elements.nextPieces[index].innerHTML = '';
                
                if (pieceType) {
                    const { Piece, PIECE_COLORS } = this.game.pieceModule;
                    const piece = new Piece(pieceType);
                    const miniGrid = this.createMiniGrid(piece);
                    this.elements.nextPieces[index].appendChild(miniGrid);
                    
                    // Animate new piece
                    if (index === 0) {
                        this.elements.nextPieces[index].classList.add('slide-in-right');
                        setTimeout(() => {
                            this.elements.nextPieces[index].classList.remove('slide-in-right');
                        }, 400);
                    }
                }
            }
        });
        
        // Update mobile next pieces
        pieces.forEach((pieceType, index) => {
            if (this.elements.mobileNext[index]) {
                this.elements.mobileNext[index].innerHTML = '';
                
                if (pieceType) {
                    const { Piece, PIECE_COLORS } = this.game.pieceModule;
                    const piece = new Piece(pieceType);
                    const mobileGrid = this.createMiniGrid(piece, true); // true for mobile size
                    this.elements.mobileNext[index].appendChild(mobileGrid);
                }
            }
        });
    }

    // Create mini grid for piece preview
    createMiniGrid(piece, isMobile = false) {
        const container = document.createElement('div');
        container.className = 'mini-grid';
        
        const gap = isMobile ? '0.5px' : '1px';
        const borderRadius = isMobile ? '1px' : '2px';
        const glowSize = isMobile ? '6px' : '10px';
        
        container.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: ${gap};
            width: 100%;
            height: 100%;
        `;
        
        const shape = piece.getCurrentShape();
        
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                const cell = document.createElement('div');
                cell.style.cssText = `
                    aspect-ratio: 1;
                    border-radius: ${borderRadius};
                    transition: all 0.2s ease;
                `;
                
                if (shape[y] && shape[y][x]) {
                    cell.style.backgroundColor = piece.color;
                    cell.style.boxShadow = `0 0 ${glowSize} ${piece.color}40`;
                    cell.style.border = `1px solid ${piece.color}`;
                } else {
                    cell.style.backgroundColor = 'transparent';
                }
                
                container.appendChild(cell);
            }
        }
        
        return container;
    }

    // Show game overlay
    showOverlay(title, message, showRestart = false) {
        if (!this.elements.overlay) return;
        
        this.elements.overlay.classList.remove('hidden');
        
        if (this.elements.overlayTitle) {
            this.elements.overlayTitle.textContent = title;
        }
        
        if (this.elements.overlayMessage) {
            this.elements.overlayMessage.textContent = message;
        }
        
        if (this.elements.startButton) {
            this.elements.startButton.style.display = showRestart ? 'none' : 'inline-block';
        }
        
        if (this.elements.restartButton) {
            this.elements.restartButton.style.display = showRestart ? 'inline-block' : 'none';
        }
        
        // Animate overlay appearance
        this.elements.overlay.classList.add('animate-game-over');
        setTimeout(() => {
            this.elements.overlay.classList.remove('animate-game-over');
        }, 800);
    }

    // Hide game overlay
    hideOverlay() {
        if (this.elements.overlay) {
            this.elements.overlay.classList.add('hidden');
        }
    }
    
    // Update mode-specific display
    updateModeDisplay(modeConfig) {
        if (!modeConfig) return;
        
        this.modeUI = modeConfig;
        
        // Show/hide UI elements based on mode
        if (this.elements.score) {
            this.elements.score.parentElement.style.display = modeConfig.showScore ? 'block' : 'none';
        }
        if (this.elements.lines) {
            this.elements.lines.parentElement.style.display = modeConfig.showLines ? 'block' : 'none';
        }
        if (this.elements.level) {
            this.elements.level.parentElement.style.display = modeConfig.showLevel ? 'block' : 'none';
        }
        
        // Add mode-specific elements
        if (modeConfig.customDisplay) {
            this.createModeSpecificUI(modeConfig.customDisplay);
        }
    }
    
    // Create mode-specific UI elements
    createModeSpecificUI(customDisplay) {
        // Remove existing mode UI if any
        if (this.currentModeDisplay) {
            this.currentModeDisplay.remove();
        }
        
        const modeUIContainer = document.createElement('div');
        modeUIContainer.className = 'mode-specific-ui';
        
        // Add timer for Sprint mode
        if (customDisplay.timer) {
            const timerElement = document.createElement('div');
            timerElement.className = 'sprint-timer';
            timerElement.id = 'mode-timer';
            timerElement.textContent = customDisplay.timer;
            modeUIContainer.appendChild(timerElement);
        }
        
        // Add progress bar for Marathon mode
        if (customDisplay.progress) {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'marathon-progress';
            const progressBar = document.createElement('div');
            progressBar.className = 'marathon-progress-bar';
            progressBar.style.width = customDisplay.progress;
            progressContainer.appendChild(progressBar);
            modeUIContainer.appendChild(progressContainer);
        }
        
        // Add objective display for Puzzle mode
        if (customDisplay.objective) {
            const objectiveElement = document.createElement('div');
            objectiveElement.className = 'puzzle-objective';
            objectiveElement.innerHTML = `
                <div class="puzzle-objective-title">Objective</div>
                <div class="puzzle-objective-desc" id="puzzle-objective-text">${customDisplay.objective}</div>
            `;
            modeUIContainer.appendChild(objectiveElement);
        }
        
        // Add pieces counter for Puzzle mode
        if (customDisplay.pieces) {
            const piecesElement = document.createElement('div');
            piecesElement.className = 'puzzle-pieces';
            piecesElement.innerHTML = `
                <div class="puzzle-pieces-title">Pieces Used</div>
                <div class="puzzle-pieces-count" id="puzzle-pieces-count">${customDisplay.pieces}</div>
            `;
            modeUIContainer.appendChild(piecesElement);
        }
        
        // Add puzzle number display
        if (customDisplay.puzzle) {
            const puzzleNumElement = document.createElement('div');
            puzzleNumElement.className = 'puzzle-number';
            puzzleNumElement.innerHTML = `
                <div class="puzzle-number-text">Puzzle ${customDisplay.puzzle}</div>
            `;
            modeUIContainer.appendChild(puzzleNumElement);
        }
        
        // Add Battle mode display (AI score, round info, etc.)
        if (customDisplay.aiScore !== undefined || customDisplay.round) {
            const battleInfoElement = document.createElement('div');
            battleInfoElement.className = 'battle-info';
            battleInfoElement.innerHTML = `
                <div class="battle-round">${customDisplay.round || 'Round 1'}</div>
                <div class="battle-scores">
                    <div class="player-score-section">
                        <div class="score-label">You</div>
                        <div class="score-value" id="player-battle-score">${customDisplay.playerScore || 0}</div>
                        <div class="wins-indicator">Wins: ${customDisplay.playerWins || 0}</div>
                    </div>
                    <div class="vs-separator">VS</div>
                    <div class="ai-score-section">
                        <div class="score-label">AI (${customDisplay.aiDifficulty || 'Normal'})</div>
                        <div class="score-value" id="ai-battle-score">${customDisplay.aiScore || 0}</div>
                        <div class="wins-indicator">Wins: ${customDisplay.aiWins || 0}</div>
                    </div>
                </div>
                <div class="ai-stats">
                    <span>AI Lines: <span id="ai-lines">${customDisplay.aiLines || 0}</span></span>
                </div>
            `;
            modeUIContainer.appendChild(battleInfoElement);
            
            // Add CSS for battle info display
            if (!document.getElementById('battle-mode-styles')) {
                const style = document.createElement('style');
                style.id = 'battle-mode-styles';
                style.textContent = `
                    .battle-info {
                        background: rgba(255, 0, 0, 0.1);
                        border: 2px solid #ff0000;
                        border-radius: 10px;
                        padding: 15px;
                        margin-bottom: 20px;
                        box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
                    }
                    .battle-round {
                        text-align: center;
                        font-size: 1.2rem;
                        font-weight: bold;
                        color: #ff0000;
                        margin-bottom: 10px;
                        text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
                    }
                    .battle-scores {
                        display: grid;
                        grid-template-columns: 1fr auto 1fr;
                        gap: 15px;
                        align-items: center;
                        margin-bottom: 10px;
                    }
                    .player-score-section, .ai-score-section {
                        text-align: center;
                    }
                    .score-label {
                        font-size: 0.9rem;
                        color: #999;
                        margin-bottom: 5px;
                    }
                    .score-value {
                        font-size: 1.8rem;
                        font-weight: bold;
                        color: #39ff14;
                        text-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
                    }
                    .ai-score-section .score-value {
                        color: #ff0040;
                        text-shadow: 0 0 10px rgba(255, 0, 64, 0.5);
                    }
                    .vs-separator {
                        font-size: 1.5rem;
                        font-weight: bold;
                        color: #ffff00;
                        text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
                    }
                    .wins-indicator {
                        font-size: 0.8rem;
                        color: #666;
                        margin-top: 5px;
                    }
                    .ai-stats {
                        text-align: center;
                        font-size: 0.9rem;
                        color: #999;
                        padding-top: 10px;
                        border-top: 1px solid rgba(255, 255, 255, 0.1);
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Insert into game area
        const gameBoard = document.querySelector('.game-board');
        if (gameBoard) {
            gameBoard.appendChild(modeUIContainer);
            this.currentModeDisplay = modeUIContainer;
        }
    }
    
    // Update mode-specific UI continuously
    updateModeUI(modeConfig) {
        // Handle Power-Up mode UI
        if (this.game.gameMode && this.game.gameMode.name === 'Power-Up') {
            this.updatePowerUpUI();
        }
        
        if (!modeConfig || !modeConfig.customDisplay) return;
        
        // Update timer for Sprint mode
        if (modeConfig.customDisplay.timer) {
            const timerElement = document.getElementById('mode-timer');
            if (timerElement) {
                timerElement.textContent = modeConfig.customDisplay.timer;
            }
        }
        
        // Update progress for Marathon mode
        if (modeConfig.customDisplay.progress) {
            const progressBar = document.querySelector('.marathon-progress-bar');
            if (progressBar) {
                progressBar.style.width = modeConfig.customDisplay.progress;
            }
        }
        
        // Update objective for Puzzle mode
        if (modeConfig.customDisplay.objective) {
            const objectiveElement = document.getElementById('puzzle-objective-text');
            if (objectiveElement) {
                objectiveElement.textContent = modeConfig.customDisplay.objective;
            }
        }
        
        // Update pieces counter for Puzzle mode
        if (modeConfig.customDisplay.pieces) {
            const piecesElement = document.getElementById('puzzle-pieces-count');
            if (piecesElement) {
                piecesElement.textContent = modeConfig.customDisplay.pieces;
            }
        }
        
        // Update Battle mode scores
        if (modeConfig.customDisplay.playerScore !== undefined) {
            const playerScoreElement = document.getElementById('player-battle-score');
            if (playerScoreElement) {
                playerScoreElement.textContent = modeConfig.customDisplay.playerScore;
            }
        }
        
        if (modeConfig.customDisplay.aiScore !== undefined) {
            const aiScoreElement = document.getElementById('ai-battle-score');
            if (aiScoreElement) {
                aiScoreElement.textContent = modeConfig.customDisplay.aiScore;
            }
        }
        
        if (modeConfig.customDisplay.aiLines !== undefined) {
            const aiLinesElement = document.getElementById('ai-lines');
            if (aiLinesElement) {
                aiLinesElement.textContent = modeConfig.customDisplay.aiLines;
            }
        }
    }
    
    // Show mode-specific messages
    showMessage(text, type = 'info', duration = 2000) {
        const messageElement = document.createElement('div');
        messageElement.className = `game-message message-${type}`;
        messageElement.textContent = text;
        messageElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            z-index: 10000;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        `;
        
        document.body.appendChild(messageElement);
        
        setTimeout(() => {
            messageElement.style.opacity = '0';
            messageElement.style.transition = 'opacity 0.5s';
            setTimeout(() => messageElement.remove(), 500);
        }, duration);
    }
    
    // Show puzzle completion
    showPuzzleComplete(puzzle, stars, stats) {
        // Create a more elaborate completion screen
        const overlay = document.createElement('div');
        overlay.className = 'puzzle-complete-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.5s;
        `;
        
        const content = document.createElement('div');
        content.className = 'puzzle-complete-content';
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 136, 0, 0.5);
            max-width: 500px;
        `;
        
        content.innerHTML = `
            <h2 style="color: #ff8800; font-size: 2.5rem; margin-bottom: 20px;">
                 PUZZLE COMPLETE! 
            </h2>
            <h3 style="color: #fff; font-size: 1.5rem; margin-bottom: 15px;">
                Puzzle #${puzzle.id}: ${puzzle.name}
            </h3>
            <div style="font-size: 3rem; margin: 20px 0;">
                ${''.repeat(stars)}${''.repeat(Math.max(0, 3 - stars))}
            </div>
            <div style="color: #ccc; margin: 20px 0;">
                <p>Lines Cleared: ${stats.linesCleared}</p>
                <p>Pieces Used: ${stats.piecesUsed}</p>
                <p>Time: ${stats.timeElapsed}s</p>
            </div>
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                <button id="next-puzzle-btn" style="
                    background: #ff8800;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    font-weight: bold;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Next Puzzle </button>
                <button id="retry-puzzle-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Retry</button>
            </div>
        `;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Add event listeners
        const nextBtn = document.getElementById('next-puzzle-btn');
        const retryBtn = document.getElementById('retry-puzzle-btn');
        
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                overlay.remove();
                // Load next puzzle
                if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                    const nextPuzzleId = puzzle.id + 1;
                    console.log(`Loading next puzzle: ${nextPuzzleId}`);
                    
                    // Reset game state first
                    this.game.state = 'playing';
                    this.game.gameMode.isComplete = false;
                    this.game.gameMode.pendingCompletion = false;
                    
                    // Load the next puzzle
                    this.game.gameMode.loadPuzzle(nextPuzzleId);
                    
                    // Clear the grid and reset the game
                    this.game.grid.reset();
                    this.game.gameMode.loadPuzzle(nextPuzzleId); // Load again to apply grid
                    
                    // Continue playing without full restart
                    this.game.currentPiece = null;
                }
            });
        }
        
        if (retryBtn) {
            retryBtn.addEventListener('click', () => {
                overlay.remove();
                // Retry current puzzle
                if (this.game && this.game.gameMode) {
                    // Reset game state
                    this.game.state = 'playing';
                    this.game.gameMode.isComplete = false;
                    this.game.gameMode.pendingCompletion = false;
                    
                    // Reload current puzzle
                    const currentPuzzleId = puzzle.id;
                    this.game.grid.reset();
                    this.game.gameMode.loadPuzzle(currentPuzzleId);
                    this.game.currentPiece = null;
                }
            });
        }
        
        // Auto-remove after 10 seconds if no action
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.remove();
            }
        }, 10000);
    }
    
    // Show puzzle failed
    showPuzzleFailed(puzzle, reason, stats) {
        const message = `Puzzle #${puzzle.id} Failed\n${reason}`;
        this.showMessage(message, 'error', 3000);
    }
    
    // Show AI difficulty selection for Battle mode
    showAIDifficultySelection(callback) {
        const overlay = document.createElement('div');
        overlay.className = 'ai-difficulty-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff0000;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.5);
        `;
        
        const difficulties = [
            { level: 1, name: 'Easy', emoji: '', color: '#4CAF50', desc: 'AI makes frequent mistakes' },
            { level: 2, name: 'Normal', emoji: '', color: '#FFC107', desc: 'Balanced challenge' },
            { level: 3, name: 'Hard', emoji: '', color: '#FF9800', desc: 'Skilled opponent', default: true },
            { level: 4, name: 'Expert', emoji: '', color: '#F44336', desc: 'Very challenging' },
            { level: 5, name: 'Grandmaster', emoji: '', color: '#9C27B0', desc: 'Nearly unbeatable' }
        ];
        
        let selectedLevel = parseInt(localStorage.getItem('battle_ai_difficulty')) || 3;
        
        content.innerHTML = `
            <h2 style="color: #ff0000; text-align: center; margin-bottom: 30px; font-size: 2rem;">
                 Choose AI Difficulty
            </h2>
            <div id="difficulty-options" style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;">
                ${difficulties.map(diff => `
                    <button class="difficulty-option" data-level="${diff.level}" style="
                        background: ${diff.level === selectedLevel ? diff.color : 'rgba(255, 255, 255, 0.1)'};
                        color: ${diff.level === selectedLevel ? '#000' : '#fff'};
                        border: 2px solid ${diff.color};
                        padding: 15px 20px;
                        border-radius: 10px;
                        cursor: pointer;
                        transition: all 0.3s;
                        text-align: left;
                        font-size: 1.1rem;
                    ">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <span style="font-size: 1.5rem; margin-right: 10px;">${diff.emoji}</span>
                                <strong>${diff.name}</strong>
                                ${diff.default ? '<span style="opacity: 0.7; font-size: 0.9rem;">(Default)</span>' : ''}
                            </div>
                            <div style="font-size: 0.9rem; opacity: 0.8;">${diff.desc}</div>
                        </div>
                    </button>
                `).join('')}
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="start-battle-btn" style="
                    background: #ff0000;
                    color: white;
                    border: none;
                    padding: 15px 40px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    font-weight: bold;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Start Battle </button>
                <button id="cancel-battle-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                ">Cancel</button>
            </div>
        `;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Add event listeners
        setTimeout(() => {
            const options = overlay.querySelectorAll('.difficulty-option');
            options.forEach(option => {
                option.addEventListener('click', () => {
                    selectedLevel = parseInt(option.dataset.level);
                    // Update visual selection
                    options.forEach(opt => {
                        const level = parseInt(opt.dataset.level);
                        const diff = difficulties.find(d => d.level === level);
                        if (level === selectedLevel) {
                            opt.style.background = diff.color;
                            opt.style.color = '#000';
                        } else {
                            opt.style.background = 'rgba(255, 255, 255, 0.1)';
                            opt.style.color = '#fff';
                        }
                    });
                });
                
                // Hover effect
                option.addEventListener('mouseenter', () => {
                    if (parseInt(option.dataset.level) !== selectedLevel) {
                        option.style.background = 'rgba(255, 255, 255, 0.2)';
                    }
                });
                option.addEventListener('mouseleave', () => {
                    if (parseInt(option.dataset.level) !== selectedLevel) {
                        option.style.background = 'rgba(255, 255, 255, 0.1)';
                    }
                });
            });
            
            document.getElementById('start-battle-btn').addEventListener('click', () => {
                localStorage.setItem('battle_ai_difficulty', selectedLevel);
                overlay.remove();
                if (callback) callback(selectedLevel);
            });
            
            document.getElementById('cancel-battle-btn').addEventListener('click', () => {
                overlay.remove();
            });
        }, 0);
    }
    
    // Show puzzle selection menu
    async showPuzzleSelection() {
        // Use storage adapter for better compatibility
        const storage = window.TetrisStorage || { 
            load: (key) => Promise.resolve(JSON.parse(localStorage.getItem('tetris_' + key) || 'null'))
        };
        
        const progress = await storage.load('puzzle_progress') || {};
        const completedPuzzles = await storage.load('puzzle_completed') || [];
        const highestUnlocked = progress.highestUnlocked || 1;
        
        const overlay = document.createElement('div');
        overlay.className = 'puzzle-selection-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            overflow-y: auto;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        `;
        
        let html = `
            <h2 style="color: #ff8800; font-size: 2rem; margin-bottom: 20px; text-align: center;">
                 Select Puzzle
            </h2>
            <div style="text-align: center; margin-bottom: 20px; color: #ccc;">
                Progress: ${completedPuzzles.length}/150 puzzles completed
            </div>
        `;
        
        // Create category tabs
        const categories = ['tutorial', 'beginner', 'intermediate', 'advanced', 'expert', 'master', 'grandmaster'];
        html += '<div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">';
        categories.forEach(cat => {
            html += `
                <button class="category-tab" data-category="${cat}" style="
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    text-transform: capitalize;
                ">${cat}</button>
            `;
        });
        html += '</div>';
        
        // Puzzle grid container
        html += '<div id="puzzle-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 20px;"></div>';
        
        // Buttons
        html += `
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                ${progress.currentPuzzleId ? `
                    <button id="resume-puzzle-btn" style="
                        background: #00ff00;
                        color: #000;
                        border: none;
                        padding: 15px 30px;
                        font-size: 1.2rem;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: bold;
                    ">Resume Puzzle #${progress.currentPuzzleId}</button>
                ` : ''}
                <button id="close-selection-btn" style="
                    background: #666;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    border-radius: 10px;
                    cursor: pointer;
                ">Close</button>
            </div>
        `;
        
        content.innerHTML = html;
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Function to show puzzles for a category
        const showCategory = (category) => {
            const gridElement = document.getElementById('puzzle-grid');
            gridElement.innerHTML = '';
            
            // Get puzzles from puzzleData
            let puzzles = [];
            if (window.PUZZLES) {
                puzzles = window.PUZZLES.filter(p => p.category === category);
            }
            
            // Create puzzle buttons
            puzzles.forEach(puzzle => {
                const isCompleted = completedPuzzles.some(p => p.puzzleId === puzzle.id);
                const isUnlocked = puzzle.id <= highestUnlocked;
                
                const puzzleBtn = document.createElement('button');
                puzzleBtn.style.cssText = `
                    background: ${isCompleted ? '#00ff00' : (isUnlocked ? '#ff8800' : '#444')};
                    color: ${isCompleted ? '#000' : '#fff'};
                    border: 2px solid ${isCompleted ? '#00ff00' : (isUnlocked ? '#ff8800' : '#666')};
                    padding: 15px;
                    border-radius: 10px;
                    cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
                    font-size: 1rem;
                    font-weight: bold;
                    opacity: ${isUnlocked ? 1 : 0.5};
                    position: relative;
                `;
                
                puzzleBtn.innerHTML = `
                    #${puzzle.id}
                    ${isCompleted ? '<span style="position: absolute; top: 2px; right: 2px; font-size: 0.8rem;"></span>' : ''}
                `;
                
                puzzleBtn.disabled = !isUnlocked;
                
                if (isUnlocked) {
                    puzzleBtn.addEventListener('click', () => {
                        overlay.remove();
                        // Load selected puzzle
                        if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                            this.game.state = 'playing';
                            this.game.gameMode.isComplete = false;
                            this.game.gameMode.pendingCompletion = false;
                            this.game.gameMode.puzzleId = puzzle.id;
                            this.game.gameMode.loadPuzzle(puzzle.id);
                            this.game.gameMode.saveCurrentProgress();
                        }
                    });
                }
                
                gridElement.appendChild(puzzleBtn);
            });
        };
        
        // Add category tab listeners
        setTimeout(() => {
            const tabs = overlay.querySelectorAll('.category-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Update active tab styling
                    tabs.forEach(t => t.style.background = '#333');
                    tab.style.background = '#ff8800';
                    showCategory(tab.dataset.category);
                });
            });
            
            // Show first category by default
            if (tabs.length > 0) {
                tabs[0].click();
            }
            
            // Resume button
            const resumeBtn = document.getElementById('resume-puzzle-btn');
            if (resumeBtn) {
                resumeBtn.addEventListener('click', () => {
                    overlay.remove();
                    if (this.game && this.game.gameMode && this.game.gameMode.loadPuzzle) {
                        this.game.state = 'playing';
                        this.game.gameMode.isComplete = false;
                        this.game.gameMode.pendingCompletion = false;
                        this.game.gameMode.loadPuzzle(progress.currentPuzzleId);
                    }
                });
            }
            
            // Close button
            const closeBtn = document.getElementById('close-selection-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    overlay.remove();
                });
            }
        }, 0);
    }
    
    // Show continue prompt for Marathon mode
    showContinuePrompt(state, callback) {
        const promptDiv = document.createElement('div');
        promptDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            z-index: 10000;
            text-align: center;
            color: white;
        `;
        promptDiv.innerHTML = `
            <h3>Continue Previous Game?</h3>
            <p>Lines: ${state.lines} | Level: ${state.level}</p>
            <button id="continue-yes" style="margin: 10px; padding: 10px 20px;">Continue</button>
            <button id="continue-no" style="margin: 10px; padding: 10px 20px;">New Game</button>
        `;
        
        document.body.appendChild(promptDiv);
        
        document.getElementById('continue-yes').onclick = () => {
            promptDiv.remove();
            callback(true);
        };
        document.getElementById('continue-no').onclick = () => {
            promptDiv.remove();
            callback(false);
        };
    }
    
    // Show load game prompt for Zen mode
    showLoadGamePrompt(saves, callback) {
        // Similar to continue prompt
        this.showMessage('Saved games available', 'info', 2000);
    }
    
    // Show power-up effect for Battle mode
    showPowerUp(type, target) {
        this.showMessage(`${type.toUpperCase()} activated!`, 'powerup', 1500);
    }
    
    // Show damage for Battle mode
    showDamage(target, lines) {
        const side = target === 'player' ? 'You' : 'AI';
        this.showMessage(`${side}: ${lines} damage!`, 'damage', 1000);
    }
    
    // Show round result for Battle mode
    showRoundResult(playerWon, round, playerWins, aiWins) {
        const message = playerWon ? 'Round Won!' : 'Round Lost!';
        this.showMessage(`${message}\nScore: ${playerWins}-${aiWins}`, playerWon ? 'success' : 'error', 2000);
    }
    
    // Show match result for Battle mode
    showMatchResult(result) {
        const message = result.won ? 'Victory!' : 'Defeat!';
        this.showMessage(message, result.won ? 'success' : 'error', 3000);
    }
    
    // Update AI grid for Battle mode
    updateAIGrid(grid) {
        // This would update a visual representation of the AI's grid
        // For now, just a placeholder
    }

    // Show pause overlay
    showPauseOverlay() {
        // Check if device supports touch for appropriate message
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const message = isTouchDevice ? 
            'Press P or tap screen to resume' : 
            'Press P to resume';
        this.showOverlay('Game Paused', message);
    }

    // Show game over overlay
    async showGameOverOverlay(stats, specialAchievements = {}, mode = null, modeData = {}) {
        // Get current game mode if not provided
        if (!mode && this.game && this.game.gameMode) {
            mode = this.game.gameMode.name.toLowerCase();
        }
        
        // Create mode-specific message
        let message = `Final Score: ${stats.score.toLocaleString()}\nLines: ${stats.lines}\nLevel: ${stats.level}`;
        
        // Add mode-specific info
        if (mode === 'sprint' && modeData.time) {
            const minutes = Math.floor(modeData.time / 60000);
            const seconds = Math.floor((modeData.time % 60000) / 1000);
            const ms = Math.floor((modeData.time % 1000) / 10);
            message += `\nTime: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
            if (modeData.isNewRecord) {
                message += '\n NEW RECORD!';
            }
        } else if (mode === 'puzzle' && modeData.puzzleId) {
            message = `Puzzle #${modeData.puzzleId} ${modeData.isVictory ? 'Complete!' : 'Failed'}\n`;
            message += `${'\u2b50'.repeat(modeData.stars || 0)}\n`;
            message += `Score: ${stats.score.toLocaleString()}`;
        } else if (mode === 'marathon') {
            message += `\nProgress: ${stats.lines}/150 lines`;
            if (stats.lines >= 150) {
                message += '\n MARATHON COMPLETE!';
            }
        } else if (mode === 'zen') {
            const duration = modeData.duration || 0;
            message += `\nDuration: ${Math.floor(duration / 60)}m ${duration % 60}s`;
            message += `\nEfficiency: ${modeData.efficiency || '0'}%`;
        } else if (mode === 'battle') {
            message = modeData.victory ? 'VICTORY!' : 'DEFEAT';
            message += `\nScore: ${stats.score.toLocaleString()}`;
            if (modeData.wins !== undefined) {
                message += `\nWins: ${modeData.wins}`;
            }
        }
        
        const title = mode === 'puzzle' && modeData.isVictory ? 'Victory!' : 'Game Over';
        this.showOverlay(title, message, true);
        
        // Create game over particles
        this.particleSystem.createGameOverEffect();
        
        // Shake animation
        document.querySelector('.game-board').classList.add('animate-shake');
        setTimeout(() => {
            document.querySelector('.game-board').classList.remove('animate-shake');
        }, 500);
        
        // Check if this is a high score and show name input
        try {
            const isHighScore = await this.scoreSaver.isHighScore(stats.score);
            if (isHighScore || mode === 'sprint' || mode === 'puzzle') {
                setTimeout(() => {
                    this.scoreSaver.showNameInput(stats, specialAchievements, mode, modeData);
                }, 1500); // Delay to let game over animation play
            }
        } catch (error) {
            console.warn('Could not check high score status:', error);
            // Show name input anyway if we can't check
            setTimeout(() => {
                this.scoreSaver.showNameInput(stats, specialAchievements, mode, modeData);
            }, 1500);
        }
        
        // Show leaderboard button
        if (this.elements.leaderboardButton) {
            this.elements.leaderboardButton.style.display = 'inline-block';
        }
    }

    // Line clear effects
    showLineClearEffect(clearedLines, isSpecial = false) {
        clearedLines.forEach((lineY, index) => {
            setTimeout(() => {
                this.particleSystem.createLineClearEffect(lineY, isSpecial);
            }, index * 50);
        });
        
        // Special effects for Tetris
        if (clearedLines.length === 4) {
            this.particleSystem.createTetrisEffect();
        }
    }

    // T-Spin effect
    showTSpinEffect(position, isMini = false) {
        this.particleSystem.createTSpinEffect(position, isMini);
        
        // Flash effect
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            canvas.classList.add('animate-tspin');
            setTimeout(() => {
                canvas.classList.remove('animate-tspin');
            }, 300);
        }
    }

    // Combo effect
    showComboEffect(comboCount) {
        if (comboCount > 1) {
            this.particleSystem.createComboEffect(comboCount);
            
            // Update score with combo animation
            if (this.elements.score) {
                this.elements.score.classList.add('animate-combo');
                setTimeout(() => {
                    this.elements.score.classList.remove('animate-combo');
                }, 600);
            }
        }
    }

    // Perfect clear effect
    showPerfectClearEffect() {
        this.particleSystem.createPerfectClearEffect();
    }

    // Update UI theme
    updateTheme(theme) {
        document.documentElement.className = `theme-${theme}`;
    }

    // Cleanup
    destroy() {
        this.particleSystem.destroy();
        this.animations.clear();
    }
}

// Particle System for Visual Effects
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.container = null;
        this.animationId = null;
    }

    init(container) {
        this.container = container;
        this.startAnimation();
    }

    createParticle(x, y, options = {}) {
        const particle = document.createElement('div');
        particle.className = `particle ${options.color || ''}`;
        
        const size = options.size || 4;
        particle.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${size}px;
            height: ${size}px;
            background: ${options.background || 'var(--neon-blue)'};
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        `;
        
        if (this.container) {
            this.container.appendChild(particle);
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, options.duration || 2000);
        }
        
        return particle;
    }

    createLineClearEffect(lineY, isSpecial) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const y = rect.top + (lineY * (rect.height / 20));
        
        for (let i = 0; i < 20; i++) {
            const x = rect.left + (i * (rect.width / 20));
            const particle = this.createParticle(x, y, {
                color: isSpecial ? 'yellow' : 'blue',
                size: Math.random() * 6 + 2,
                duration: 1000 + Math.random() * 1000
            });
            
            // Animate particle
            particle.style.animation = `particle-float ${1 + Math.random()}s ease-out forwards`;
        }
    }

    createTetrisEffect() {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const radius = Math.random() * 100 + 50;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            this.createParticle(x, y, {
                color: ['pink', 'yellow', 'green', 'purple'][Math.floor(Math.random() * 4)],
                size: Math.random() * 8 + 4,
                duration: 2000
            });
        }
    }

    createTSpinEffect(position, isMini) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = rect.left + (position.x * (rect.width / 10));
        const y = rect.top + (position.y * (rect.height / 20));
        
        const particleCount = isMini ? 15 : 30;
        const colors = isMini ? ['purple'] : ['purple', 'pink'];
        
        for (let i = 0; i < particleCount; i++) {
            this.createParticle(
                x + Math.random() * 40 - 20,
                y + Math.random() * 40 - 20,
                {
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 6 + 3,
                    duration: 1500
                }
            );
        }
    }

    createComboEffect(comboCount) {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        for (let i = 0; i < comboCount * 10; i++) {
            const x = centerX + (Math.random() - 0.5) * 200;
            const y = centerY + (Math.random() - 0.5) * 200;
            
            this.createParticle(x, y, {
                color: 'yellow',
                size: Math.random() * 8 + 4,
                duration: 1000 + comboCount * 200
            });
        }
    }

    createLevelUpEffect() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        for (let i = 0; i < 100; i++) {
            const angle = (i / 100) * Math.PI * 2;
            const radius = Math.random() * 200 + 100;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            this.createParticle(x, y, {
                color: 'green',
                size: Math.random() * 6 + 2,
                duration: 3000
            });
        }
    }

    createGameOverEffect() {
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            
            this.createParticle(x, y, {
                color: 'red',
                size: Math.random() * 8 + 2,
                duration: 5000
            });
        }
    }

    createPerfectClearEffect() {
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            
            this.createParticle(x, y, {
                color: ['pink', 'yellow', 'green', 'blue', 'purple'][Math.floor(Math.random() * 5)],
                size: Math.random() * 10 + 4,
                duration: 4000
            });
        }
    }

    startAnimation() {
        // Animation loop for particle updates if needed
        const animate = () => {
            this.animationId = requestAnimationFrame(animate);
        };
        animate();
    }

    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        this.particles = [];
    }
    
    updatePowerUpUI() {
        // Update power-up slots display
        if (this.game.gameMode && this.game.gameMode.powerUpManager) {
            const manager = this.game.gameMode.powerUpManager;
            
            // Update slot displays
            for (let i = 0; i < manager.slots.length; i++) {
                manager.updateSlotDisplay(i);
            }
            
            // Update active power-ups
            manager.updateActivePowerUpsDisplay();
        }
    }
    
    initializePowerUpControls() {
        // Add click handlers for power-up slots
        document.querySelectorAll('.powerup-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const slotIndex = parseInt(slot.dataset.slot);
                if (this.game.gameMode && this.game.gameMode.powerUpManager) {
                    this.game.gameMode.powerUpManager.activatePowerUp(slotIndex);
                }
            });
        });
    }
}
})();

/* scripts/modals.js */
(function() {
// Modern Tetris - Modal Management System


window.ModalManager = class ModalManager {
    constructor(audioManager) {
        this.audioManager = audioManager;
        this.currentModal = null;
        this.leaderboardManager = new LeaderboardManager();
        this.game = null; // Will be set by game instance
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Home screen mode cards
        document.querySelectorAll('.home-mode-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const mode = e.currentTarget.dataset.mode;
                this.selectModeAndStart(mode);
            });
        });
        
        // Home screen buttons
        document.getElementById('home-settings-button')?.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('home-leaderboard-button')?.addEventListener('click', () => {
            this.leaderboardManager.showLeaderboard();
        });
        
        document.getElementById('home-help-button')?.addEventListener('click', () => {
            this.showHelp();
        });
        
        // Game screen buttons
        document.getElementById('back-to-menu')?.addEventListener('click', () => {
            this.backToHome();
        });
        
        document.getElementById('game-help-button')?.addEventListener('click', () => {
            this.showHelp();
        })

        // Mute button
        const muteButton = document.getElementById('mute-button');
        if (muteButton) {
            muteButton.addEventListener('click', () => {
                this.toggleMute();
            });
        }

        // Close buttons
        document.getElementById('close-settings')?.addEventListener('click', () => {
            this.hideSettings();
        });

        document.getElementById('close-help')?.addEventListener('click', () => {
            this.hideHelp();
        });
        
        // Help tabs
        document.querySelectorAll('.help-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                this.switchHelpTab(e.target.dataset.tab);
            });
        });

        // Settings tabs
        document.querySelectorAll('.settings-tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchSettingsTab(e.target.dataset.tab);
            });
        });

        // Audio controls
        this.initializeAudioControls();

        // Close modals on overlay click
        this.initializeOverlayClicks();

        // Keyboard shortcuts for modals
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                this.closeCurrentModal();
            }
        });
    }

    initializeAudioControls() {
        // Volume sliders
        const masterVolume = document.getElementById('master-volume');
        const musicVolume = document.getElementById('music-volume');
        const sfxVolume = document.getElementById('sfx-volume');

        // Volume value displays
        const masterVolumeValue = document.getElementById('master-volume-value');
        const musicVolumeValue = document.getElementById('music-volume-value');
        const sfxVolumeValue = document.getElementById('sfx-volume-value');

        // Toggle checkboxes
        const musicEnabled = document.getElementById('music-enabled');
        const sfxEnabled = document.getElementById('sfx-enabled');

        if (masterVolume && this.audioManager) {
            const settings = this.audioManager.getSettings();
            
            // Set initial values
            masterVolume.value = settings.masterVolume * 100;
            musicVolume.value = settings.musicVolume * 100;
            sfxVolume.value = settings.sfxVolume * 100;
            musicEnabled.checked = settings.musicEnabled;
            sfxEnabled.checked = settings.sfxEnabled;
            
            // Update display values
            masterVolumeValue.textContent = `${Math.round(settings.masterVolume * 100)}%`;
            musicVolumeValue.textContent = `${Math.round(settings.musicVolume * 100)}%`;
            sfxVolumeValue.textContent = `${Math.round(settings.sfxVolume * 100)}%`;

            // Master volume control
            masterVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setMasterVolume(volume);
                masterVolumeValue.textContent = `${e.target.value}%`;
            });

            // Music volume control
            musicVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setMusicVolume(volume);
                musicVolumeValue.textContent = `${e.target.value}%`;
            });

            // SFX volume control
            sfxVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.audioManager.setSFXVolume(volume);
                sfxVolumeValue.textContent = `${e.target.value}%`;
            });

            // Music toggle
            musicEnabled.addEventListener('change', (e) => {
                if (e.target.checked !== settings.musicEnabled) {
                    this.audioManager.toggleMusic();
                }
            });

            // SFX toggle
            sfxEnabled.addEventListener('change', (e) => {
                if (e.target.checked !== settings.sfxEnabled) {
                    this.audioManager.toggleSFX();
                }
            });
        }
    }

    initializeOverlayClicks() {
        // Settings overlay
        const settingsOverlay = document.getElementById('settings-overlay');
        if (settingsOverlay) {
            settingsOverlay.addEventListener('click', (e) => {
                if (e.target === settingsOverlay) {
                    this.hideSettings();
                }
            });
        }

        // Help overlay
        const helpOverlay = document.getElementById('help-overlay');
        if (helpOverlay) {
            helpOverlay.addEventListener('click', (e) => {
                if (e.target === helpOverlay) {
                    this.hideHelp();
                }
            });
        }
    }

    showSettings() {
        const overlay = document.getElementById('settings-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            this.currentModal = 'settings';
            
            // Clear game inputs
            if (window.tetrisGame?.inputManager) {
                window.tetrisGame.inputManager.reset();
            }

            // Update audio settings display
            this.updateAudioSettingsDisplay();
        }
    }

    hideSettings() {
        const overlay = document.getElementById('settings-overlay');
        if (overlay) {
            overlay.style.display = 'none';
            this.currentModal = null;
        }
    }

    showHelp() {
        const overlay = document.getElementById('help-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
            this.currentModal = 'help';
            
            // Clear game inputs
            if (window.tetrisGame?.inputManager) {
                window.tetrisGame.inputManager.reset();
            }

            // Show keyboard tab by default
            this.switchHelpTab('keyboard');
        }
    }
    
    switchHelpTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.help-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update tab content
        document.getElementById('keyboard-controls').style.display = tabName === 'keyboard' ? 'block' : 'none';
        document.getElementById('touch-controls').style.display = tabName === 'touch' ? 'block' : 'none';
        document.getElementById('scoring-system').style.display = tabName === 'scoring' ? 'block' : 'none';
    }

    hideHelp() {
        const overlay = document.getElementById('help-overlay');
        if (overlay) {
            overlay.style.display = 'none';
            this.currentModal = null;
        }
    }

    closeCurrentModal() {
        if (this.currentModal === 'settings') {
            this.hideSettings();
        } else if (this.currentModal === 'help') {
            this.hideHelp();
        } else if (this.currentModal === 'mode-selector') {
            this.hideModeSelector();
        }
    }
    
    // Navigation methods
    selectModeAndStart(modeName) {
        if (this.game) {
            // Hide home screen
            document.getElementById('home-screen').style.display = 'none';
            // Show game screen
            document.getElementById('game-screen').style.display = 'block';
            
            // Select mode
            this.game.selectMode(modeName);
            
            // Show puzzle selection menu for puzzle mode
            if (modeName === 'puzzle' && this.game.uiManager) {
                this.game.uiManager.showPuzzleSelection();
            } 
            // Show AI difficulty selection for battle mode
            else if (modeName === 'battle' && this.game.uiManager) {
                this.game.uiManager.showAIDifficultySelection((difficulty) => {
                    // Start game with selected difficulty
                    this.game.start();
                });
            } else {
                // Start game with new mode
                this.game.start();
            }
        }
    }
    
    backToHome() {
        if (this.game) {
            // Stop game and music
            this.game.state = 'menu';
            this.game.audioManager.stopBackgroundMusic();
            
            // Clear any running timers
            this.game.dropTimer = 0;
            this.game.lockDelay = 0;
            
            // Reset game state completely
            this.game.grid.reset();
            this.game.score = 0;
            this.game.lines = 0;
            this.game.level = 1;
            this.game.combo = 0;
            this.game.currentPiece = null;
            this.game.ghostPiece = null;
            this.game.heldPiece = null;
            this.game.heldPieceUsed = false;
            
            // Reset next pieces
            this.game.pieceBag = new PieceBag();
            this.game.nextPieces = [];
            for (let i = 0; i < 3; i++) {
                this.game.nextPieces.push(this.game.pieceBag.getNextPiece().type);
            }
            
            // Update UI after pieces are reset
            this.game.uiManager.updateNextPieces(this.game.nextPieces);
            
            // Hide game overlay
            this.game.uiManager.hideOverlay();
            
            // Update UI
            this.game.updateUI();
            
            // Show home screen
            document.getElementById('home-screen').style.display = 'flex';
            // Hide game screen  
            document.getElementById('game-screen').style.display = 'none';
        }
    }
    
    setGame(game) {
        this.game = game;
    }

    switchSettingsTab(tab) {
        // Update tab buttons
        document.querySelectorAll('.settings-tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === tab);
        });

        // Show/hide panels
        const audioPanel = document.getElementById('audio-panel');
        const controlsPanel = document.getElementById('controls-panel');

        if (audioPanel && controlsPanel) {
            audioPanel.style.display = tab === 'audio' ? 'block' : 'none';
            controlsPanel.style.display = tab === 'controls' ? 'block' : 'none';
        }
    }

    toggleMute() {
        if (!this.audioManager) return;

        const settings = this.audioManager.getSettings();
        const muteButton = document.getElementById('mute-button');
        
        if (settings.masterVolume > 0) {
            // Mute
            this.audioManager.setMasterVolume(0);
            muteButton.textContent = '';
            muteButton.classList.add('muted');
            muteButton.title = 'Unmute';
        } else {
            // Unmute
            this.audioManager.setMasterVolume(0.7);
            muteButton.textContent = '';
            muteButton.classList.remove('muted');
            muteButton.title = 'Mute';
        }

        // Update settings display if visible
        this.updateAudioSettingsDisplay();
    }

    updateAudioSettingsDisplay() {
        if (!this.audioManager || this.currentModal !== 'settings') return;

        const settings = this.audioManager.getSettings();
        
        // Update sliders
        const masterVolume = document.getElementById('master-volume');
        const musicVolume = document.getElementById('music-volume');
        const sfxVolume = document.getElementById('sfx-volume');
        
        if (masterVolume) masterVolume.value = settings.masterVolume * 100;
        if (musicVolume) musicVolume.value = settings.musicVolume * 100;
        if (sfxVolume) sfxVolume.value = settings.sfxVolume * 100;

        // Update value displays
        const masterVolumeValue = document.getElementById('master-volume-value');
        const musicVolumeValue = document.getElementById('music-volume-value');
        const sfxVolumeValue = document.getElementById('sfx-volume-value');
        
        if (masterVolumeValue) masterVolumeValue.textContent = `${Math.round(settings.masterVolume * 100)}%`;
        if (musicVolumeValue) musicVolumeValue.textContent = `${Math.round(settings.musicVolume * 100)}%`;
        if (sfxVolumeValue) sfxVolumeValue.textContent = `${Math.round(settings.sfxVolume * 100)}%`;

        // Update toggles
        const musicEnabled = document.getElementById('music-enabled');
        const sfxEnabled = document.getElementById('sfx-enabled');
        
        if (musicEnabled) musicEnabled.checked = settings.musicEnabled;
        if (sfxEnabled) sfxEnabled.checked = settings.sfxEnabled;
    }

    populateQuickControls() {
        const quickControls = document.getElementById('quick-controls');
        if (!quickControls) return;

        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        let controlsHTML = '';

        if (isMobile || isTouchDevice) {
            // Show touch controls for mobile
            controlsHTML = `
                <div class="quick-control-item">
                    <span class="quick-control-key"> Tap</span>
                    <span class="quick-control-action">Rotate</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key"> Swipe</span>
                    <span class="quick-control-action">Move</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key"> Swipe Down</span>
                    <span class="quick-control-action">Drop</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key"> Long Press</span>
                    <span class="quick-control-action">Hold</span>
                </div>
            `;
        } else {
            // Show keyboard controls for desktop
            controlsHTML = `
                <div class="quick-control-item">
                    <span class="quick-control-key"></span>
                    <span class="quick-control-action">Move</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key"></span>
                    <span class="quick-control-action">Rotate</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">Space</span>
                    <span class="quick-control-action">Drop</span>
                </div>
                <div class="quick-control-item">
                    <span class="quick-control-key">C</span>
                    <span class="quick-control-action">Hold</span>
                </div>
            `;
        }

        quickControls.innerHTML = controlsHTML;
    }

    // Check if any modal is active
    isAnyModalActive() {
        return this.currentModal !== null;
    }

    // Update mute button state
    updateMuteButton() {
        if (!this.audioManager) return;

        const settings = this.audioManager.getSettings();
        const muteButton = document.getElementById('mute-button');
        
        if (muteButton) {
            if (settings.masterVolume === 0) {
                muteButton.textContent = '';
                muteButton.classList.add('muted');
                muteButton.title = 'Unmute';
            } else {
                muteButton.textContent = '';
                muteButton.classList.remove('muted');
                muteButton.title = 'Mute';
            }
        }
    }
}

// Add styles for quick controls
const quickControlStyles = `
.quick-control-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.quick-control-key {
    background: var(--neon-green);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: var(--font-primary);
    font-weight: 700;
    font-size: 0.8rem;
    min-width: 40px;
    text-align: center;
    box-shadow: 0 0 6px rgba(57, 255, 20, 0.3);
}

.quick-control-action {
    color: var(--text-primary);
    font-weight: 500;
    font-size: 0.9rem;
}
`;

// Inject styles
if (!document.getElementById('quick-control-styles')) {
    const style = document.createElement('style');
    style.id = 'quick-control-styles';
    style.textContent = quickControlStyles;
    document.head.appendChild(style);
}
})();

/* scripts/game.js */
(function() {
// Modern Tetris - Main Game Engine












window.TetrisGame = class TetrisGame {
    constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state
        this.state = 'menu'; // menu, playing, paused, gameover
        this.grid = new Grid();
        this.pieceBag = new PieceBag();
        
        // Current game pieces
        this.currentPiece = null;
        this.ghostPiece = null;
        this.heldPiece = null;
        this.heldPieceUsed = false;
        this.nextPieces = [];
        
        // Timing
        this.lastTime = 0;
        this.dropTimer = 0;
        this.dropInterval = 1000; // 1 second initially
        
        // Scoring
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.combo = 0;
        
        // Special achievements tracking
        this.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        // Game mechanics
        this.lockDelay = 0;
        this.maxLockDelay = 500;
        this.lastPiecePosition = null;
        
        // Systems
        this.audioManager = new AudioManager();
        this.inputManager = new InputManager(this);
        this.uiManager = new UIManager(this);
        this.modalManager = new ModalManager(this.audioManager);
        this.modalManager.setGame(this); // Connect modal manager to game
        
        // Mode system
        this.modeSelector = new ModeSelector();
        this.gameMode = null;
        this.currentModeName = 'classic';
        
        // Store piece module reference for UI
        this.pieceModule = { Piece, PIECE_TYPES };
        
        // Track game start time for duration calculation
        this.gameStartTime = Date.now();
        
        this.initializeGame();
        this.startGameLoop();
    }

    initializeGame() {
        // Setup canvas
        this.setupCanvas();
        
        // Add resize listener
        window.addEventListener('resize', () => {
            this.setupCanvas();
        });
        
        // Generate initial next pieces
        for (let i = 0; i < 3; i++) {
            this.nextPieces.push(this.pieceBag.getNextPiece().type);
        }
        
        // Update UI
        this.updateUI();
        
        // Initialize PWA install handler
        this.initializePWAInstall();
    }

    setupCanvas() {
        // Fixed internal resolution
        const internalWidth = 400;
        const internalHeight = 800;
        
        // Set internal dimensions
        this.canvas.width = internalWidth;
        this.canvas.height = internalHeight;
        
        // CSS will handle the display size
        // The canvas will scale to fit its container
        
        // Setup rendering context
        this.ctx.imageSmoothingEnabled = false;
        this.cellSize = internalWidth / GRID_WIDTH;
        
        // Log for debugging
        console.log('Canvas setup:', {
            width: this.canvas.width,
            height: this.canvas.height,
            cellSize: this.cellSize
        });
    }

    // Game loop
    startGameLoop() {
        let lastRenderTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;
        
        const gameLoop = (currentTime) => {
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            // Always update game logic
            this.update(deltaTime);
            
            // Limit rendering to 60 FPS for better performance
            if (currentTime - lastRenderTime >= frameTime) {
                this.render();
                lastRenderTime = currentTime;
            }
            
            requestAnimationFrame(gameLoop);
        };
        
        requestAnimationFrame(gameLoop);
    }

    update(deltaTime) {
        if (this.state !== 'playing') {
            this.inputManager.update(deltaTime);
            return;
        }
        
        this.inputManager.update(deltaTime);
        this.updateGameLogic(deltaTime);
    }

    updateGameLogic(deltaTime) {
        // Update game mode first
        if (this.gameMode) {
            const continueGame = this.gameMode.update(deltaTime);
            if (!continueGame) {
                // Mode has ended
                return;
            }
        }
        
        if (!this.currentPiece) {
            this.spawnNextPiece();
            return;
        }
        
        // Update drop timer
        this.dropTimer += deltaTime;
        
        // Natural drop
        if (this.dropTimer >= this.dropInterval) {
            this.dropTimer = 0;
            this.dropPiece();
        }
        
        // Update ghost piece
        this.updateGhostPiece();
        
        // Handle lock delay
        if (this.currentPiece.shouldLock(this.grid)) {
            if (this.currentPiece.updateLockDelay(deltaTime)) {
                this.lockPiece();
            }
        } else {
            this.currentPiece.resetLockDelay();
        }
        
        // Update UI
        this.updateUI();
    }

    // Piece spawning
    spawnNextPiece() {
        if (this.nextPieces.length === 0) return;
        
        // Get next piece type and create piece
        const pieceType = this.nextPieces.shift();
        this.currentPiece = new Piece(pieceType, 3, 0);
        
        // Add new piece to next queue
        this.nextPieces.push(this.pieceBag.getNextPiece().type);
        
        // Reset hold piece usage
        this.heldPieceUsed = false;
        
        // Check game over
        if (this.grid.checkCollision(this.currentPiece)) {
            this.gameOver();
            return;
        }
        
        // Update UI
        this.uiManager.updateNextPieces(this.nextPieces);
    }

    // Piece movement
    movePiece(dx, dy) {
        if (!this.currentPiece || this.state !== 'playing') return false;
        
        const newPiece = this.currentPiece.copy();
        newPiece.move(dx, dy);
        
        if (!this.grid.checkCollision(newPiece)) {
            this.lastPiecePosition = this.currentPiece.copy();
            this.currentPiece = newPiece;
            
            // Play move sound
            this.audioManager.playSFX('move');
            
            // Reset lock delay on successful movement
            if (this.currentPiece.shouldLock(this.grid)) {
                this.currentPiece.resetLockDelay();
            }
            
            return true;
        }
        
        return false;
    }

    // Piece rotation
    rotatePiece(direction = 1) {
        if (!this.currentPiece || this.state !== 'playing') return false;
        
        const rotatedPiece = this.grid.testPieceRotation(this.currentPiece, direction);
        
        if (rotatedPiece) {
            this.lastPiecePosition = this.currentPiece.copy();
            this.currentPiece = rotatedPiece;
            
            // Play rotate sound
            this.audioManager.playSFX('rotate');
            
            return true;
        }
        
        return false;
    }

    // Soft drop
    softDrop() {
        if (this.movePiece(0, 1)) {
            this.score += 1;
            this.dropTimer = 0;
            // Move sound is already played in movePiece
        }
    }

    // Hard drop
    hardDrop() {
        if (!this.currentPiece || this.state !== 'playing') return;
        
        const originalY = this.currentPiece.y;
        let dropDistance = 0;
        
        // Temporarily disable move sound for hard drop
        const originalPlaySFX = this.audioManager.playSFX;
        this.audioManager.playSFX = () => {};
        
        while (this.movePiece(0, 1)) {
            dropDistance++;
        }
        
        // Restore sound and play drop sound
        this.audioManager.playSFX = originalPlaySFX;
        this.audioManager.playSFX('drop');
        
        this.score += dropDistance * 2;
        this.lockPiece();
    }

    // Natural drop
    dropPiece() {
        if (!this.movePiece(0, 1)) {
            // Can't move down, start lock delay
            this.currentPiece.lockDelay = this.currentPiece.lockDelay || 0;
        }
    }

    // Hold piece
    holdPiece() {
        if (!this.currentPiece || this.heldPieceUsed || this.state !== 'playing') return;
        
        if (this.heldPiece) {
            // Swap current and held pieces
            const temp = this.heldPiece;
            this.heldPiece = this.currentPiece.type;
            this.currentPiece = new Piece(temp, 3, 0);
        } else {
            // Hold current piece and spawn next
            this.heldPiece = this.currentPiece.type;
            this.spawnNextPiece();
        }
        
        this.heldPieceUsed = true;
        this.audioManager.playSFX('hold');
        this.uiManager.updateHoldPiece(this.heldPiece ? new Piece(this.heldPiece) : null);
    }

    // Lock piece in place
    lockPiece() {
        if (!this.currentPiece) return;
        
        // Check for T-Spin
        const tspinResult = TSpinDetector.isTSpin(this.currentPiece, this.grid, this.lastPiecePosition);
        
        // Place piece on grid
        this.grid.placePiece(this.currentPiece);
        
        // Notify game mode that a piece was placed
        if (this.gameMode && this.gameMode.handlePiecePlaced) {
            this.gameMode.handlePiecePlaced();
        }
        
        // Play lock sound
        this.audioManager.playSFX('lock');
        
        // Process line clearing immediately and completely
        this.processLineClear(tspinResult);
        
        // Check if the game mode is complete or will be complete
        const isModeComplete = this.gameMode && 
            (this.gameMode.isComplete || this.gameMode.pendingCompletion);
        
        // For puzzle mode, don't check game over if objective is met or pending
        if (isModeComplete) {
            this.currentPiece = null;
            return; // Exit early if mode is complete
        }
        
        // Check game over only if mode is not complete
        if (this.grid.isGameOver()) {
            // For puzzle mode, give it one last chance to check objective
            if (this.gameMode && this.gameMode.name === 'Puzzle') {
                // Final check for objective completion
                if (this.gameMode.checkObjectiveComplete && this.gameMode.checkObjectiveComplete()) {
                    this.gameMode.isComplete = true;
                    this.gameMode.pendingCompletion = true;
                    this.currentPiece = null;
                    return;
                }
            }
            this.gameOver();
        } else {
            this.currentPiece = null;
        }
    }

    // Process line clearing with proper sequencing
    processLineClear(tspinResult) {
        // Get lines to clear BEFORE clearing them for animation
        const linesToClear = this.grid.getCompletedLines();
        
        if (linesToClear.length === 0) {
            return; // No lines to clear
        }
        
        // Clear the lines from the grid immediately using the detected lines
        const actualCleared = this.grid.clearLines(linesToClear);
        
        // Track special achievements
        this.updateSpecialAchievements(tspinResult, actualCleared);
        
        // Show effects and play sounds using original line positions
        this.playLineClearEffects(actualCleared, linesToClear, tspinResult);
        
        // Calculate and update score
        this.calculateScore(actualCleared, tspinResult);
        
        // Check for perfect clear bonus
        if (this.grid.isPerfectClear() && actualCleared > 0) {
            this.specialAchievements.perfectClears++;
            this.uiManager.showPerfectClearEffect();
            this.score += 10000 * this.level; // Bonus for perfect clear
        }
        
        // Update level after processing everything
        this.updateLevel();
    }

    // Update special achievements tracking
    updateSpecialAchievements(tspinResult, clearedLines) {
        // Track T-Spins
        if (tspinResult.type === 'tspin') {
            if (tspinResult.mini) {
                this.specialAchievements.tspinMinis++;
            } else {
                this.specialAchievements.tspins++;
            }
        }
        
        if (clearedLines === 4) {
            this.specialAchievements.tetris++;
        }
    }

    // Play line clear effects and sounds
    playLineClearEffects(clearedLines, originalLinePositions, tspinResult) {
        if (clearedLines > 0) {
            // Show visual effects using original line positions
            this.uiManager.showLineClearEffect(originalLinePositions, clearedLines === 4);
            
            // Play appropriate sound
            if (clearedLines === 4) {
                this.audioManager.playSFX('tetris');
            } else {
                this.audioManager.playSFX('lineClear');
            }
        }
        
        if (tspinResult.type === 'tspin') {
            this.audioManager.playSFX('tspin');
            this.uiManager.showTSpinEffect(this.currentPiece, tspinResult.mini);
        }
    }

    // Calculate score based on lines cleared and special moves
    calculateScore(linesCleared, tspinResult) {
        // Delegate to game mode if available
        if (this.gameMode) {
            const specialClear = {
                type: tspinResult.type,
                mini: tspinResult.mini,
                perfectClear: this.grid.isPerfectClear()
            };
            this.gameMode.handleLineClears(linesCleared, specialClear);
            return;
        }
        
        // Fallback to default scoring (for backward compatibility)
        if (linesCleared === 0) {
            this.combo = 0;
            return;
        }
        
        let baseScore = 0;
        let multiplier = this.level;
        
        // Base scoring
        switch (linesCleared) {
            case 1:
                baseScore = tspinResult.type === 'tspin' ? 
                    (tspinResult.mini ? 200 : 800) : 100;
                break;
            case 2:
                baseScore = tspinResult.type === 'tspin' ? 1200 : 300;
                break;
            case 3:
                baseScore = tspinResult.type === 'tspin' ? 1600 : 500;
                break;
            case 4:
                baseScore = 800; // Tetris
                break;
        }
        
        // Combo bonus
        this.combo++;
        if (this.combo > 1) {
            baseScore += 50 * this.combo * multiplier;
            this.uiManager.showComboEffect(this.combo);
            this.specialAchievements.combos++;
        }
        
        // Perfect clear bonus
        if (this.grid.isPerfectClear()) {
            baseScore *= 10;
        }
        
        this.score += baseScore * multiplier;
        this.lines += linesCleared;
    }

    // Update game level
    updateLevel() {
        const newLevel = Math.floor(this.lines / 10) + 1;
        if (newLevel > this.level) {
            this.level = newLevel;
            this.audioManager.playSFX('levelUp');
            // Update music tempo based on new level
            this.audioManager.setGameLevel(this.level);
            this.updateDropSpeed();
        }
    }

    // Update drop speed based on level
    updateDropSpeed() {
        // Standard Tetris drop speed formula
        if (this.level <= 8) {
            this.dropInterval = (48 - 5 * this.level) * 16.67; // ~60 FPS
        } else if (this.level <= 10) {
            this.dropInterval = (8 - this.level) * 16.67;
        } else if (this.level <= 12) {
            this.dropInterval = 16.67; // 1 frame
        } else if (this.level <= 15) {
            this.dropInterval = 13.33; // ~3/4 frame
        } else if (this.level <= 18) {
            this.dropInterval = 8.33; // 1/2 frame
        } else if (this.level <= 28) {
            this.dropInterval = 6.67; // 1/3 frame
        } else {
            this.dropInterval = 3.33; // 1/5 frame
        }
    }

    // Update ghost piece
    updateGhostPiece() {
        if (this.currentPiece) {
            this.ghostPiece = this.grid.getGhostPosition(this.currentPiece);
        } else {
            this.ghostPiece = null;
        }
    }

    // Update UI elements
    updateUI() {
        this.uiManager.updateStats({
            score: this.score,
            lines: this.lines,
            level: this.level
        });
    }

    // Select and initialize game mode
    selectMode(modeName) {
        this.currentModeName = modeName || 'classic';
        this.gameMode = this.modeSelector.createModeInstance(this.currentModeName, this);
        
        if (this.gameMode) {
            this.gameMode.initialize();
            this.uiManager.updateModeDisplay(this.gameMode.getModeUI());
            return true;
        }
        return false;
    }
    
    // Game state management
    async start() {
        // Initialize game mode if not already done
        if (!this.gameMode) {
            this.selectMode('classic');
        }
        
        this.state = 'playing';
        this.gameStartTime = Date.now(); // Reset game start time
        this.uiManager.hideOverlay();
        
        // Start the game mode
        if (this.gameMode) {
            this.gameMode.start();
        }
        
        // Ensure audio context is ready
        await this.audioManager.resumeAudioContext();
        
        // Set initial game level for music tempo
        this.audioManager.setGameLevel(this.level);
        
        // Start background music
        this.audioManager.startBackgroundMusic();
        
        this.spawnNextPiece();
    }

    pause() {
        if (this.state === 'playing') {
            this.state = 'paused';
            this.uiManager.showPauseOverlay();
        }
    }

    resume() {
        if (this.state === 'paused') {
            this.state = 'playing';
            this.uiManager.hideOverlay();
        }
    }

    togglePause() {
        if (this.state === 'playing') {
            this.pause();
        } else if (this.state === 'paused') {
            this.resume();
        }
    }

    restart() {
        // Reset game state
        this.grid.reset();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        // Reset music tempo to level 1
        this.audioManager.setGameLevel(1);
        this.combo = 0;
        this.dropTimer = 0;
        
        // Reset special achievements
        this.specialAchievements = {
            tspins: 0,
            tspinMinis: 0,
            tetris: 0,
            combos: 0,
            perfectClears: 0
        };
        
        this.updateDropSpeed();
        
        this.currentPiece = null;
        this.ghostPiece = null;
        this.heldPiece = null;
        this.heldPieceUsed = false;
        
        // Reset piece bag
        this.pieceBag = new PieceBag();
        this.nextPieces = [];
        for (let i = 0; i < 3; i++) {
            this.nextPieces.push(this.pieceBag.getNextPiece().type);
        }
        
        // Update UI
        this.uiManager.updateNextPieces(this.nextPieces);
        this.uiManager.updateHoldPiece(null);
        
        this.start();
    }

    gameOver(isVictory = false, customStats = null) {
        this.state = 'gameover';
        
        // Stop background music and play appropriate sound
        this.audioManager.stopBackgroundMusic();
        
        if (isVictory) {
            this.audioManager.playSFX('levelUp');
        } else {
            this.audioManager.playSFX('gameOver');
        }
        
        // Use custom stats if provided (for modes like Sprint)
        const finalStats = customStats || {
            score: this.score,
            lines: this.lines,
            level: this.level
        };
        
        // Prepare special achievements for database
        const dbAchievements = {
            tspins: this.specialAchievements.tspins + this.specialAchievements.tspinMinis,
            combos: this.specialAchievements.combos,
            tetris: this.specialAchievements.tetris,
            perfectClears: this.specialAchievements.perfectClears
        };
        
        // Update player progression and achievements
        const gameResults = {
            mode: this.gameMode ? this.gameMode.name.toLowerCase() : 'classic',
            score: finalStats.score,
            lines: finalStats.lines,
            level: finalStats.level,
            time: Date.now() - this.gameStartTime,
            combo: this.combo,
            tspins: dbAchievements.tspins,
            tetris: dbAchievements.tetris,
            perfectClears: dbAchievements.perfectClears,
            isVictory: isVictory
        };
        
        // Calculate and award XP
        const xpEarned = playerProgression.calculateGameXP(gameResults);
        playerProgression.addXP(xpEarned, 'gameplay');
        playerProgression.updateStats(gameResults);
        
        // Check achievements
        achievementSystem.updateProgress('totalLines', this.lines, true);
        achievementSystem.updateProgress('highScore', this.score);
        achievementSystem.updateProgress('maxCombo', this.combo);
        achievementSystem.updateProgress('tspins', dbAchievements.tspins, true);
        achievementSystem.updateProgress('perfectClears', dbAchievements.perfectClears, true);
        
        // Set game start time for score saver
        this.uiManager.scoreSaver.setGameStartTime(this.gameStartTime);
        
        // Show appropriate overlay based on victory status
        if (!isVictory) {
            // Regular game over
            this.uiManager.showGameOverOverlay(finalStats, dbAchievements);
        }
        // For victory cases, the mode handles showing its own victory overlay
    }
    
    // Add helper method for modes to trigger game over
    triggerGameOver(isVictory = false, customStats = null) {
        this.gameOver(isVictory, customStats);
    }

    handleConfirm() {
        if (this.state === 'menu' || this.state === 'gameover') {
            this.start();
        }
    }

    // Rendering
    render() {
        this.clearCanvas();
        
        if (this.state === 'playing' || this.state === 'paused') {
            this.renderGrid();
            this.renderGhostPiece();
            this.renderCurrentPiece();
            this.renderGridLines();
            
            // Update mode-specific UI
            if (this.gameMode && this.uiManager) {
                this.uiManager.updateModeUI(this.gameMode.getModeUI());
            }
        }
    }

    clearCanvas() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    renderGrid() {
        const gridData = this.grid.getRenderData();
        
        gridData.forEach(cell => {
            this.renderCell(cell.x, cell.y, cell.color, false);
        });
    }

    renderCurrentPiece() {
        if (!this.currentPiece) return;
        
        const blocks = this.currentPiece.getBlocks();
        blocks.forEach(block => {
            if (block.y >= 4) { // Only render visible blocks
                this.renderCell(block.x, block.y - 4, block.color, false);
            }
        });
    }

    renderGhostPiece() {
        if (!this.ghostPiece) return;
        
        const blocks = this.ghostPiece.getBlocks();
        blocks.forEach(block => {
            if (block.y >= 4) { // Only render visible blocks
                this.renderCell(block.x, block.y - 4, block.color, true);
            }
        });
    }

    renderCell(x, y, color, isGhost = false) {
        const cellX = x * this.cellSize;
        const cellY = y * this.cellSize;
        
        this.ctx.save();
        
        if (isGhost) {
            this.ctx.globalAlpha = 0.3;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(cellX + 1, cellY + 1, this.cellSize - 2, this.cellSize - 2);
        } else {
            // Filled block with glow effect
            this.ctx.fillStyle = color;
            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
            
            // Inner highlight
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.fillRect(cellX + 1, cellY + 1, this.cellSize - 2, 2);
            this.ctx.fillRect(cellX + 1, cellY + 1, 2, this.cellSize - 2);
            
            // Border
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(cellX, cellY, this.cellSize, this.cellSize);
        }
        
        this.ctx.restore();
    }

    renderGridLines() {
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.lineWidth = 0.5;
        
        // Vertical lines
        for (let x = 0; x <= GRID_WIDTH; x++) {
            const lineX = x * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(lineX, 0);
            this.ctx.lineTo(lineX, GRID_HEIGHT * this.cellSize);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y <= GRID_HEIGHT; y++) {
            const lineY = y * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(0, lineY);
            this.ctx.lineTo(GRID_WIDTH * this.cellSize, lineY);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
    
    initializePWAInstall() {
        let deferredPrompt;
        const installButton = document.getElementById('install-button');
        
        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Show install button
            if (installButton) {
                installButton.style.display = 'inline-block';
                
                installButton.addEventListener('click', async () => {
                    if (deferredPrompt) {
                        // Show the install prompt
                        deferredPrompt.prompt();
                        
                        // Wait for the user to respond to the prompt
                        const { outcome } = await deferredPrompt.userChoice;
                        
                        if (outcome === 'accepted') {
                            console.log('User accepted the install prompt');
                            installButton.style.display = 'none';
                        } else {
                            console.log('User dismissed the install prompt');
                        }
                        
                        // Clear the deferredPrompt for use later
                        deferredPrompt = null;
                    }
                });
            }
        });
        
        // Hide button if already installed
        window.addEventListener('appinstalled', () => {
            if (installButton) {
                installButton.style.display = 'none';
            }
            console.log('PWA was installed');
        });
        
        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches || 
            window.navigator.standalone === true) {
            if (installButton) {
                installButton.style.display = 'none';
            }
        }
    }
}

// Initialize game when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.tetrisGame = new TetrisGame();
});
})();

// Initialize the game when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log(' Initializing standalone Tetris...');
    
    // Set file mode context
    window.TetrisContext = {
        isFileProtocol: true,
        isLocalhost: false,
        hasServiceWorker: false,
        mode: 'standalone'
    };
    
    // Initialize game
    if (window.TetrisExports.Game) {
        window.game = new window.TetrisExports.Game();
    } else if (window.Game) {
        window.game = new window.Game();
    }
    
    console.log(' Standalone Tetris ready!');
});

</script>
</body>
</html>